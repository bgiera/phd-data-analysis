import copyimport numpy as npimport EDLCalcs#test test#from scipy import integrate#from scipy.optimize import leastsq#from scipy import interpolate#import matplotlib.pyplot as plt#from matplotlib.colors import LinearSegmentedColormapimport gzip#from mpl_toolkits.mplot3d import Axes3D#from matplotlib import cm#from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter #import	cProfile#These others get imported as needed within the functions that require them.#import matplotlib.patches as patches#import matplotlib.path as path#import scipy#import scipy, pylab#import scipy.optimize#To access Mellon's filesystem @ UCSB:#sshfs -C bgiera@mellon.chemengr.ucsb.edu:/home/bgiera /Users/bgiera/Documents/mellon	#and then to turn it off#umount /Users/bgiera/Documents/mellon#To access Mellon's filesystem @ LANL:#sshfs -C bgiera@mellon.chemengr.ucsb.edu:/home/bgiera ~/mellon	#and then to turn it off#fusermount -u /n/srv/bgiera/mellon#To connect to Estella (owned and operated by Creative Consultants - PROVIDE CONTACT INFO#ssh bgiera@70.90.200.25#ssh glscantlen@70.90.200.25#PW: Hint-backwards_login#ssh c4hdn-la#To run files on Esteall#PROVIDE DIRECTIONS#To copy files from Estella to LANL machine:#scp -Crp -o "ProxyCommand ssh bgiera@70.90.200.25 nc c4hdn-la 22" c4hdn-la:~/N_800_LB_1_sig_7_z_1.5_REDO .#To Upgrade LAMMPS#1) Download tar file to personal laptop (this probably could be changed) from http://lammps.sandia.gov/download.html#2) scp -r ~/Desktop/lammps.tar.gz/ lab@mellon.chemengr.ucsb.edu:~/src#3) ssh lab@mellon.chemengr.ucsb.edu#4) cd ~/src/#5) tar -zxvf lammps.tar.gz#6-think) cp ~/src/Makefile.g++ lammps-NEW_VERSION/src/MAKE # copy the last working makefile.g++ from cd ~/src/ to ~/src/#7) cd ~/src/lammps-NEW_VERSION/src> #8) make g++#9) Pray#10) cp lmp_g++ /home/lab/src/#11) cd ../../#12) sudo scp lmp_g++  bgiera@mellon:Stable_DeleteRawDatas/#13) Move lmp_g++ to newly named folder#14) Run data.py with LAMMPS_Validation() using X11#LAMMPS Runscript#nohup mpiexec -np 8 lmp_g++ < in.040510_z0.50 > THERMO.txt &##Web stuff, unrelated to research#These commands are performed from: ~/#scp -r Documents/Research_Docs/Web/* lab@squerver.chemengr.ucsb.edu: #ssh lab@squerver.chemengr.ucsb.edu#sudo cp -r Squires_Group,_UCSB/* www/#To routine update all computers:#ssh -Y lab@mellon.chemengr.ucsb.edu#cssh squiresgroup#(login and wait)#screen    - NOT screen -r#sudo aptitude update&&sudo aptitude full-upgrade#Sometimes need to do this first: sudo rm /var/lib/dpkg/lock && sudo dpkg --configure -a#sudo rm /var/lib/dpkg/lock && sudo rm /var/lock/aptitude#To add a new user to the SquWiki#Login as: lab_super (PW: squiresgroup)#Click the "Admin" button at bottom of page#To compress files and tar the folder:#tar -zcvf archive_name.tar.gz directory_to_compress &#To uncompress files:#tar -zxvf archive_name.tar.gz &#To send off an Archive to Gould:#1) Create an arhive folder on mellon (~/Archive/Archive_XX) and fill it with everything that is to be moved into archive#2) cd ~/Archive && ls -lR Archive_XX > Contents_of_AXX.txt & #3) Open a screen#4) scp -r Archive_XX share@gould.chemengr.ucsb.edu:~/share/bgiera/mellon/.#5) ssh share@gould.chemengr.ucsb.edu#6) Compress it with the above compression instructions##To backup research files from personal computer (a direct copy):#scp -r Documents/Research_Docs share@gould.chemengr.ucsb.edu:~/share/bgiera/.def MyHist(Pos,bin):    """Returns a histogram of the z-positions for ions.    This does the exact thing as np.histogram() before numpy was updated!Input:    Pos:  (N,many) sorted array of atomic positions    bin:  vector of bin dimensionsOutput:	counts:	a histogram of counts for z-values within their respective bins"""        #Start with zeroed bins    counts= np.zeros(len(bin)-1, int)    k_store=0    for x in sorted(Pos): #Scroll through all the ion positions of Pos        k,get_next_x=k_store,False        while (k<(len(bin)-1) and not(get_next_x)): #iterate through all the bin sets	  if x>=bin[k] and x<bin[k+1]: #check to see if the z-position is within a particular bin	    counts[k]+=1	    k=k_store	    get_next_x=True	  k+=1 #iterare the bin index           return counts    def Transient_GC_System(filename,Bjerrum,r_ion):    """This function performs similar duties as     GC_System(filename,Bjerrum,Numbins,r_ion) above in the sense that it     reads and processes MD output.	This function is underdevelopment and will evolve alongside the MD	simulation that generates this. - 11/02/11 14:47:58 Input    filename: str() the name of the file with MD trajectory data    Bjerrum:  float() the Bjerrum length that was set for the system    r_ion:    float() the WCA radius of the ion OR    		list() of WCA radii r_ion =[smaller,larger]    M_per_slice: number of insertions per bin for muex_EV calculations    ##CONSIDER ADDING VALENCY AS A FUCNTION INPUT!Output:    None, only printed statements that are written to a .txt file from the command line"""    #These are hard coded values that cannot be determined from Data[]    valency=1.0    r_wall=1.0    eps_wall=1.0    eps_WCA=1.0    filename_orignal=filename    if filename[-3:]=='.gz':        Data=gzip.GzipFile(fileobj=open(filename,'rb'))	filename=filename[0:len(filename)-2]+'txt'    else:        Data=file(filename,"r")    print '\n'    print filename    dielectric=(4*np.pi*Bjerrum)**-1 #This used to be dielectric=Bjerrum**-1#    graph_prefix=str(Numbins) + filename[4:len(filename)-4]    #Create empty vectors to fill    BA_Data,BA_z=[],[]    BC_Data,BC_z=[],[]#    Pos_A,Pos_C=[],[]    ze=str(filename[-9:-4])#    print 'The goal as of 11/05/10 16:08:46 should be to feed Sigma_s via the LAMMPS filename.'    if type(r_ion) == type(0.5):			    if Bjerrum==7.0 and r_ion==3.5:		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':			Sigma_s=0.00836*dielectric		if ze=='0.500':			Sigma_s=0.01684*dielectric		if ze=='0.750':			Sigma_s=0.02559*dielectric		if ze=='1.000':			Sigma_s=0.03474*dielectric		if ze=='1.250':			Sigma_s=0.04443*dielectric		if ze=='1.500':			Sigma_s=0.05482*dielectric		if ze=='1.750':			Sigma_s=0.06607*dielectric		if ze=='2.000':			Sigma_s=0.07835*dielectric		if ze=='2.250':			Sigma_s=0.09185*dielectric		if ze=='2.500':			Sigma_s=0.10679*dielectric		if ze=='2.750':			Sigma_s=0.12341*dielectric		if ze=='3.000':			Sigma_s=0.14195*dielectric		if ze=='3.250':			Sigma_s=0.16272*dielectric		if ze=='3.500':			Sigma_s=0.18603*dielectric		if ze=='4.000':			Sigma_s=0.24179*dielectric		if ze=='5.000':			Sigma_s=0.40335*dielectric	    else:		Sigma_s=0.0000		print 'Sigma_s was set to a default value of 0.000'		#This code is as new as 11/05/10 16:07:32         nth=1     # new addition, untested (prob need to add a k+=1 near qz_avg) - 02/10/10 13:17:25 , also never actually used... - 11/18/10 11:47:02        n_obs=0    i=0     get_time=0	    get_box_dims=0    time_old=-1000    time_new=time_old    charges=1    Q_DL=[]    t_index=0    jj=0    for y in Data:          x=y.split()            ##This gets the current time_step      if get_time==1:        time_old=time_new	time_new=int(x[0])      	get_time=0	      if len(x)==2:      	if x[1]=='TIMESTEP':     		get_time=1      ##Format for x is:#     x= [id type x y z xu yu zu vx vy vz fx fy fz]      get_box_dims+=1      if get_box_dims<=8:	if get_box_dims==6:	  L_x=float(x[1])-float(x[0])	elif get_box_dims==7:	  L_y=float(x[1])-float(x[0])	  area=L_x*L_y	elif get_box_dims==8:	  L_box=float(x[1])-float(x[0])	  z_wall=-0.5*L_box+r_wall	        if not x[0]=="ITEM:":	x=[float(xx) for xx in x]	if len(x)<=2:	  i+=1	  if i==6: #This means an entire timestep worth of data is had	    n_obs+=1	    BA_z=np.array(BA_z)	    BC_z=np.array(BC_z)	    NA_L= len(BA_z[BA_z<0.])	    NA_R= len(BA_z[BA_z>=0.])	    NC_L= len(BC_z[BC_z<0.])	    NC_R= len(BC_z[BC_z>=0.])	    mean_qdl = ((NA_L-NC_L) + (NC_R-NA_R))*0.5	    if charges==1:	    	Q_DL.append(mean_qdl)	    else:	    	Q_DL[t_index]+=mean_qdl ##Remove this, too#	    print Q_DL,t_index,time_old,BA_z	    if time_old>time_new:		charges+=1		t_index=0 	            else:		t_index+=1	    BA_z=[]	    BC_z=[]	    i=1	elif x[1]==1:	  BA_z.append(x[4])	elif x[1]==2:	  BC_z.append(x[4])    #And to get the last (tricky) snapshot... - 4/27/11 @ 3.30p    print jj    n_obs+=1    BA_z=np.array(BA_z)    BC_z=np.array(BC_z)    NA_L= len(BA_z[BA_z<0.])    NA_R= len(BA_z[BA_z>=0.])    NC_L= len(BC_z[BC_z<0.])    NC_R= len(BC_z[BC_z>=0.])    mean_qdl = ((NA_L-NC_L) + (NC_R-NC_R))*0.5    Q_DL[t_index]+=mean_qdl	    #Average the results (negative sign just to flip curves over x-axis):    Q_DL=-np.array(Q_DL)/float(charges)       print "Writing analyzed data to file..."    	##Do averages here!    total_prefix='Transient_' + filename[4:len(filename)-4]    total_output=file(total_prefix+"_DATA.txt","w")    for q in Q_DL:    	total_output.write("%-1.5f\n" % (q))        total_output.close()    print 'Finished ' + filename_orignal    return#Transient_GC_System('1000_tr_zeta_2.500.txt',1.0,0.5)#Transient_GC_System('1000_tr_zeta_1.250.txt',1.0,0.5)def Calc_Volt(z_positions,z_plus,z_minus,Sigma_s,epsilon,A_xy):    """Input:    z_positions:   Bin discretation    z_plus:	   array of z positions for cations (attracted to right plate)    z_minus:	   array of z positions for anions (attracted to left plate)    Sigma_s:	   the applied surface charge density    epsilon:	   dialectric, or inverse bjerrum    A_xy:	   Cross-sectional area of simulation boxOutput:    Psi_tot:	   Final calculation of the voltage    E_tot:	   Final calculation of Efield"""  #Initialize array of potential and field       E_tot=np.ones(len(z_positions), dtype=float)*(Sigma_s/epsilon)    Psi_tot=[-Sigma_s/epsilon*z for z in z_positions]    charge=1.    for (i,z) in enumerate(z_positions):	for z_charge in z_plus[z_plus<=z]:	    Psi_tot[i]=Psi_tot[i]-charge*(z-z_charge)/(epsilon*A_xy)	    E_tot[i]=E_tot[i]-charge/(epsilon*A_xy)    charge=-1.    for (i,z) in enumerate(z_positions):	for z_charge in z_minus[z_minus<=z]:	    Psi_tot[i]=Psi_tot[i]-charge*(z-z_charge)/(epsilon*A_xy)	    E_tot[i]=E_tot[i]-charge/(epsilon*A_xy)	        return np.array(Psi_tot),np.array(E_tot)def quickCalc_VoltandField(z_positions,z_plus,z_minus,Sigma_s,epsilon,A_xy,valence):    """    This calculates the following this using Fortran (f2py)Input:    z_positions:   Bin discretation    z_plus:	   array of z positions for cations (attracted to right plate)    z_minus:	   array of z positions for anions (attracted to left plate)    Sigma_s:	   the applied surface charge density    epsilon:	   dialectric, or inverse bjerrum    A_xy:	   Cross-sectional area of simulation boxOutput:    Psi_tot:	   Final calculation of the voltage    E_tot:	   Final calculation of Efield"""  #Initialize array of potential and field       E_tot=np.ones(len(z_positions), dtype=float)*(Sigma_s/epsilon)    Psi_tot=np.array([-Sigma_s/epsilon*z for z in z_positions])    Psi_tot,E_tot = EDLCalcs.calcvoltandfield(np.array(z_positions), np.array(z_plus), np.array(z_minus), epsilon, A_xy, valence, Psi_tot, E_tot, len(z_positions), len(z_plus))	        return np.array(Psi_tot),np.array(E_tot)def Calc_muex_EV(z_positions,Pos_A,Pos_C,M,r_ion,eps_WCA,A_xy):	    """	Input:	    z_positions:   Bin discretation	    Pos_A:	   array of (x,y,z) positions for ions (attracted to right plate)	    Pos_C:	   array of (x,y,z) positions for ions (attracted to left plate)	    M:		   the number of random insertions per bin	    r_ion:	   WCA radius for ions	    eps_WCA:	   Energy scale for WCA potential	    A_xy:	   Cross-sectional area of simulation box	Output:	    exp_muex_EV:	   Excluded volume contributions to mu_ex 	    			NOTE: muex_EV[z] = -ln(exp_muex_EV[z]/n_obs) must be taken before printing 	"""	    import random	    L_xy = A_xy**0.5	    hL_xy=L_xy*0.5	    iL_xy=1./L_xy	    sig_WCA=2*r_ion	    sig_WCA_sq=sig_WCA**2	   	  #Initialize array of exp(muex_EV), which we later average 	  #	and subesequently take the natural log of to get muex_EV(z)	    exp_muex_EV=np.zeros(len(z_positions), dtype=float)	    i=-1 #This index is used to fill muex_EV[i]	    for (zlo,zhi) in zip(z_positions[0:-1],z_positions[1:len(z_positions)]):		i+=1	    	m=0 #This index and while loop to ensure that #		###The next two lines of code ensure calculations are made at the#		#######	same value of z (not random z's). This is for debugging.#		#08/25/11 16:21:38  #		zmid = 0.5*(zlo+zhi)#		zlo,zhi=zmid,zmid	    			#Trim away ions whose z-coordinates are +/- sig_WCA from bin edges		    	Pos_near_A = Pos_A[np.logical_and(Pos_A[:,2]>(zlo-sig_WCA),Pos_A[:,2]<(zhi+sig_WCA))]		Pos_near_C = Pos_C[np.logical_and(Pos_C[:,2]>(zlo-sig_WCA),Pos_C[:,2]<(zhi+sig_WCA))]		#This can't be done apriori for (x,y), since these are periodic dimensions			if (len(Pos_near_A)+len(Pos_near_C))!=0: #Perform M random 				#insertions if simulation particles have				#nearby z-coordinated.			while m < M:				m+=1				#Reset energies				del_Energies_A,del_Energies_C=[],[] 								#Randomly choose (x,y,z) of test ion with a z				#	position inside the bin of interest				r0=np.array([random.uniform(-hL_xy,hL_xy),random.uniform(-hL_xy,hL_xy),random.uniform(zlo,zhi)])				#Calculate the distance between the test ion and Anions				if len(Pos_near_A)!=0: #provided anions are near					r_0j=r0-Pos_near_A					r_0j[:,:2]=r_0j[:,:2]-L_xy*np.round_(r_0j[:,:2]*iL_xy)					r_0j_sq=np.sum(r_0j*r_0j,axis=1)					sig_over_r_p6=(sig_WCA_sq/r_0j_sq[r_0j_sq<sig_WCA_sq])**3					#Calculate energy due to inserting test ion					del_Energies_A = 4.*eps_WCA*(sig_over_r_p6*(sig_over_r_p6-1)+0.25)				else:					del_Energies_A=[]				if len(Pos_near_C)!=0:					#Do the same thing for Cations...					r_0j=r0-Pos_near_C					r_0j[:,:2]=r_0j[:,:2]-L_xy*np.round_(r_0j[:,:2]*iL_xy)					r_0j_sq=np.sum(r_0j*r_0j,axis=1)					sig_over_r_p6=(sig_WCA_sq/r_0j_sq[r_0j_sq<sig_WCA_sq])**3					del_Energies_C = 4.*eps_WCA*(sig_over_r_p6*(sig_over_r_p6-1)+0.25)				else:					del_Energies_C=[]		    		exp_muex_EV[i]+=np.exp(-(sum(del_Energies_A)+sum(del_Energies_C)))		else:			del_Energies_A,del_Energies_C=[],[]			exp_muex_EV[i]+=M*np.exp(-(sum(del_Energies_A)+sum(del_Energies_C)))	    return exp_muex_EV/M #Calculate average after M insertionsdef quick_Calc_muex_EV(z_positions,Pos_A,Pos_C,M,r_ion,eps_WCA,A_xy):	    """	Input:	    z_positions:   Bin discretation	    Pos_A:	   array of (x,y,z) positions for ions (attracted to right plate)	    Pos_C:	   array of (x,y,z) positions for ions (attracted to left plate)	    M:		   the number of random insertions per bin	    r_ion:	   WCA radius for ions	    eps_WCA:	   Energy scale for WCA potential	    A_xy:	   Cross-sectional area of simulation box	Output:	    exp_muex_EV:	   Excluded volume contributions to mu_ex 	    			NOTE: muex_EV[z] = -ln(exp_muex_EV[z]/n_obs) must be taken before printing 	"""	    Pos = Pos_A + Pos_C 	    exp_EV = np.zeros(len(z_positions), dtype=float)	    exp_EV_HS = np.zeros(len(z_positions), dtype=float)	    exp_EV,exp_EV_HS = EDLCalcs.calc_ev(z_positions, np.array(Pos), exp_EV, exp_EV_HS, M, np.sqrt(A_xy), eps_WCA, 2.*r_ion, len(z_positions), len(Pos))	    return np.array(exp_EV),np.array(exp_EV_HS)def Calc_2_muex_EV(z_positions,Pos_A,Pos_C,M,r_ion,eps_WCA,A_xy):	    """	Input:	    z_positions:   Bin discretation	    Pos_A:	   array of (x,y,z) positions for ions (attracted to right plate)	    Pos_C:	   array of (x,y,z) positions for ions (attracted to left plate)	    M:		   the number of random insertions per bin	    r_ion:	   list() of WCA radii for ions r_ion = [smaller (type 1 or A),larger]	    eps_WCA:	   Energy scale for WCA potential	    A_xy:	   Cross-sectional area of simulation box	Output:	    exp_muex_EV:	   Excluded volume contributions to mu_ex 	    			NOTE: muex_EV[z] = -ln(exp_muex_EV[z]/n_obs) must be taken before printing 	"""	    import random	    L_xy = A_xy**0.5	    hL_xy=L_xy*0.5	    iL_xy=1./L_xy	    sig_WCA=2*np.array(r_ion)	    sig_WCA_sq=sig_WCA**2	    sig_WCA_12 = 0.5*r_ion[0] + 0.5*r_ion[1]	    sig_WCA_12_sq = sig_WCA_12**2	   	  #Initialize array of exp(muex_EV), which we later average 	  #	and subesequently take the natural log of to get muex_EV(z)	    exp_1muex_EV=np.zeros(len(z_positions), dtype=float)	    exp_2muex_EV=np.zeros(len(z_positions), dtype=float)	    i=-1 #This index is used to fill muex_EV[i]	    for (zlo,zhi) in zip(z_positions[0:-1],z_positions[1:len(z_positions)]):		i+=1	    	m=0 #This index and while loop to ensure that 	    			#Trim away ions whose z-coordinates are +/- larger sig_WCA from bin edges		    	Pos_near_A = Pos_A[np.logical_and(Pos_A[:,2]>(zlo-sig_WCA[1]),Pos_A[:,2]<(zhi+sig_WCA[1]))]		Pos_near_C = Pos_C[np.logical_and(Pos_C[:,2]>(zlo-sig_WCA[1]),Pos_C[:,2]<(zhi+sig_WCA[1]))]		#This can't be done apriori for (x,y), since these are periodic dimensions			if (len(Pos_near_A)+len(Pos_near_C))!=0: #Perform M random 				#insertions if simulation particles have				#nearby z-coordinated.			while m < M:				m+=1				#Reset energies				del_Energies_A1,del_Energies_C1=[],[] #Small test ions				del_Energies_A2,del_Energies_C2=[],[] #Larger test ions				#Randomly choose (x,y,z) of test ion with a z				#	position inside the bin of interest				r0=np.array([random.uniform(-hL_xy,hL_xy),random.uniform(-hL_xy,hL_xy),random.uniform(zlo,zhi)])				#Calculate the distance between the test ions and small Anions				if len(Pos_near_A)!=0: #provided anions are near					r_0j=r0-Pos_near_A					r_0j[:,:2]=r_0j[:,:2]-L_xy*np.round_(r_0j[:,:2]*iL_xy)					r_0j_sq=np.sum(r_0j*r_0j,axis=1)					#Calculate energy due to inserting smaller test ion atop small ion										sig_over_r_p6=(sig_WCA_sq[0]/r_0j_sq[r_0j_sq<sig_WCA_sq[0]])**3					del_Energies_A1 = 4.*eps_WCA*(sig_over_r_p6*(sig_over_r_p6-1)+0.25)					#Calculate energy due to inserting larger test ion atop small ion					sig_over_r_p6=(sig_WCA_12_sq/r_0j_sq[r_0j_sq<sig_WCA_12_sq])**3					del_Energies_A2 = 4.*eps_WCA*(sig_over_r_p6*(sig_over_r_p6-1)+0.25)				else:					del_Energies_A1,del_Energies_A2=[],[]				if len(Pos_near_C)!=0:					#Do the same thing for Cations...					r_0j=r0-Pos_near_C					r_0j[:,:2]=r_0j[:,:2]-L_xy*np.round_(r_0j[:,:2]*iL_xy)					r_0j_sq=np.sum(r_0j*r_0j,axis=1)					#Calculate energy due to inserting smaller test ion atop larger ion										sig_over_r_p6=(sig_WCA_12_sq/r_0j_sq[r_0j_sq<sig_WCA_12_sq])**3					del_Energies_C1 = 4.*eps_WCA*(sig_over_r_p6*(sig_over_r_p6-1)+0.25)					#Calculate energy due to inserting larger test ion atop small ion					sig_over_r_p6=(sig_WCA_sq[1]/r_0j_sq[r_0j_sq<sig_WCA_sq[1]])**3					del_Energies_C2 = 4.*eps_WCA*(sig_over_r_p6*(sig_over_r_p6-1)+0.25)				else:					del_Energies_C1,del_Energies_C2=[],[]				##MOdify this now~!!!		    		exp_1muex_EV[i]+=np.exp(-(sum(del_Energies_A1)+sum(del_Energies_C1)))		    		exp_2muex_EV[i]+=np.exp(-(sum(del_Energies_A2)+sum(del_Energies_C2)))		else:			del_Energies_A1,del_Energies_C1=[],[]			del_Energies_A2,del_Energies_C2=[],[]				    		exp_1muex_EV[i]+=np.exp(-(sum(del_Energies_A1)+sum(del_Energies_C1)))	    		exp_2muex_EV[i]+=np.exp(-(sum(del_Energies_A2)+sum(del_Energies_C2)))	    			    return exp_1muex_EV/M,exp_2muex_EV/M #Calculate average after M insertionsdef GC_System(filename,Bjerrum,Numbins,r_ion,M_per_slice):    """This function performs all duties as     GC_System_symmetricsize(filename,Bjerrum,Numbins,r_ion) below    and alongside it performs a modified Widom insertion method to approximate    the excluded volume contributions to the excess chemical potential as a     function of distance from the plate z for 2 or only 1 ion size. This    has the same bin notation as the voltage (and possibly a shifted density).        After all of the items calculated as mentioned above, each component of the     excess chemical potential is also calculated.    This information (along with errors?) will be printed to various _DATA files    of both old and (probably) new formats, which MUST BE ACCOUNTED FOR IN PLOT    ROUTINES.    Error analysis has been commented out.Input    filename: str() the name of the file with MD trajectory data    Bjerrum:  float() the Bjerrum length that was set for the system    Numbins:  int() the number of bins to discretize system    r_ion:    float() the WCA radius of the ion OR    		list() of WCA radii r_ion =[smaller,larger]    M_per_slice: number of insertions per bin for muex_EV calculations    ##CONSIDER ADDING VALENCY AS A FUCNTION INPUT!Output:    None, only printed statements that are written to a .txt file from the command line"""    #These are hard coded values that cannot be determined from Data[]    valency=1.0    valence=1    r_wall=1.0            eps_wall=1.0    eps_WCA=1.0#    filename='1000_DEBUG_zeta_1.000.txt'    filename_orignal=filename    #z='3.776'    #filename='1000_ss_zeta_'+z+'.txt'    if filename[-3:]=='.gz':        Data=gzip.GzipFile(fileobj=open(filename,'rb'))	filename=filename[0:len(filename)-2]+'txt'    else:        Data=file(filename,"r")    print '\n'    print filename    dielectric=(4*np.pi*Bjerrum)**-1 #This used to be dielectric=Bjerrum**-1    graph_prefix=str(Numbins) + filename[4:len(filename)-4]    #Create empty vectors to fill    BA_Data,BA_z=[],[]    BC_Data,BC_z=[],[]    Pos_A,Pos_C=[],[]    p_squared,p_avg=0,0    print 'DOUBLE CHECK SIGMA_S VALUES IN IF STATEMENTS!!!'    ze=str(filename[-9:-4])#    print 'The goal as of 11/05/10 16:08:46 should be to feed Sigma_s via the LAMMPS filename.'    if type(r_ion) == type(0.5):    	    print 'Symmetrically size ions'	    if Bjerrum==1. and r_ion==0.5:		print '\n\nDouble check to see if the proper Sigma_s is included in data analysis!\nThere are many versions of (Bjerrum,sigma) = (1,1).\n\n'		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':	#		Sigma_s=0.02435*dielectric			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.04908*dielectric			Sigma_s=0.05052*dielectric		if ze=='0.750':			Sigma_s=0.07476*dielectric			Sigma_s=0.07677*dielectric		if ze=='1.000':			Sigma_s=0.10174*dielectric			Sigma_s=0.10422*dielectric			#print 'Reflection wall Sigma!'		if ze=='1.250':	#		Sigma_s=0.13028*dielectric			Sigma_s=0.13330*dielectric		if ze=='1.500':	#		Sigma_s=0.16075*dielectric			Sigma_s=0.16446*dielectric		if ze=='1.750':	#		Sigma_s=0.19372*dielectric			Sigma_s=0.19820*dielectric		if ze=='2.000':	#		Sigma_s=0.22973*dielectric			Sigma_s=0.23504*dielectric			#print 'Reflection wall Sigma!'		if ze=='2.500':	#		Sigma_s=0.31314*dielectric			Sigma_s=0.32038*dielectric 		if ze=='2.750':	#		Sigma_s=0.36185*dielectric			Sigma_s=0.37022*dielectric		if ze=='3.000':	#		Sigma_s=0.41623*dielectric			Sigma_s=0.42585*dielectric		if ze=='3.500':			print 'Sig_s is different for 1200 vs 800 particles!'			Sigma_s=0.54547*dielectric # 800			Sigma_s=0.56133*dielectric #1200			Sigma_s=0.55808*dielectric #1400 & 7000 - lattice			#Sigma_s=0.59952*dielectric #2300		if ze=='4.000':			print 'Sig_s is different for 1200 vs 800 particles!'			Sigma_s=0.70897*dielectric #800			Sigma_s=0.72959*dielectric #1200			Sigma_s=0.72537*dielectric #1400 & 7000 - lattice			#Sigma_s=0.80087*dielectric #2300		if ze=='5.000':			print 'Sig_s is different for 1200 vs 800 particles!'			Sigma_s=1.18268*dielectric #800			Sigma_s=1.21708*dielectric #1200			Sigma_s=1.21004*dielectric #1400 & 7000 - lattice			#Sigma_s=1.43531*dielectric #2300	    elif Bjerrum==1. and r_ion==2.5:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.250':			Sigma_s=0.02510*dielectric		if ze=='0.500':			Sigma_s=0.05059*dielectric		if ze=='0.750':			Sigma_s=0.07706*dielectric		if ze=='1.000':			Sigma_s=0.10474*dielectric		if ze=='1.250':			Sigma_s=0.13396*dielectric		if ze=='1.500':			Sigma_s=0.16528*dielectric		if ze=='1.750':			Sigma_s=0.19919*dielectric		if ze=='2.000':			Sigma_s=0.23621*dielectric		if ze=='2.500':			Sigma_s=0.32198*dielectric		if ze=='2.750':			Sigma_s=0.37207*dielectric		if ze=='3.000':			Sigma_s=0.42798*dielectric		if ze=='3.311':			Sigma_s=0.50699*dielectric		if ze=='3.500':			Sigma_s=0.56087*dielectric		if ze=='4.000':			Sigma_s=0.72899*dielectric		if ze=='5.000':			Sigma_s=1.21608*dielectric	    elif Bjerrum==1. and r_ion==3.0:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.250':			Sigma_s=0.02510*dielectric		if ze=='0.500':			Sigma_s=0.05059*dielectric		if ze=='0.750':			Sigma_s=0.07706*dielectric		if ze=='1.000':			Sigma_s=0.10474*dielectric		if ze=='1.250':			Sigma_s=0.13396*dielectric		if ze=='1.500':			Sigma_s=0.16528*dielectric		if ze=='1.750':			Sigma_s=0.19919*dielectric		if ze=='2.000':			Sigma_s=0.23621*dielectric		if ze=='2.250':			Sigma_s=0.27556*dielectric		if ze=='2.350':			Sigma_s=0.29293*dielectric		if ze=='2.600':			Sigma_s=0.33968*dielectric		if ze=='2.800':			Sigma_s=0.38086*dielectric				if ze=='2.500':			Sigma_s=0.32198*dielectric		if ze=='2.670':			Sigma_s=0.35545*dielectric		if ze=='2.750':			Sigma_s=0.37207*dielectric			if ze=='3.000':			Sigma_s=0.42798*dielectric		if ze=='3.500':			Sigma_s=0.56087*dielectric	    elif Bjerrum==1. and r_ion==3.5:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.250':			Sigma_s=0.02510*dielectric		if ze=='0.500':			Sigma_s=0.05059*dielectric		if ze=='0.750':			Sigma_s=0.07706*dielectric		if ze=='1.000':			Sigma_s=0.10474*dielectric		if ze=='1.250':			Sigma_s=0.13396*dielectric		if ze=='1.500':			Sigma_s=0.16528*dielectric		if ze=='1.750':			Sigma_s=0.19919*dielectric		if ze=='2.000':			Sigma_s=0.23621*dielectric		if ze=='2.100':			Sigma_s=0.25077*dielectric		if ze=='2.300':			Sigma_s=0.28416*dielectric		if ze=='2.600':			Sigma_s=0.33968*dielectric		if ze=='2.900':			Sigma_s=0.40285*dielectric		if ze=='3.500':			Sigma_s=0.55808*dielectric		if ze=='2.200':			Sigma_s=0.26846*dielectric		if ze=='2.500':			Sigma_s=0.32198*dielectric		if ze=='2.750':			Sigma_s=0.37207*dielectric		if ze=='3.000':			Sigma_s=0.42798*dielectric	    elif Bjerrum==1. and r_ion==4.0:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.250':			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.05052*dielectric		if ze=='0.750':			Sigma_s=0.07677*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.250':			Sigma_s=0.13330*dielectric		if ze=='1.500':			Sigma_s=0.16446*dielectric		if ze=='1.870':			Sigma_s=0.21546*dielectric		if ze=='2.000':			Sigma_s=0.23504*dielectric		if ze=='2.250':			Sigma_s=0.27556*dielectric		if ze=='2.500':			Sigma_s=0.32038*dielectric	    elif Bjerrum==5. and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.250':			Sigma_s=0.02435*dielectric		if ze=='0.500':			Sigma_s=0.04908*dielectric		if ze=='0.750':			Sigma_s=0.07476*dielectric		if ze=='1.000':			Sigma_s=0.10174*dielectric		if ze=='1.250':			Sigma_s=0.13028*dielectric		if ze=='1.500':			Sigma_s=0.16075*dielectric		if ze=='1.750':			Sigma_s=0.19372*dielectric		if ze=='2.000':			Sigma_s=0.22973*dielectric		if ze=='2.500':			Sigma_s=0.31314*dielectric		if ze=='2.750':			Sigma_s=0.36185*dielectric		if ze=='3.000':			Sigma_s=0.41623*dielectric		if ze=='3.500':			Sigma_s=0.54547*dielectric		if ze=='4.000':			Sigma_s=0.70897*dielectric		if ze=='5.000':			Sigma_s=1.18268*dielectric			    elif Bjerrum==0.5 and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.05052*dielectric		if ze=='0.750':			Sigma_s=0.07677*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.250':			Sigma_s=0.13330*dielectric		if ze=='1.500':			Sigma_s=0.16446*dielectric		if ze=='1.750':			Sigma_s=0.19820*dielectric		if ze=='2.000':			Sigma_s=0.23504*dielectric		if ze=='2.500':			Sigma_s=0.32038*dielectric		if ze=='2.750':			Sigma_s=0.37022*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.500':			print 'possibly more particles need to be used?'			Sigma_s=0.55808*dielectric		if ze=='4.000':			print 'possibly more particles need to be used?'			Sigma_s=0.72537*dielectric		if ze=='5.000':			print 'possibly more particles need to be used?'			Sigma_s=1.21004*dielectric	    elif Bjerrum==3.0 and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.05052*dielectric		if ze=='0.750':			Sigma_s=0.07677*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.250':			Sigma_s=0.13330*dielectric		if ze=='1.500':			Sigma_s=0.16446*dielectric		if ze=='1.750':			Sigma_s=0.19820*dielectric		if ze=='2.000':			Sigma_s=0.23504*dielectric		if ze=='2.250':			Sigma_s=0.27556*dielectric		if ze=='2.500':			Sigma_s=0.32038*dielectric		if ze=='2.750':			Sigma_s=0.37022*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.250':			Sigma_s=0.48815*dielectric		if ze=='3.500':			print 'possibly more particles need to be used?'			Sigma_s=0.55808*dielectric		if ze=='4.000':			print 'possibly more particles need to be used?'			Sigma_s=0.72537*dielectric		if ze=='5.000':			print 'possibly more particles need to be used?'			Sigma_s=1.21004*dielectric	    elif Bjerrum==7.0 and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.05052*dielectric		if ze=='0.750':			Sigma_s=0.07677*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.250':			Sigma_s=0.13330*dielectric		if ze=='1.500':			Sigma_s=0.16446*dielectric		if ze=='1.750':			Sigma_s=0.19820*dielectric		if ze=='2.000':			Sigma_s=0.23504*dielectric		if ze=='2.250':			Sigma_s=0.27556*dielectric		if ze=='2.500':			Sigma_s=0.32038*dielectric		if ze=='2.750':			Sigma_s=0.37022*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.250':			Sigma_s=0.48815*dielectric		if ze=='3.500':			print 'possibly more particles need to be used?'			Sigma_s=0.55808*dielectric		if ze=='4.000':			print 'possibly more particles need to be used?'			Sigma_s=0.72537*dielectric		if ze=='5.000':			print 'possibly more particles need to be used?'			Sigma_s=1.21004*dielectric	    elif Bjerrum==10.0 and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.05052*dielectric		if ze=='0.750':			Sigma_s=0.07677*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.250':			Sigma_s=0.13330*dielectric		if ze=='1.500':			Sigma_s=0.16446*dielectric		if ze=='1.750':			Sigma_s=0.19820*dielectric		if ze=='2.000':			Sigma_s=0.23504*dielectric		if ze=='2.250':			Sigma_s=0.27556*dielectric		if ze=='2.500':			Sigma_s=0.32038*dielectric		if ze=='2.750':			Sigma_s=0.37022*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.250':			Sigma_s=0.48815*dielectric		if ze=='3.500':			print 'possibly more particles need to be used?'			Sigma_s=0.55808*dielectric		if ze=='4.000':			print 'possibly more particles need to be used?'			Sigma_s=0.72537*dielectric		if ze=='5.000':			print 'possibly more particles need to be used?'			Sigma_s=1.21004*dielectric	    elif Bjerrum==7.0 and r_ion==3.5:		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		if ze=='0.250':			Sigma_s=0.00836*dielectric		if ze=='0.500':			Sigma_s=0.01684*dielectric		if ze=='0.750':			Sigma_s=0.02559*dielectric		if ze=='1.000':			Sigma_s=0.03474*dielectric		if ze=='1.250':			Sigma_s=0.04443*dielectric		if ze=='1.500':			Sigma_s=0.05482*dielectric		if ze=='1.750':			Sigma_s=0.06607*dielectric		if ze=='2.000':			Sigma_s=0.07835*dielectric		if ze=='2.250':			Sigma_s=0.09185*dielectric		if ze=='2.500':			Sigma_s=0.10679*dielectric		if ze=='2.750':			Sigma_s=0.12341*dielectric		if ze=='3.000':			Sigma_s=0.14195*dielectric		if ze=='3.250':			Sigma_s=0.16272*dielectric		if ze=='3.500':			Sigma_s=0.18603*dielectric		if ze=='4.000':			Sigma_s=0.24179*dielectric		if ze=='5.000':			Sigma_s=0.40335*dielectric		##For large Bjerrum lengths	    elif Bjerrum==100.0 and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.500':			Sigma_s=0.05649*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.500':			Sigma_s=0.20143*dielectric		if ze=='2.000':			Sigma_s=0.26278*dielectric		if ze=='2.500':			Sigma_s=0.35820*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.500':			Sigma_s=0.55808*dielectric		if ze=='4.000':			Sigma_s=0.72537*dielectric		if ze=='5.000':			Sigma_s=1.21004*dielectric	    ##This is for the CS runs	    elif Bjerrum==0.1 and r_ion == 2.7: #r3_PhiB_0.185		if ze == '0.000':		    Sigma_s=0.000*dielectric		if ze == '0.250':		    Sigma_s=0.01547*dielectric		if ze == '0.500':		    Sigma_s=0.03119*dielectric		if ze == '0.750':		    Sigma_s=0.04739*dielectric		if ze == '1.000':		    Sigma_s=0.06433*dielectric		if ze == '1.250':		    Sigma_s=0.08228*dielectric		if ze == '1.500':		    Sigma_s=0.10152*dielectric	    elif Bjerrum==0.1 and r_ion == 4.8: #r4_PhiB_0.185		if ze == '0.000':		    Sigma_s=0.000*dielectric		if ze == '0.250':		    Sigma_s=0.00653*dielectric		if ze == '0.500':		    Sigma_s=0.01316*dielectric		if ze == '0.750':		    Sigma_s=0.01999*dielectric		if ze == '1.000':		    Sigma_s=0.02714*dielectric		if ze == '1.250':		    Sigma_s=0.03471*dielectric		if ze == '1.500':		    Sigma_s=0.04283*dielectric		if ze == '1.750':		    Sigma_s=0.05161*dielectric		if ze == '2.000':		    Sigma_s=0.06121*dielectric	    elif Bjerrum==0.1 and r_ion == 7.5: #r5_PhiB_0.289		if ze == '0.000':		    Sigma_s=0.000*dielectric		if ze == '0.250':		    Sigma_s=0.00418*dielectric		if ze == '0.500':		    Sigma_s=0.00842*dielectric		if ze == '0.750':		    Sigma_s=0.01280*dielectric		if ze == '1.000':		    Sigma_s=0.01737*dielectric		if ze == '1.250':		    Sigma_s=0.02222*dielectric		if ze == '1.500':		    Sigma_s=0.02741*dielectric		if ze == '1.750':		    Sigma_s=0.03303*dielectric		if ze == '2.000':		    Sigma_s=0.03917*dielectric	    else:		Sigma_s=0.0000		print 'Sigma_s was set to a default value of 0.000'		#This code is as new as 11/05/10 16:07:32 	    ##This is for the CS runs	    if Bjerrum==0.1 and r_ion == 2.7: #r3_PhiB_0.185		if ze == '0.000':		    Sigma_s=0.000*dielectric		if ze == '0.250':		    Sigma_s=0.01547*dielectric		if ze == '0.500':		    Sigma_s=0.03119*dielectric		if ze == '0.750':		    Sigma_s=0.04739*dielectric		if ze == '1.000':		    Sigma_s=0.06433*dielectric		if ze == '1.250':		    Sigma_s=0.08228*dielectric		if ze == '1.500':		    Sigma_s=0.10152*dielectric	    elif Bjerrum==0.1 and r_ion == 4.8: #r4_PhiB_0.185		if ze == '0.000':		    Sigma_s=0.000*dielectric		if ze == '0.250':		    Sigma_s=0.00653*dielectric		if ze == '0.500':		    Sigma_s=0.01316*dielectric		if ze == '0.750':		    Sigma_s=0.01999*dielectric		if ze == '1.000':		    Sigma_s=0.02714*dielectric		if ze == '1.250':		    Sigma_s=0.03471*dielectric		if ze == '1.500':		    Sigma_s=0.04283*dielectric		if ze == '1.750':		    Sigma_s=0.05161*dielectric		if ze == '2.000':		    Sigma_s=0.06121*dielectric	    elif Bjerrum==0.1 and r_ion == 7.5: #r5_PhiB_0.289		if ze == '0.000':		    Sigma_s=0.000*dielectric		if ze == '0.250':		    Sigma_s=0.00418*dielectric		if ze == '0.500':		    Sigma_s=0.00842*dielectric		if ze == '0.750':		    Sigma_s=0.01280*dielectric		if ze == '1.000':		    Sigma_s=0.01737*dielectric		if ze == '1.250':		    Sigma_s=0.02222*dielectric		if ze == '1.500':		    Sigma_s=0.02741*dielectric		if ze == '1.750':		    Sigma_s=0.03303*dielectric		if ze == '2.000':		    Sigma_s=0.03917*dielectric    #This is for the special "Reflection Wall" case    #print 'Reflection wall Sigma_s is being used!'    #if Bjerrum==1. and r_ion==0.5:	#print 'Reflection wall Sigma_s are being used!'	#if ze=='0.000':		#Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)	#if ze=='0.250':		#Sigma_s=0.02507*dielectric	#if ze=='0.500':		#Sigma_s=0.05052*dielectric	#if ze=='1.000':		#Sigma_s=0.10422*dielectric	#if ze=='1.250':		#Sigma_s=0.13330*dielectric	#if ze=='2.000':		#Sigma_s=0.23504*dielectric    elif len(r_ion) == 2:  	    if Bjerrum==1. and (r_ion[1]==1. or r_ion[1]==1.5):		print 'Data analysis for sigma ratio = 2 or 3!'		if ze=='0.000':			Sigma_s=0.00*dielectric # => Sig_s = F_z*dielectric, used to be F_z/Bjerrum (and worked when Bjerrum was 1)		elif ze=='0.250':			Sigma_s=0.02507*dielectric		elif ze=='0.500':			Sigma_s=0.05052*dielectric		elif ze=='0.750':			Sigma_s=0.07677*dielectric		elif ze=='1.000':			Sigma_s=0.10422*dielectric		elif ze=='1.250':			Sigma_s=0.13330*dielectric		elif ze=='1.500':			Sigma_s=0.16446*dielectric		elif ze=='1.750':			Sigma_s=0.19820*dielectric		elif ze=='2.000':			Sigma_s=0.23504*dielectric		elif ze=='2.100':			Sigma_s=0.25077*dielectric		elif ze=='2.500':			Sigma_s=0.32038*dielectric		elif ze=='2.750':			Sigma_s=0.37022*dielectric		elif ze=='3.000':			Sigma_s=0.42586*dielectric		elif ze=='3.500':			Sigma_s=0.55808*dielectric		elif ze=='4.000':			Sigma_s=0.72537*dielectric		elif ze=='5.000':			Sigma_s=1.21004*dielectric		else:			print 'Sig_s set to default!'			Sigma_s=3.776*dielectric###    print 'USING UNIQUE VALUES FOR LB,LD = 5,20'#    if ze=='0.000':#		Sigma_s=0.00*dielectric#    if ze=='0.500':#		Sigma_s=0.02526*dielectric#    if ze=='1.000':#		Sigma_s=0.05211*dielectric#    if ze=='1.500':#		Sigma_s=0.08223*dielectric#    if ze=='2.000':#		Sigma_s=0.11752*dielectric#    if ze=='2.500':#		Sigma_s=0.16019*dielectric#    if ze=='3.000':#		Sigma_s=0.21293*dielectric#    if ze=='3.500':#		Sigma_s=0.27904*dielectric#    if ze=='5.000':#		Sigma_s=0.60502*dielectric    if Bjerrum==100.0 and r_ion==0.5:		print 'USING UNIQUE VALUES FOR LB,LD = 100,~10'		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.050':			Sigma_s=0.005649*dielectric#			print Sigma_s,Sigma_s*1000000.#			print '%1.16f' % Sigma_s		if ze=='0.125':			Sigma_s=0.0141225*dielectric		if ze=='0.250':			Sigma_s=0.028245*dielectric		if ze=='0.500':			Sigma_s=0.05649*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.500':			Sigma_s=0.20143*dielectric		if ze=='2.000':			Sigma_s=0.26278*dielectric		if ze=='2.500':			Sigma_s=0.35820*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.500':			Sigma_s=0.55808*dielectric		if ze=='4.000':			Sigma_s=0.72537*dielectric		if ze=='5.000':			Sigma_s=1.21004*dielectric    if Bjerrum==1000.0 and r_ion==0.5:		print 'USING UNIQUE VALUES FOR LB,LD = 1000,10'		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.050':			Sigma_s=0.005649*dielectric		if ze=='0.125':			Sigma_s=0.0141225*dielectric		if ze=='0.250':			Sigma_s=0.028245*dielectric		if ze=='0.500':			Sigma_s=0.05649*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.500':			Sigma_s=0.20143*dielectric		if ze=='2.000':			Sigma_s=0.26278*dielectric		if ze=='2.500':			Sigma_s=0.35820*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.500':			Sigma_s=0.55808*dielectric		if ze=='4.000':			Sigma_s=0.72537*dielectric		if ze=='5.000':			Sigma_s=1.21004*dielectric    if (Bjerrum==20.0 or Bjerrum==40.0 or Bjerrum==60.0 or Bjerrum==80.0) and r_ion==0.5:		if ze=='0.000':			Sigma_s=0.00*dielectric		if ze=='0.050':			Sigma_s=0.00500*dielectric		if ze=='0.125':			Sigma_s=0.01251*dielectric		if ze=='0.250':			Sigma_s=0.02507*dielectric		if ze=='0.500':			Sigma_s=0.05052*dielectric		if ze=='1.000':			Sigma_s=0.10422*dielectric		if ze=='1.500':			Sigma_s=0.16446*dielectric		if ze=='2.000':			Sigma_s=0.23504*dielectric		if ze=='2.500':			Sigma_s=0.32038*dielectric		if ze=='3.000':			Sigma_s=0.42586*dielectric		if ze=='3.500':			Sigma_s=0.55808*dielectric								if ze=='4.000':			Sigma_s=0.72537*dielectric		if ze=='5.000':			Sigma_s=1.21004*dielectric		if ze=='6.000':			Sigma_s=2.00357*dielectric    if	r_ion==1.5 and Bjerrum==0.1:    		print 'here'		if ze=='0.000':			Sigma_s=0.0*dielectric		if ze=='0.500':			Sigma_s=0.03368*dielectric		if ze=='1.000':			Sigma_s=0.06948*dielectric		if ze=='1.500':			Sigma_s=0.10964*dielectric		if ze=='1.750':			Sigma_s=0.13213*dielectric		if ze=='2.000':			Sigma_s=0.15669*dielectric		if ze=='2.500':			Sigma_s=0.21359*dielectric		if ze=='2.750':			Sigma_s=0.24682*dielectric		if ze=='3.000':			Sigma_s=0.28390*dielectric		if ze=='3.500':			Sigma_s=0.37206*dielectric								if ze=='4.000':			Sigma_s=0.48358*dielectric		if ze=='5.000':			Sigma_s=0.80669*dielectric		if ze=='6.000':			Sigma_s=1.33572*dielectric				if ze=='7.000':			Sigma_s=2.20568*dielectric		if 'S' in ze:			print 'Getting the factor'			Factor = float(S[-3:])/100			Sigma_s=0.80669*dielectric*Factor		    if	r_ion==1.5 and Bjerrum==0.025:    		print 'now here'		if ze=='0.000':			Sigma_s=0.0		if ze=='1.000':			Sigma_s=0.03474*dielectric		if ze=='2.000':			Sigma_s=0.07835*dielectric		if ze=='2.500':			Sigma_s=0.10679*dielectric#		if ze=='2.750':#			Sigma_s=0.24682*dielectric		if ze=='3.000':			Sigma_s=0.14195*dielectric		if ze=='3.500':			Sigma_s=0.18603*dielectric								if ze=='4.000':			Sigma_s=0.24179*dielectric		if ze=='4.500':			Sigma_s=0.31274*dielectric		if ze=='5.000':			Sigma_s=0.40335*dielectric		if ze=='6.000':			Sigma_s=0.66786*dielectric		#		if ze=='7.000':#			Sigma_s=2.20568*dielectric    if	True:    		print 'here here here'		if ze=='0.000':			Sigma_s=0.0*dielectric		if ze=='0.125':			Sigma_s=0.00842*dielectric		if ze=='0.250':			Sigma_s=0.01684*dielectric		if ze=='0.500':			Sigma_s=0.03368*dielectric		if ze=='1.000':			Sigma_s=0.06948*dielectric		if ze=='1.500':			Sigma_s=0.10964*dielectric		if ze=='1.750':			Sigma_s=0.13213*dielecwtric		if ze=='2.000':			Sigma_s=0.15669*dielectric		if ze=='2.500':			Sigma_s=0.21359*dielectric		if ze=='2.750':			Sigma_s=0.24682*dielectric		if ze=='3.000':			Sigma_s=0.28390*dielectric		if ze=='3.500':			Sigma_s=0.37206*dielectric								if ze=='4.000':			Sigma_s=0.48358*dielectric		if ze=='5.000':			Sigma_s=0.80669*dielectric		if ze=='6.000':			Sigma_s=1.33572*dielectric				if ze=='7.000':			Sigma_s=2.20568*dielectric                else:                        Sigma_s=0.03368*dielectric*0.25     wallZ_L,wallZ_R=[],[]        nth=1     # new addition, untested (prob need to add a k+=1 near qz_avg) - 02/10/10 13:17:25 , also never actually used... - 11/18/10 11:47:02        n_obs=0    i,k=0,0 	    get_box_dims=0    for y in Data:      x=y.split()      ##Format for x is:#     x= [id type x y z xu yu zu vx vy vz fx fy fz]            get_box_dims+=1      if get_box_dims<=8:	if get_box_dims==6:	  L_x=float(x[1])-float(x[0])	elif get_box_dims==7:	  L_y=float(x[1])-float(x[0])	  area=L_x*L_y	elif get_box_dims==8:	  L_box=float(x[1])-float(x[0])	  z_wall=-0.5*L_box+r_wall	        if not x[0]=="ITEM:":	x=[float(xx) for xx in x]	if len(x)<=2:	  i+=1	  if i==6: #This means an entire timestep worth of data is had	    if not (k % nth): #This means data is collected every nth timestep.		    BA_z=np.array(sorted(BA_z))	            BC_z=np.array(sorted(BC_z))##At this point, all the (x,y,z) for + and - must be collected and at some point#now? Widom insert method'd. Come to think of it, I DON'T need to change the#z-coords for density since I'm feeding in the positions as is.		    #Calculate the average z-positions of all ions penetrating the wall		    wallL,wallR=[],[]		    for z in BA_z:		    	if z<(-L_box*0.5+r_wall):		    		wallL.append(z)	    		if z>(L_box*0.5-r_wall):	    			wallR.append(z)		    for z in BC_z:		    	if z<(-L_box*0.5+r_wall):		    		wallL.append(z)	    		if z>(L_box*0.5-r_wall):	    			wallR.append(z)				    if len(wallL)!=0:		    	wallZ_L.append(sum(wallL)/len(wallL))	    	    if len(wallR)!=0:	    	        wallZ_R.append(sum(wallR)/len(wallR))	            	            n_obs+=1		    if k==0: #This indicates that the first timestep worth of data was collected		      BA_qty=len(BA_z)		      BC_qty=len(BC_z)		      N_tot=BA_qty+BC_qty		      #This was the old way, which still should work for the old numpy#		      hist_A,bin=np.histogram(BA_z, Numbins, (-L_box*0.5,L_box*0.5))       		      bin=np.array([((-L_box/2.)+i*(L_box/float(Numbins))) for i in range(Numbins)]+[L_box*0.5])		      hist_A = MyHist(BA_z,bin)      		      		      Sum_A=hist_A		      SumSq_A=Sum_A**2		      #		      hist_C,bin=np.histogram(BC_z, Numbins, (-L_box*0.5,L_box*0.5)) 		      hist_C = MyHist(BC_z,bin)   		      Sum_C=hist_C		      SumSq_C=Sum_C**2		      bin_plot=[(x+y)/2. for (x,y) in zip(bin[0:len(bin)-1],bin[1:len(bin)])]		      L_bin=(bin[1]-bin[0])		      #Voltage initialization		      Shell_bin=np.array([x+bin[len(bin)-1] for x in bin])		      #bin[len(bin)-1] is added to BA_z and BC_z since this voltage calculation assumes the walls go from 0 - L (not -0.5L -> 0.5L as all else)		      Psi,Efield=quickCalc_VoltandField(Shell_bin,BA_z+bin[len(bin)-1],BC_z+bin[len(bin)-1],Sigma_s,dielectric,area,valence)		      Psi_tot=Psi		      E_tot=Efield		      Psi_sq=Psi**2		      E_sq=Efield**2		      ##Use modified Widom to calculate instantaneous exp_muex_EV = exp(-muex_EV) to add to a total for later averaging		      		#muex_EV = -np.ln(exp_muex_EV/n_obs)	    	      if type(r_ion) == type(0.5):			      exp_muex_EV,exp_muex_HS = quick_Calc_muex_EV(bin,Pos_A,Pos_C,M_per_slice,r_ion,eps_WCA,area)			      exp_muex_EV_tot=exp_muex_EV#+exp_muex_EV_tot			      exp_muex_EV_sq=exp_muex_EV**2#+exp_muex_EV_sq			      exp_muex_HS_tot=exp_muex_HS#+exp_muex_HS_tot			      exp_muex_HS_sq=exp_muex_HS**2#+exp_muex_HS_sq		      elif len(r_ion) == 2:			      exp_1muex_EV,exp_2muex_EV = Calc_2_muex_EV(bin,np.array(Pos_A),np.array(Pos_C),M_per_slice,r_ion,eps_WCA,area)			      exp_1muex_EV_tot,exp_2muex_EV_tot = exp_1muex_EV,exp_2muex_EV			      exp_1muex_EV_sq,exp_2muex_EV_sq = exp_1muex_EV**2,exp_2muex_EV**2			      #		      for pos in Pos_A:#		          print 'anion','\t\t',pos[0],'\t\t',pos[1],'\t\t',pos[2]#		      for pos in Pos_C:#		          print 'cation','\t\t',pos[0],'\t\t',pos[1],'\t\t',pos[2]#		      print endthiscode		          		          #		      #Correlation time and error analysis, for data sets of 50,000 snapshots!#		      Psi_5000,Psi_sq_5000=np.zeros(len(Psi),dtype=float),np.zeros(len(Psi),dtype=float)#		      Psi_7500,Psi_sq_7500=np.zeros(len(Psi),dtype=float),np.zeros(len(Psi),dtype=float)#		      Psi_10000,Psi_sq_10000=np.zeros(len(Psi),dtype=float),np.zeros(len(Psi),dtype=float)#		      Psi_22500,Psi_sq_22500=np.zeros(len(Psi),dtype=float),np.zeros(len(Psi),dtype=float)#		      E_5000,E_sq_5000=np.zeros(len(Efield),dtype=float),np.zeros(len(Efield),dtype=float)#		      E_7500,E_sq_7500=np.zeros(len(Efield),dtype=float),np.zeros(len(Efield),dtype=float)#		      E_10000,E_sq_10000=np.zeros(len(Efield),dtype=float),np.zeros(len(Efield),dtype=float)#		      E_22500,E_sq_22500=np.zeros(len(Efield),dtype=float),np.zeros(len(Efield),dtype=float)#		      A_count_5000,A_count_sq_5000=np.zeros(len(Sum_A),dtype=float),np.zeros(len(Sum_A),dtype=float)#		      A_count_7500,A_count_sq_7500=np.zeros(len(Sum_A),dtype=float),np.zeros(len(Sum_A),dtype=float)#		      A_count_10000,A_count_sq_10000=np.zeros(len(Sum_A),dtype=float),np.zeros(len(Sum_A),dtype=float)#		      A_count_22500,A_count_sq_22500=np.zeros(len(Sum_A),dtype=float),np.zeros(len(Sum_A),dtype=float)#		      C_count_5000,C_count_sq_5000=np.zeros(len(Sum_C),dtype=float),np.zeros(len(Sum_C),dtype=float)#		      C_count_7500,C_count_sq_7500=np.zeros(len(Sum_C),dtype=float),np.zeros(len(Sum_C),dtype=float)#		      C_count_10000,C_count_sq_10000=np.zeros(len(Sum_C),dtype=float),np.zeros(len(Sum_C),dtype=float)#		      C_count_22500,C_count_sq_22500=np.zeros(len(Sum_C),dtype=float),np.zeros(len(Sum_C),dtype=float)		      		      #Using built in std_dev functions for these#		      LD_5000,zeta_5000=[],[]#		      LD_7500,zeta_7500=[],[]#		      LD_10000,zeta_10000=[],[]#		      LD_22500,zeta_22500=[],[]#		      LD_tot=0#		      LD=(8*np.pi*((np.mean(hist_A[Numbins/2-2:Numbins/2+2])+np.mean(hist_C[Numbins/2-2:Numbins/2+2]))/(2.*area*L_bin))*Bjerrum)**-0.5#		      LD_5000.append(LD)#		      LD_tot+=LD		      z_min=np.min([np.min(BA_z),np.min(BC_z)])		      z_max=np.max([np.max(BA_z),np.max(BC_z)])		    #At some point error analysis is needed on voltage and density profiles		      k+=1		    else:#		      hist_A,bin=np.histogram(BA_z, Numbins, (-L_box*0.5,L_box*0.5))		      hist_A = MyHist(BA_z,bin)		      Sum_A=Sum_A+hist_A		      SumSq_A=SumSq_A+hist_A**2#		      hist_C,bin=np.histogram(BC_z, Numbins, (-L_box*0.5,L_box*0.5))		      hist_C = MyHist(BC_z,bin)		      Sum_C=Sum_C+hist_C		      SumSq_C=SumSq_C+hist_C**2      		  		      Psi,Efield=quickCalc_VoltandField(Shell_bin,BA_z+bin[len(bin)-1],BC_z+bin[len(bin)-1],Sigma_s,dielectric,area,valence)		      Psi_tot=Psi_tot+Psi		      E_tot=E_tot+Efield		      		      Psi_sq=Psi_sq+Psi**2		      E_sq=E_sq+Efield**2   		      ##Use modified Widom to calculate instantaneous exp_muex_EV = exp(-muex_EV) to add to a total for later averaging		      		#muex_EV = -np.ln(exp_muex_EV/n_obs)      	    	      if type(r_ion) == type(0.5):			      exp_muex_EV,exp_muex_HS = quick_Calc_muex_EV(bin,Pos_A,Pos_C,M_per_slice,r_ion,eps_WCA,area)			      exp_muex_EV_tot=exp_muex_EV+exp_muex_EV_tot			      exp_muex_EV_sq=exp_muex_EV**2+exp_muex_EV_sq			      exp_muex_HS_tot=exp_muex_HS+exp_muex_HS_tot			      exp_muex_HS_sq=exp_muex_HS**2+exp_muex_HS_sq		      elif len(r_ion) == 2:			      exp_1muex_EV,exp_2muex_EV = Calc_2_muex_EV(bin,np.array(Pos_A),np.array(Pos_C),M_per_slice,r_ion,eps_WCA,area)			      exp_1muex_EV_tot+=exp_1muex_EV			      exp_2muex_EV_tot+=exp_2muex_EV			      exp_1muex_EV_sq = exp_1muex_EV_sq + exp_1muex_EV**2			      exp_2muex_EV_sq = exp_2muex_EV_sq + exp_2muex_EV**2				      		      z_min=np.min([np.min(BA_z),np.min(BC_z),z_min])		      z_max=np.max([np.max(BA_z),np.max(BC_z),z_max])  ######	Capacitance information to go here!!! - 11/05/10 12:14:29 		    z_plus=np.mean(BC_z)		    z_minus=np.mean(BA_z)		    qz_avg=(z_plus-z_minus)/2.		    #These quantities still need to be averaged after the loop is through		    p_avg+=(N_tot*qz_avg)		    p_squared+=(N_tot*qz_avg)**2		    #The following is a progress meter		    if not n_obs % 1000:		    	print filename,n_obs,n_obs/float(50000)		    #		    #Correlation time and error analysis, these still must be averaged after the loop is through! #		    if n_obs<=5000:#			Psi_5000+=Psi#			Psi_sq_5000+=Psi**2#			E_5000+=Efield#			E_sq_5000+=Efield**2#			A_count_5000+=hist_A#			A_count_sq_5000+=hist_A**2#			C_count_5000+=hist_C#			C_count_sq_5000+=hist_C**2#			LD_5000.append((8*np.pi*((np.mean(hist_A[Numbins/2-2:Numbins/2+2])+np.mean(hist_C[Numbins/2-2:Numbins/2+2]))/(2.*area*L_bin))*Bjerrum)**-0.5)#			zeta_5000.append(np.mean(abs(Psi[1]),abs(Psi[-1])))    #		    elif n_obs>5000 and n_obs<=12500:#			Psi_7500+=Psi#			Psi_sq_7500+=Psi**2#			E_7500+=Efield#			E_sq_7500+=Efield**2#			A_count_7500+=hist_A#			A_count_sq_7500+=hist_A**2#			C_count_7500+=hist_C#			C_count_sq_7500+=hist_C**2#			LD_7500.append((8*np.pi*((np.mean(hist_A[Numbins/2-2:Numbins/2+2])+np.mean(hist_C[Numbins/2-2:Numbins/2+2]))/(2.*area*L_bin))*Bjerrum)**-0.5)#			zeta_7500.append(np.mean(abs(Psi[1]),abs(Psi[-1])))    #		    elif n_obs>12500 and n_obs<=22500:#			Psi_10000+=Psi#			Psi_sq_10000+=Psi**2#			E_10000+=Efield#			E_sq_10000+=Efield**2#			A_count_10000+=hist_A#			A_count_sq_10000+=hist_A**2#			C_count_10000+=hist_C#			C_count_sq_10000+=hist_C**2#			LD_10000.append((8*np.pi*((np.mean(hist_A[Numbins/2-2:Numbins/2+2])+np.mean(hist_C[Numbins/2-2:Numbins/2+2]))/(2.*area*L_bin))*Bjerrum)**-0.5)#			zeta_10000.append(np.mean(abs(Psi[1]),abs(Psi[-1]))) #		    elif n_obs>22500:#			Psi_22500+=Psi#			Psi_sq_22500+=Psi**2#			E_22500+=Efield#			E_sq_22500+=Efield**2#			A_count_22500+=hist_A#			A_count_sq_22500+=hist_A**2#			C_count_22500+=hist_C#			C_count_sq_22500+=hist_C**2#			LD_22500.append((8*np.pi*((np.mean(hist_A[Numbins/2-2:Numbins/2+2])+np.mean(hist_C[Numbins/2-2:Numbins/2+2]))/(2.*area*L_bin))*Bjerrum)**-0.5)#			zeta_22500.append(np.mean(abs(Psi[1]),abs(Psi[-1])))  					    BA_z=[]		    BC_z=[]		    Pos_A=[]		    Pos_C=[]		    i=1	elif x[1]==1:	  BA_z.append(x[4])	  Pos_A.append([x[2],x[3],x[4]])	elif x[1]==2:	  BC_z.append(x[4])  	  Pos_C.append([x[2],x[3],x[4]])    #And to get the last (tricky) snapshot... - 4/27/11 @ 3.30p    n_obs+=1    #    hist_A,bin=np.histogram(BA_z, Numbins, (-L_box*0.5,L_box*0.5))    hist_A = MyHist(BA_z,bin)    Sum_A=Sum_A+hist_A    SumSq_A=SumSq_A+hist_A**2#    hist_C,bin=np.histogram(BC_z, Numbins, (-L_box*0.5,L_box*0.5))    hist_C = MyHist(BC_z,bin)    Sum_C=Sum_C+hist_C    SumSq_C=SumSq_C+hist_C**2             Psi,Efield=quickCalc_VoltandField(Shell_bin,BA_z+bin[len(bin)-1],BC_z+bin[len(bin)-1],Sigma_s,dielectric,area,valence)    Psi_tot=Psi_tot+Psi    E_tot=E_tot+Efield		          Psi_sq=Psi_sq+Psi**2    E_sq=E_sq+Efield**2        z_plus=np.mean(BC_z)    z_minus=np.mean(BA_z)    qz_avg=(z_plus-z_minus)/2.    p_avg+=(N_tot*qz_avg)    p_squared+=(N_tot*qz_avg)**2#    #This must be _LARGEST_BLOCK_SIZE#    Psi_22500+=Psi#    Psi_sq_22500+=Psi**2#    E_22500+=Efield#    E_sq_22500+=Efield**2#    A_count_22500+=hist_A#    A_count_sq_22500+=hist_A**2#    C_count_22500+=hist_C#    C_count_sq_22500+=hist_C**2#    LD_22500.append((8*np.pi*((np.mean(hist_A[Numbins/2-2:Numbins/2+2])+np.mean(hist_C[Numbins/2-2:Numbins/2+2]))/(2.*area*L_bin))*Bjerrum)**-0.5)#    zeta_22500.append(np.mean(abs(Psi[1]),abs(Psi[-1])))         print "Sorted data..."    L_z=L_box-2*r_wall    pot_drop=Sigma_s*L_z/dielectric    dipole_avg=p_avg/n_obs    dipole_avg_sq=p_squared/n_obs    kBT=1.    beta=1./kBT    dipole_var=beta*(dipole_avg_sq-dipole_avg**2.)    #Per conversation with Shell, to match up with theory, remove the 1 in (area*dielectric/L_z)*(1-dipole_avg/(dielectric*pot_drop))**-1    C_tot=(area*dielectric/L_z)*(1-dipole_avg/(dielectric*pot_drop))**-1    #Per conversation with Shell, to match up with theory, remove the 1 in (area*dielectric/L_z)*(1-dipole_var/(dielectric*area*L_z))**-1    C_dif=(area*dielectric/L_z)*(1-dipole_var/(dielectric*area*L_z))**-1    A_count=Sum_A/float(n_obs)    C_count=Sum_C/float(n_obs)    BA_den=Sum_A/(float(n_obs)*area*L_bin) #Unnormalized    BC_den=Sum_C/(float(n_obs)*area*L_bin) #Unnormalized          n0_BA=np.mean(BA_den[Numbins/2-2:Numbins/2+2])    n0_BC=np.mean(BC_den[Numbins/2-2:Numbins/2+2])           n0=(n0_BA+n0_BC)/2. #I think this is plenty fine as long as cations and anions differ only in +/- charge    print "Bulk concentration is %1.8f" % n0    lambda_D=(8.*np.pi*n0*Bjerrum)**(-0.5) # added valency on 02/18/10 14:20:23     print "Lambda_D is %1.5f" % lambda_D       #    Psi_var=Psi_sq/n_obs - (Psi_tot/n_obs)**2#    E_var=E_sq/n_obs - (E_tot/n_obs)**2#    A_var=SumSq_A/n_obs - (Sum_A/n_obs)**2#    C_var=SumSq_C/n_obs - (Sum_C/n_obs)**2#    LD_var,zeta_var=[],[]#    for (L,z) in zip(LD_5000,zeta_5000):#    	LD_var.append(L)#    	zeta_var.append(z)  #    for (L,z) in zip(LD_7500,zeta_7500):#    	LD_var.append(L)#    	zeta_var.append(z)  #    for (L,z) in zip(LD_10000,zeta_10000):#    	LD_var.append(L)#    	zeta_var.append(z)  #    for (L,z) in zip(LD_22500,zeta_22500):#    	LD_var.append(L)#    	zeta_var.append(z)  #    print 'Other lam_D = %1.5f' % np.mean(LD_var)	#    LD_var=np.var(LD_var)#    zeta_var=np.var(zeta_var)    #    Psi_5000_var=Psi_sq_5000/5000 - (Psi_5000/5000)**2#    E_5000_var=E_sq_5000/5000 - (E_5000/5000)**2#    A_5000_var=A_count_sq_5000/5000 - (A_count/5000)**2#    C_5000_var=C_count_sq_5000/5000 - (C_count/5000)**2#    LD_5000_var=np.var(LD_5000)#    zeta_5000_var=np.var(zeta_5000)#    Psi_7500_var=Psi_sq_7500/7500 - (Psi_7500/7500)**2#    E_7500_var=E_sq_7500/7500 - (E_7500/7500)**2#    A_7500_var=A_count_sq_7500/7500 - (A_count/7500)**2#    C_7500_var=C_count_sq_7500/7500 - (C_count/7500)**2#    LD_7500_var=np.var(LD_7500)#    zeta_7500_var=np.var(zeta_7500)#    #    Psi_10000_var=Psi_sq_10000/10000 - (Psi_10000/10000)**2#    E_10000_var=E_sq_10000/10000 - (E_10000/10000)**2#    A_10000_var=A_count_sq_10000/10000 - (A_count/10000)**2#    C_10000_var=C_count_sq_10000/10000 - (C_count/10000)**2#    LD_10000_var=np.var(LD_10000)#    zeta_10000_var=np.var(zeta_10000)#    Psi_22500_var=Psi_sq_22500/22500 - (Psi_22500/22500)**2#    E_22500_var=E_sq_22500/22500 - (E_22500/22500)**2#    A_22500_var=A_count_sq_22500/22500 - (A_count/22500)**2#    C_22500_var=C_count_sq_22500/22500 - (C_count/22500)**2#    LD_22500_var=np.var(LD_22500)#    zeta_22500_var=np.var(zeta_22500)#    print '\nPsi error ' + filename#    Psi_err=[]#    o=-1#    for (y_5000,y_7500,y_10000,y_22500,constant) in zip(Psi_5000_var,Psi_7500_var,Psi_10000_var,Psi_22500_var,Psi_var):#	o+=1#    	y=[y_5000,y_7500,y_10000,y_22500]#    	x=[constant/5000,constant/7500,constant/10000,constant/22500]#	two_tau,intercept=np.polyfit(x,y,1)#	Psi_err.append(constant*2/(n_obs*two_tau*0.5))#	print bin[o]#	for (yp,xp) in zip(y,x):#	  print xp,yp#	print '\n'  #	#    E_err=[]#    for (y_5000,y_7500,y_10000,y_22500,constant) in zip(E_5000_var,E_7500_var,E_10000_var,E_22500_var,E_var):#    	y=[y_5000,y_7500,y_10000,y_22500]#    	x=[constant/5000,constant/7500,constant/10000,constant/22500]#	two_tau,intercept=np.polyfit(x,y,1)#	E_err.append(constant*2/(n_obs*two_tau*0.5))#    A_err=[]#    for (y_5000,y_7500,y_10000,y_22500,constant) in zip(A_5000_var,A_7500_var,A_10000_var,A_22500_var,A_var):#    	y=[y_5000,y_7500,y_10000,y_22500]#    	x=[constant/5000,constant/7500,constant/10000,constant/22500]#	two_tau,intercept=np.polyfit(x,y,1)#	A_err.append(constant*2/(n_obs*two_tau*0.5))#    C_err=[]#    for (y_5000,y_7500,y_10000,y_22500,constant) in zip(C_5000_var,C_7500_var,C_10000_var,C_22500_var,C_var):#    	y=[y_5000,y_7500,y_10000,y_22500]#    	x=[constant/5000,constant/7500,constant/10000,constant/22500]#	two_tau,intercept=np.polyfit(x,y,1)#	C_err.append(constant*2/(n_obs*two_tau*0.5))#    y=[LD_5000_var,LD_7500_var,LD_10000_var,LD_22500_var]#    x=[LD_var/5000,LD_var/7500,LD_var/10000,LD_var/22500]#    two_tau,intercept=np.polyfit(x,y,1)#    LD_err=LD_var*2/(n_obs*two_tau*0.5)#    y=[zeta_5000_var,zeta_7500_var,zeta_10000_var,zeta_22500_var]#    x=[zeta_var/5000,zeta_var/7500,zeta_var/10000,zeta_var/22500]#    two_tau,intercept=np.polyfit(x,y,1)#    zeta_err=zeta_var*2/(n_obs*two_tau*0.5)    Psi_tot=Psi_tot/float(n_obs)      E_tot=E_tot/float(n_obs)    Psi_tot=Psi_tot-np.mean(Psi_tot)    if type(r_ion) == type(0.5):	    exp_muex_EV,exp_muex_HS = quick_Calc_muex_EV(bin,Pos_A,Pos_C,M_per_slice,r_ion,eps_WCA,area)	    exp_muex_EV_tot=exp_muex_EV+exp_muex_EV_tot	    exp_muex_EV_sq=exp_muex_EV**2+exp_muex_EV_sq	    exp_muex_HS_tot=exp_muex_HS+exp_muex_HS_tot	    exp_muex_HS_sq=exp_muex_HS**2+exp_muex_HS_sq    	    muex_EV=-np.log(exp_muex_EV_tot/float(n_obs))	    muex_EV_total=-np.log(sum(exp_muex_EV_tot)/float(n_obs*len(exp_muex_EV_tot)))	    muex_HS=-np.log(exp_muex_HS_tot/float(n_obs))	    muex_HS_total=-np.log(sum(exp_muex_HS_tot)/float(n_obs*len(exp_muex_HS_tot)))    #	    muex_EV=-np.log(exp_muex_EV_tot/float(n_obs))#	    muex_EV_total=-np.log(sum(exp_muex_EV_tot)/float(n_obs*len(exp_muex_EV_tot)))#	    total_prefix='Analyzed_error' + filename[4:len(filename)-4]#	    total_output=file(total_prefix+"_DATA.txt","w")#	    for (z,V,E,Np,Nm,V_err,Ef_err,A_err,C_err,Ovar_Psi,Ovar_E,Ovar_A,Ovar_C) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion],Psi_err+[LD_err],E_err+[zeta_err],A_err+[LD_var,zeta_var],C_err+[np.pi,np.pi],Psi_var.tolist()+[np.pi],E_var.tolist()+[np.pi],A_var.tolist()+[np.pi,np.pi],C_var.tolist()+[np.pi,np.pi]):#	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,V_err,Ef_err,A_err,C_err,Ovar_Psi,Ovar_E,Ovar_A,Ovar_C))   #	    total_output.close()	    total_prefix='Analyzed_' + filename[4:len(filename)-4]	    total_output=file(total_prefix+"_DATA.txt","w")	    for (z,V,E,Np,Nm) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion]):	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm))   	    if (len(wallZ_L)!=0) and (len(wallZ_R)!=0):		total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (0,0,0,np.mean(wallZ_L),np.mean(wallZ_R))) 	    total_output.close()	    total_prefix='Analyzed_muexEV_' + str(M_per_slice) + filename[4:len(filename)-4]	    total_output=file(total_prefix+"_DATA.txt","w")	    for (z,V,E,Np,Nm,muexEV) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion],muex_EV.tolist()+[muex_EV_total]):	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV))   	    total_output.close() 	    AvInWallZ = r_wall - 0.5*(abs(np.mean(wallZ_L)+L_z*0.5)+(np.mean(wallZ_R)-L_z*0.5))	    Xi = Sigma_s*2.*np.pi*Bjerrum**2	    newname = 'Analyzed_GC_'+str(N_tot)+'_'+str(Xi)+'_'+str(Bjerrum)+'_'+str(2*r_ion)+'_'+str(L_z)+'_'+str(round(np.sqrt(area),2))	    total_output= file(newname+".txt","w") 	    for (z,V,E,Np,Nm,muexEV,muexHS) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[z_min],E_tot.tolist()+[z_max],A_count.tolist()+[lambda_D,r_ion],C_count.tolist()+[area,Bjerrum],muex_EV.tolist()+[AvInWallZ],muex_HS.tolist()+[AvInWallZ]):		total_output.write("%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\n" % (z,V,E,Nm,Np,muexEV,muexHS))	    total_output.close()        elif len(r_ion) == 2:	    muex_EV1=-np.log(exp_1muex_EV_tot/float(n_obs))	    muex_EV2=-np.log(exp_2muex_EV_tot/float(n_obs)) 	    total_prefix='Analyzed_sigr' + filename[4:len(filename)-4]	    total_output=file(total_prefix+"_DATA.txt","w")	    for (z,V,E,Np,Nm) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion[0]]):	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm))   	    if (len(wallZ_L)!=0) and (len(wallZ_R)!=0):		total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (0,0,0,np.mean(wallZ_L),np.mean(wallZ_R))) 	    total_output.close()		      		    total_prefix='Analyzed_muexEV_sigr_' + str(M_per_slice) + filename[4:len(filename)-4]	    total_output=file(total_prefix+"_DATA.txt","w")	    for (z,V,E,Np,Nm,muexEV1,muexEV2) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion[1]],muex_EV1.tolist()+[np.mean(wallZ_L)],muex_EV2.tolist()+[np.mean(wallZ_R)]):	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV1,muexEV2))   	    total_output.close()	    AvInWallZ = r_wall - 0.5*(abs(np.mean(wallZ_L)+L_z*0.5)+(np.mean(wallZ_R)-L_z*0.5))	    Xi = Sigma_s*2.*np.pi*Bjerrum**2	    newname = 'Analyzed_GC_'+str(N_tot)+'_'+str(Xi)+'_'+str(Bjerrum)+'_'+str(2*r_ion[0])+'_'+str(L_z)+'_'+str(round(np.sqrt(area),2))+'_'+str(2*r_ion[1])	    total_output= file(newname+".txt","w") 	    for (z,V,E,Np,Nm,muexEV,muexHS) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[z_min],E_tot.tolist()+[z_max],A_count.tolist()+[lambda_D,r_ion[0]/r_ion[1]],C_count.tolist()+[area,Bjerrum],muex_EV1.tolist()+[AvInWallZ],muex_EV2.tolist()+[AvInWallZ]):		total_output.write("%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\n" % (z,V,E,Nm,Np,muexEV,muexHS))	    total_output.close() 	    	    #    AvInWallZ = r_wall - 0.5*(abs(np.mean(wallZ_L)+L_z*0.5)+(np.mean(wallZ_R)-L_z*0.5))#    Xi = Sigma_s*2.*np.pi*Bjerrum**2#    newname = 'Analyzed_GC_'+str(N_tot)+'_'+str(Xi)+'_'+str(Bjerrum)+'_'+str(2*r_ion)+'_'+str(L_z)+'_'+str(round(np.sqrt(area),2))#    total_output= file(newname+".txt","w") #    for (z,V,E,Np,Nm,muexEV,muexHS) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[z_min],E_tot.tolist()+[z_max],A_count.tolist()+[lambda_D,r_ion],C_count.tolist()+[area,Bjerrum],muex_EV.tolist()+[AvInWallZ],muex_HS.tolist()+[AvInWallZ]):#	total_output.write("%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\t\t\t\t%-1.8f\n" % (z,V,E,Nm,Np,muexEV,muexHS))#    total_output.close()   #        print 'Finished ' + filename_orignal    return#GC_System('1000_7_1_2_23.2_21.7.gz',1,502,1.,10)#######GC_System(filename,Bjerrum,Numbins,r_ion,M_per_slice)#GC_System('1000_ss_zeta_3.776.txt',1,502,1.,10)def CDF(filename,r_ion):    """Generates and saves plots for the cylindrical distribution function.    This demands that L_x = L_y    It also is ONLY for CDF of a sheet that is up against the wall.Input:    filename: the name of the input fileOutput:    None, only saved plots in the directory the code was ran."""     #Hard-coded values that cannot be determined from file    r_wall=1.0    z_lo=-251.    z_hi=-250+0.55*2*r_ion    r_AA,r_AC,r_CC=[],[],[]    NA,NC=0,0    A,C=[],[]    Numbins=50    if filename[-3:]=='.gz':        Data=gzip.GzipFile(fileobj=open(filename,'rb'))	filename=filename[0:len(filename)-2]+'txt'    else:        Data=file(filename,"r")    print '\n'    print filename    graph_prefix=filename[0:len(filename)-4]    nth=1     # new addition, untested - 02/10/10 13:17:25 , also unused - 11/18/10 11:47:02        n_obs=0    i,k=0,0    get_box_dims=0    for y in Data:      x=y.split()                 #Acquire box dimensions      get_box_dims+=1      if get_box_dims<=8:	if get_box_dims==6:	  L_x=float(x[1])-float(x[0])	elif get_box_dims==7:	  L_y=float(x[1])-float(x[0])	  area=L_x*L_y	elif get_box_dims==8:	  L_box=float(x[1])-float(x[0])	  z_wall=-0.5*L_box+r_wall	  L_xy=L_x	  r_max=0.5*L_xy ##99% sure this is the old way	  print 'new update to CDF, r_max = L_xy...'	  print 'This can be accelerated with iL_xy type additions'	  V=(z_hi-z_lo-r_wall)*L_xy**2	        if not x[0]=="ITEM:":	x=[float(xx) for xx in x]	if len(x)<=2:	  i+=1	  if i==6: #This means an entire timestep worth of data is had	    n_obs+=1	    for (i,ri) in enumerate(A):    		for (j,rj) in enumerate(A):     			if i!=j:   				r=ri[0:2]-rj[0:2]   				r=r-L_xy*np.round_(r/L_xy)   				r=np.sqrt(r[0]**2+r[1]**2)   				if r<=r_max:    					r_AA.append(r) #This gives AA and must be changed				    		for (j,rj) in enumerate(C):			r=ri[0:2]-rj[0:2]			r=r-L_xy*np.round_(r/L_xy)			r=np.sqrt(r[0]**2+r[1]**2)   			if r<=r_max:				r_AC.append(r) 	 #This gives AC and must be changed				    for (i,ri) in enumerate(C):    		for (j,rj) in enumerate(C):    			if i!=j:   				r=ri[0:2]-rj[0:2]   				r=r-L_xy*np.round_(r/L_xy)   				r=np.sqrt(r[0]**2+r[1]**2)   				if r<=r_max:					r_CC.append(r) #This gives CC and must be changed		    i=1	    A,C=[],[]	elif x[1]==1.0:	      if x[4]<=z_hi and x[4]>z_lo:		xyz=[x[2],x[3]]		A.append(np.array(xyz))		NA+=len(A)	elif x[1]==2.0:	      if x[4]<=z_hi and x[4]>z_lo:		xyz=[x[2],x[3]]		C.append(np.array(xyz))	  		NC+=len(C)    				    				    CDF_output=file(graph_prefix + '_' + str(Numbins)+ '_' + "CDF_Output.txt","w")    NA=NA/float(n_obs)    NC=NC/float(n_obs)    g_AA,g_AC,g_CC=[],[],[]    hi,lo=z_hi,z_lo    hist,bin=np.histogram(np.array(r_AA), Numbins, (0,r_max))    bin_width=(bin[1]-bin[0])    for (i,ci) in zip(np.arange(len(hist)),hist):   		g_AA.append((ci/(n_obs*NA*(NA-1.)))*(V/(np.pi*(hi-lo)*(2.*i+1.)*bin_width**2.)))    	    hist,bin=np.histogram(np.array(r_CC), Numbins, (0,r_max))    for (i,ci) in zip(np.arange(len(hist)),hist):   	    	g_CC.append((ci/(n_obs*NC*(NC-1.)))*(V/(np.pi*(hi-lo)*(2.*i+1.)*bin_width**2.)))     hist,bin=np.histogram(np.array(r_AC), Numbins, (0,r_max))    for (i,ci) in zip(np.arange(len(hist)),hist):    	g_AC.append((ci/(n_obs*NA*NC))*(V/(np.pi*(hi-lo)*(2.*i+1.)*bin_width**2.)))    g_AA_bulk=np.mean(g_AA[-5:len(g_AA)-1])    g_CC_bulk=np.mean(g_CC[-5:len(g_CC)-1])    g_AC_bulk=np.mean(g_AC[-5:len(g_AC)-1])    g_AA=[x/g_AA_bulk for x in g_AA]    g_CC=[x/g_CC_bulk for x in g_CC]    g_AC=[x/g_AC_bulk for x in g_AC]    bin=[(x+y)/2. for (x,y) in zip(bin[0:len(bin)-1],bin[1:len(bin)])] #Not sure what I feel about this...    CDF_output.write("Bin		g_AA		g_AC		g_CC\n")     for (r,AA,AC,CC) in zip(bin,g_AA,g_AC,g_CC):      CDF_output.write("%1.3f		%1.3f		%1.3f		%1.3f\n" % (r,AA,AC,CC))    CDF_output.close()                 returndef Forces_GC_System(filename):    """Returns a histogram of the z-positions for ionsInput:XXX    Data:     (N,3) array of atomic positions    sigma:    dimless charge density, must be manually entered    filename: the name of the input fileOutput:    None, only printed statements that are written to a .txt file from the command line"""    print '\nModify this so that you determine the force profile on both anions and cations and then print out the data that is plotted - 08/20/10 10:13:00 \n'   #   The valency needs to be added into the lambda_D calculation. This function is currently incorrect 02/18/10 14:23:43	#Should this be used, it needs to be drastically re-worked... - 02/04/11 14:49:17        filename_orignal=filename    if filename[-3:]=='.gz':        Data=[[float(x) for x in line.split()] for line in gzip.GzipFile(fileobj=open(filename,'rb')).readlines() if not line.startswith("ITEM")]	filename=filename[0:len(filename)-2]+'txt'    else:        Data=[[float(x) for x in line.split()] for line in file(filename,"r").readlines() if not line.startswith("ITEM")]    print '\n'    print filename    print "Loaded data..."    graph_prefix=filename[0:len(filename)-4]         #These are hard coded values that cannot be determined from Data[]    valency=1.0    r_wall=1.0    r_ion=0.01    eps_wall=10    wall_type=126 #or 93 #note his!        L_box=Data[4][1]-Data[4][0] #-0.43 #The 0.43 (or any number) truncates how many empty bins are shown for positions inside the wall.        #Histogram Stuff    Numbins=102    #Note this!    bin=np.array([((-L_box/2.)+i*(L_box/float(Numbins))) for i in range(Numbins)]+[L_box*0.5]) #This makes this script compabtible on both Mac and Mellon    bin_plot=[(x+y)/2. for (x,y) in zip(bin[0:len(bin)-1],bin[1:len(bin)])]    #Create empty vectors to fill    FA_Data,FA_z=[],[]    FC_Data,FC_z=[],[]            i,k=0,0    for x in Data:      if len(x)<=2:	i+=1	if i==6: #This means an entire timestep worth of data is had	  if k==0: #This indicates that the first timestep worth of data having been collected#	    BA_qty=len(FA_z)	    k+=1	  FA_Data.append(sorted(FA_z))	  FC_Data.append(sorted(FC_z))	  FA_z=[]	  FC_z=[]	  i=1      elif x[1]==1:        z_and_Fs=[x[4],x[11],x[12],x[13]]        FA_z.append(z_and_Fs)      elif x[1]==2:        z_and_Fs=[x[4],x[11],x[12],x[13]]        FC_z.append(z_and_Fs)             print "Sorted data..."	#Theory Stuff    area=abs(Data[2][0]-Data[2][1])*abs(Data[3][0]-Data[3][1]) #width times height of the box    z_wall=-0.5*L_box+r_wall        zeta_Ex=float(filename[-11:-6])    zeta=str(zeta_Ex)        #Forces histograms     Fx_hist,Fy_hist,Fz_hist=OptHist(FA_Data[0],bin)    Fx_hist=[[x] for x in Fx_hist]    Fy_hist=[[x] for x in Fy_hist]    Fz_hist=[[x] for x in Fz_hist]	    for FA in FA_Data[1:]:	i=0	Fx,Fy,Fz=OptHist(FA,bin)	for (x,y,z) in zip(Fx,Fy,Fz):	    Fx_hist[i].append(x)	    Fy_hist[i].append(y)	    Fz_hist[i].append(z)	    i+=1    FA_x=[np.mean(np.array(x)) for x in Fx_hist]    FA_y=[np.mean(np.array(x)) for x in Fy_hist]    FA_z=[np.mean(np.array(x)) for x in Fz_hist]    FA_mag=[]    for (x,y,z) in zip(FA_x,FA_y,FA_z):    	FA_mag.append(np.sqrt(x**2+y**2+z**2))           #Forces histograms, cations    Fx_hist,Fy_hist,Fz_hist=OptHist(FC_Data[0],bin)    Fx_hist=[[x] for x in Fx_hist]    Fy_hist=[[x] for x in Fy_hist]    Fz_hist=[[x] for x in Fz_hist]	    for FC in FC_Data[1:]:	i=0	Fx,Fy,Fz=OptHist(FC,bin)	for (x,y,z) in zip(Fx,Fy,Fz):	    Fx_hist[i].append(x)	    Fy_hist[i].append(y)	    Fz_hist[i].append(z)	    i+=1    FC_x=[np.mean(np.array(x)) for x in Fx_hist]    FC_y=[np.mean(np.array(x)) for x in Fy_hist]    FC_z=[np.mean(np.array(x)) for x in Fz_hist]    FC_mag=[]    for (x,y,z) in zip(FC_x,FC_y,FC_z):    	FC_mag.append(np.sqrt(x**2+y**2+z**2))       plt.subplot(221)    plt.title('Force Profiles for Anions')    plt.plot(bin_plot,FA_x,'-',color='blue',label=r'$\tilde F_x$')    plt.legend(loc=0)    plt.grid(True)    plt.ylabel(r'$\tilde F$($\tilde z$)',size='x-large')    plt.xlabel(r'$\tilde z$',size='x-large')        plt.subplot(222)    plt.title(r'$\~\zeta$ = '+zeta)    plt.plot(bin_plot,FA_y,'-',color='orange',label=r'$\tilde F_y$')    plt.legend(loc=0)    plt.grid(True)    plt.ylabel(r'$\tilde F$($\tilde z$)',size='x-large')    plt.xlabel(r'$\tilde z$',size='x-large')        plt.subplot(223)    plt.plot(bin_plot,FA_z,'-',color='brown',label=r'$\tilde F_z$')    plt.legend(loc=0)    plt.grid(True)    plt.ylabel(r'$\tilde F$($\tilde z$)',size='x-large')    plt.xlabel(r'$\tilde z$',size='x-large')        plt.subplot(224)    plt.plot(bin_plot,FA_mag,'k-',label=r'|$\tilde F$|')#    plt.ylim(ymin=-20)    plt.legend(loc=0)    plt.grid(True)    plt.ylabel(r'$\tilde F$($\tilde z$)',size='x-large')    plt.xlabel(r'$\tilde z$',size='x-large')    graph_name=graph_prefix+'_A_'+"Forces.pdf"    plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)    plt.close()        graph_output=file(graph_prefix+"_Forces.txt","w")    for (z,A_x,C_x,A_y,C_y,A_z,C_z,A_mag,C_mag) in zip(bin_plot,FA_x,FC_x,FA_y,FC_y,FA_z,FC_z,FA_mag,FC_mag):    	graph_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t\n" % (z,A_x,C_x,A_y,C_y,A_z,C_z,A_mag,C_mag))    graph_output.close()          returndef polyfit(x, y, degree):    results = {}    coeffs = np.polyfit(x, y, degree)     # Polynomial Coefficients    results['polynomial'] = coeffs.tolist()    # r-squared    p = np.poly1d(coeffs)    # fit values, and mean    yhat = [p(z) for z in x]    ybar = sum(y)/len(y)    ssreg = sum([ (yihat - ybar)**2 for yihat in yhat])    sstot = sum([ (yi - ybar)**2 for yi in y])    print ssreg/sstot    results['determination'] = ssreg / sstotdef Histogram(Pos,bin):    """Returns a histogram of the z-positions for ionsInput:    Pos: (N,many) array of z positions    bin: vector of bin dimensionsOutput:	counts:	a histogram of counts for z-values within their respective bins   vxy_squared:	a histogram of vxysquared = (vx^2 + vy^2) values within their respective bins"""        #Start with zeroed bins    counts= np.zeros((len(bin)-1), int)    counts= np.zeros(len(bin), int)    vxy_squared= np.zeros((len(bin)-1), int)    print bin        for x in Pos: #Scroll through all the ion positions of Pos        k=0        while k<(len(bin)-1): #iterate through all the bin sets            if x>=bin[k] and x<bin[k+1]: #check to see if the z-position is within a particular bin	         counts[k]+=1 # then add a count in bin k#	    vxy_squared[k]+=x[8]**2+x[9]**2 #Calculate vxy^2 = (vx^2 + vy^2), used for Txy            k+=1 #iterare the bin index	  	        return counts,vxy_squareddef OptHist(Pos,bin):    """Returns a histogram of the z-positions for ionsInput:    Pos:  (N,many) sorted array of atomic positions    bin:  vector of bin dimensionsOutput:	counts:	a histogram of counts for z-values within their respective bins"""        #Start with zeroed bins    counts= np.zeros(len(bin)-1, int)    Fx= np.zeros(len(bin)-1, int)    Fy= np.zeros(len(bin)-1, int)    Fz= np.zeros(len(bin)-1, int)    k_store=0        for x in Pos: #Scroll through all the ion positions of Pos        k,get_next_x=k_store,False        while (k<(len(bin)-1) and not(get_next_x)): #iterate through all the bin sets	  if x[0]>=bin[k] and x[0]<bin[k+1]: #check to see if the z-position is within a particular bin	    Fx[k]+=x[1]	    Fy[k]+=x[2]	    Fz[k]+=x[3]	    counts[k]+=1	    k=k_store	    get_next_x=True	  k+=1 #iterare the bin index	      mean_Fx,mean_Fy,mean_Fz=[],[],[]    for (count,x,y,z) in zip(counts,Fx,Fy,Fz):    	if count!=0:    	     count=float(count)    	     mean_Fx.append(x/count)    	     mean_Fy.append(y/count)        	     mean_Fz.append(z/count)    	elif count==0:    	     mean_Fx.append(0.)    	     mean_Fy.append(0.)        	     mean_Fz.append(0.)           return mean_Fx,mean_Fy,mean_Fzdef DisplacementHistogram(r,Numbins):    """Returns a histogram of the r_displacement valuesInput:      r: N-length vector of |r-r_0| values    bin: quantity of binsOutput:    counts: a histogram of counts for |r-r_0| values within their respective bins      bins: vector that contains bin dimensions"""    #This function implies Numbins is known for a particular array of |r-r_0| values    # this may need to be slightly re-thought        L=abs(max(r)-min(r)) #z-length of sim box    bin=[((-L/2)+i*(L/float(Numbins))) for i in range(Numbins+1)]    counts = np.zeros((len(bin)-1), int)            for x in r: #Scroll through all the |r-r_0| values of r        k=0        while k<(len(bin)-1): #iterate through all the bin sets	  if x>=bin[k] and x<bin[k+1]: #check to see if the |r-r_0| value is within a particular bin	    counts[k]+=1 # then add a count in bin k	  k+=1 #iterare the bin index	  	        return counts,bindef Displacement(Data,time0,atom_type):    """Returns a histogram of counts vs. displacementInput:    Data: (N,3) array of atomic positions    time0: The timestep from which migration will start    atom_type: LAMMPS atom_typeOutput:    None, only printed statements that are written to a .txt file from the command line    PROBABLY ANOTHER DEFUNCT CODE... - 12/07/10 14:02:34 """    #The output should be changed to generated files that are printed in the directory in which the code is being ran.    # If this code is ever used, it should be re-looked at before being built upon.    # ALSO, THIS CODE REQUIRES SORTING THE (XU,YU,ZU) COORD'S BECAUSE LAMMPS DOESN'T OUTPUT THEM IN A CONSISTEN MANNER!!!            #Various iterators    h=0    i=0    j=0    k=0    collect=False    makePos0=False          #Create empty vectors to fill    Pos0=[]    Positions=[]    r=[]    temptimestep=[]    timestep=[]    RMatrix=[]    BinMatrix=[]    midpoint=[]    time0=[time0] #This is a nice, but possibly unneccsary feature. If the dump frequence from LAMMPS does not change,		  # (which it never does) then only a d_timestep is needed!            for x in Data:      if x==time0:    #This starts the collection	collect=True  # of position data for	makePos0=True # all times and make Pos0	      if len(Pos0) and len(x)!=11: #This stops making Pos0	makePos0=False		  # after it's been filled	      if len(x)!=11: #This stores all of the timestep values	i+=1		  	if i==6:	  temptimestep.append([np.sum(Data[j*int(np.sum(Data[1])+5)])]) #The times not needed will be excluded in a later loops	  i=1	  j+=1      elif x[1]==atom_type and collect:    #If this is a particle of the desired type,	Positions.append([x[5],x[6],x[7]]) # store (xu,yu,zu)	if makePos0 and x[1]==atom_type:	  Pos0.append([x[5],x[6],x[7]])  # store (xu_0,yu_0,zu_0)	      for x in temptimestep: #This loops looks at the timesteps      if x>=time0: 	   # above (in temptimesteps) and 	timestep.append(x) # collects that are relevent for analysis.	    timestep.append(Data[-int(np.sum(Data[1])+5)]) #This gets the last timestep value        for x in Positions:                                                               #For every atom,      r.append((Pos0[k][0]-x[0])+(Pos0[k][1]-x[1])+(Pos0[k][2]-x[2])) # find out how far it has migrated      #The r above ^^^ is incorrect! It should be abs(r-r_0), or |r-r_0| or np.sqrt((x-x0)^2+(y-...))            k+=1      if k==len(Pos0):	k=0	hist,bin=DisplacementHistogram(r,Numbins)		#Build data matricies of the |r-r_0| histograms and their associated bin dimensions	RMatrix.append(hist) 	BinMatrix.append(bin)	r=[]      #print np.sum(RMatrix,axis=1)    t=0    k=-1    #Print displacement Histogram Info    print "Displacement Type %i" % atom_type    for bin in BinMatrix:      h=0      k+=1      print "\n",int(np.sum(timestep[t]))      t+=1      midpoint=[]      for x in np.zeros((len(bin)-1), int):	  midpoint.append((bin[h]+bin[h+1])/2.)	  h+=1      for (y,z) in zip(midpoint,RMatrix[k]):	  print "%2.5f  	%4i" % (y,z)      #Useful notes for use when this function is to be completed.      ## make x data      #num = 100      #x = scipy.linspace(-10, 10, num=num) - MY BIN MIDPOINTS      #distancePerLag = x[1]-x[0]      ## make two gaussians, with different means      #offset = 2.0      #y1 = scipy.exp(-x**2/8.0)      #y2 = scipy.exp(-(x-offset)**2/1.0)      ## compute the cross-correlation between y1 and y2      #ycorr = scipy.correlate(y1, y2, mode='full')      #xcorr = scipy.linspace(0, len(ycorr)-1, num=len(ycorr))      ## define a gaussian fitting function where      ## p[0] = amplitude      ## p[1] = mean      ## p[2] = sigma      #fitfunc = lambda p, x: p[0]*scipy.exp(-(x-p[1])**2/(2.0*p[2]**2))      #errfunc = lambda p, x, y: fitfunc(p,x)-y      ## guess some fit parameters      #p0 = scipy.c_[max(ycorr), scipy.where(ycorr==max(ycorr))[0], 5]      ## fit a gaussian to the correlation function      #p1, success = scipy.optimize.leastsq(errfunc, p0.copy(), \					  #args=(xcorr,ycorr))      ## compute the best fit function from the best fit parameters      #corrfit = fitfunc(p1, xcorr)      ## get the mean of the cross-correlation      #xcorrMean = p1[1]      ## convert index to lag steps      ## the first point has index=0 but the largest (negative) lag      ## there is a simple mapping between index and lag      #nLags = xcorrMean-(len(y1)-1)      ## convert nLags to a physical quantity      ## note the minus sign to ensure that the      ## offset is positive for y2 is shifted to the right of y1      ## a negative offset means that y2 is shifted to the left of y1      ## I don't know what the standard notation is (if there is one)      #offsetComputed = -nLags*distancePerLag      ## see how well you have done by comparing the actual      ## to the computed offset      #print 'xcorrMean, nLags = ', \	  #xcorrMean, ', ', nLags      #print 'actualOffset, computedOffset = ', offset,', ', offsetComputed      ## visualize the data      ## plot the initial functions      #pylab.subplot(211)      #pylab.plot(x, y1, 'ro')      #pylab.plot(x, y2, 'bo')      ## plot the correlation and fit to the correlation      #pylab.subplot(212)      #pylab.plot(xcorr, ycorr, 'k.')      #pylab.plot(xcorr, corrfit, 'r-')      #pylab.plot([xcorrMean, xcorrMean], [0, max(ycorr)], 'g-')      #pylab.show()#for (x,y) in zip(MC_per_part,MeanSqDisp):    #if (x,y)==(-1.0,-1.0):        #print "\n"    #else:        #print "%4.5f            %4.5f" % (x,y)	#AT THIS POINT, SCIPY NEEDS TO BE INSTALLED AND FITTING WITH THAT SHOULD OCCUR	  	        returndef Ion_Lattice():    """Returns lattice spaced wall and point-charge positions.Input:    N: the number of +/- ions along x and y axes    x:     the x-length of the simulation box whose edges are +/- 0.5*x    y:     the y-length of the simulation box whose edges are +/- 0.5*y    z:     the z-length of the simulation box whose edges are +/- 0.5*zOutput:    none"""        Lammps_text=file("Lammps_text.txt","w")        #    #This code below gives 3200 (1600+ and 1600-) positions##    x_grid=[-1,-2,1,2]##    y_grid=[-1,-2,1,2]###    z_grid=[1,2,3,4,5]#    N=1000#    L=300#    NLat = int(N**(1./3.) + 1.)#    LatSpac = L / NLat#    r = LatSpac * np.arange(NLat, dtype=float) - 0.5*L#    i=0#    j=0#    count=0#    for z in r:#        for x in r:#            for y in r:#                i+=1#                a_type=2#                if (i % 2):#                    a_type=1#                    i=1#                if count<N:#                	Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (a_type,x,y,z))#                	j+=1#                count+=1#    print j    #This code below gives 160 (80+ and 80-) positions    x_grid=[-1,-2,1,2]    y_grid=[-1,-2,1,2]    z_grid=[0]    i=0    for z in z_grid:        for x in x_grid:            for y in y_grid:                i+=1                if (i % 2):                    a_type=1                else:                    a_type=2                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (1,x,y,z))                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,y,-z))    #    #This code below gives 160 (80+ and 80-) positions#    x_grid=[-1,-2,1,2]#    y_grid=[-1,-2,1,2]#    z_grid=[1,2,3,4,5]#    i=0#    for z in z_grid:#        for x in x_grid:#            for y in y_grid:#                i+=1#                if (i % 2):#                    a_type=1#                else:#                    a_type=2#                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (1,x,y,z))#                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,y,-z))#    #This code is for 2d colloid#    x_grid=[x for x in np.arange(-3,3)]#    y_grid=[y for y in np.arange(-4,4)]#    for y in y_grid:#         Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,4,y,0))#         Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,-4,y,0))#    for x in x_grid:#         Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,4,0))#         Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,-4,0))#    Lammps_text.write("\n\n3D Positions Below\n")#    #This code is for 3d colloid#    x_grid=[x for x in np.arange(-4,4)]#    y_grid=[y for y in np.arange(-4,4)]##    z_grid=[y for y in np.arange(-4,4)]#    for x in x_grid:#         for y in y_grid:#              Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,y,4))#              Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,y,-4))#    #    z_grid=[z for z in np.arange(-3,3)]#    y_grid=[y for y in np.arange(-4,4)]#    for y in y_grid:#         for z in z_grid:#              Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,4,y,z))#              Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,-4,y,z))#    z_grid=[z for z in np.arange(-3,3)]#    x_grid=[x for x in np.arange(-3,3)]#    for x in x_grid:#         for z in z_grid:#              Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,3,z))#              Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,-3,z))#    #This code should give 320 (160+ and 160-) positions #    x_grid=[1,2,3,4]#    y_grid=[1,2,3,4]#    z_grid=[2,3,4,5,6]#    i=0#    for z in z_grid:#        for x in x_grid:#            for y in y_grid:#                i+=1#                if (i % 2):#                    a_type=1#                else:#                    a_type=2#                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (1,x,y,z))#                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,y,-z))#                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (1,-x,y,z))#                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,-x,y,-z))##    #This code gives 640 (320+ and 320-) positions ##    x_grid=[-1,-2,-3,-4,1,2,3,4]##    y_grid=[-1,-2,-3,-4,1,2,3,4]##    z_grid=[2,3,4,5,6]##    i=0##    for z in z_grid:##        for x in x_grid:##            for y in y_grid:##                i+=1##                if (i % 2):##                    a_type=1##                else:##                    a_type=2##                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (1,x,y,z))##                Lammps_text.write("\ncreate_atoms	%i single %i %i %i units box" % (2,x,y,-z))    # This code below should give 1080 positions#    x_grid=[-3,-2,-1,1,2,3]#    y_grid=[-3,-2,-1,1,2,3]#    z_grid=[z*0.5 for z in [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]]#    print z_grid#    i=0#    for z in z_grid:#        for x in x_grid:#            for y in y_grid:##                i+=1##                if (i % 2):##                    a_type=1##                else:##                    a_type=2#                Lammps_text.write("\ncreate_atoms	%i single %i %i %.1f units box" % (1,x,y,z))#                Lammps_text.write("\ncreate_atoms	%i single %i %i %.1f units box" % (2,x,y,-z))    Lammps_text.close()        returndef GC_density(z,lam_D,zeta,rho_bulk,sign):    """Gives the GCT density as used for InitialPositiions(...) [and possibly GC_System(...) in the future]Input:    z:		z from the wall    lam_D:      screening length    zeta:       the applied zeta potential of the system    sign:       is positive for counter-ions.Output:    none"""        psi_GCT=2*np.log((1+np.exp(-(z)/lam_D)*np.tanh(zeta/4.))/(1-np.exp(-(z)/lam_D)*np.tanh(zeta/4.)))    return rho_bulk*np.exp(sign*psi_GCT)def simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000): # N must be even on entry    "Approximate the definite integral of f from a to b, using Composite Simpson's rule - thank you Wikipedia!"        h = float(b-a)/N   # this is factored out of the loop just for efficiency    return  h/3 * ( GC_density(a,lam_D_spec,zeta,rho_bulk,sign) + 2*sum((k%2+1) * GC_density(a + h*k,lam_D_spec,zeta,rho_bulk,sign) for k in range(1,N)) + GC_density(b,lam_D_spec,zeta,rho_bulk,sign) )def WCA(eps,r_cut,r):    """WCA potentialInput:    eps:	characteristic energy, units of kT    r_cut:      intermolecular distance beyond which potential = 0    		I  report this as \sigma in my results    r:       	intermolecular separationOutput:    Evaluation of the WCA potential at r"""        if r>r_cut:    	return 0    else:#    	r_cut = 1#    	sig_LJ=r_cut/(2.**(1./6))#    	return 4*eps*((sig_LJ/r)**12 - (sig_LJ/r)**6+0.25)#	r=r/r_cut    	return 4*eps*(0.25*(r_cut/r)**12 - 0.5*(r_cut/r)**6+0.25)#    	return 4*eps*(0.25*(1/r)**12 - 0.5*(1/r)**6+0.25)def B2_integrand(eps,r_cut,r):    return 2*np.pi*(1-np.exp(-WCA(eps,r_cut,r)))*r**2def B2_WCA(eps,r_cut, a, b, N): # N must be even on entry    """Approximate the definite integral of f from a to b, using Composite Simpson's rule - thank you Wikipedia!    http://en.wikipedia.org/wiki/Simpson's_rule#Composite_Simpson.27s_rule"""        h = float(b-a)/N   # this is factored out of the loop just for efficiency    return h/3 * ( B2_integrand(eps,r_cut,a) + 2*sum((k%2+1) * B2_integrand(eps,r_cut,a + h*k) for k in range(1,N)) + B2_integrand(eps,r_cut,b) )def Noro_integrand(eps,r_cut,r):    return (1-np.exp(-WCA(eps,r_cut,r)))def Noro_WCA(eps,r_cut, a, b, N): # N must be even on entry    """Approximate the definite integral of f from a to b, using Composite Simpson's rule - thank you Wikipedia!    http://en.wikipedia.org/wiki/Simpson's_rule#Composite_Simpson.27s_rule"""        h = float(b-a)/N   # this is factored out of the loop just for efficiency    return h/3 * ( Noro_integrand(eps,r_cut,a) + 2*sum((k%2+1) * Noro_integrand(eps,r_cut,a + h*k) for k in range(1,N)) + Noro_integrand(eps,r_cut,b) )#sig_HS_001=[]#sig_HS_01=[]#sig_HS_1=[]#sig_HS_10=[]#sig_HS_100=[]#sig_HS_1000=[]#sig_n_HS_001=[]#sig_n_HS_01=[]#sig_n_HS_1=[]#sig_n_HS_10=[]#sig_n_HS_100=[]#sig_n_HS_1000=[]##sig_WCAs=np.linspace(0.01,10,150)#sig_WCAs=[0.01,10]#i=0#for sig in sig_WCAs:	#sig_HS_001.append((3.*B2_WCA(0.001,sig, 10**-20, sig, 10**5)/(2.*np.pi))**(1./3))	#sig_HS_01.append((3.*B2_WCA(0.01,sig, 10**-20, sig, 10**5)/(2.*np.pi))**(1./3))	#sig_HS_1.append((3.*B2_WCA(1,sig, 10**-20, sig, 10**5)/(2.*np.pi))**(1./3))	#sig_HS_10.append((3.*B2_WCA(10,sig, 10**-20, sig, 10**5)/(2.*np.pi))**(1./3))	#sig_HS_100.append((3.*B2_WCA(100,sig, 10**-20, sig, 10**5)/(2.*np.pi))**(1./3))	#sig_HS_1000.append((3.*B2_WCA(1000,sig, 10**-20, sig, 10**5)/(2.*np.pi))**(1./3))	#sig_n_HS_001.append(Noro_WCA(0.001,sig, 10**-20, sig, 10**5))	#sig_n_HS_01.append(Noro_WCA(0.01,sig, 10**-20, sig, 10**5))	#sig_n_HS_1.append(Noro_WCA(1,sig, 10**-20, sig, 10**5))	#sig_n_HS_10.append(Noro_WCA(10,sig, 10**-20, sig, 10**5))	#sig_n_HS_100.append(Noro_WCA(100,sig, 10**-20, sig, 10**5))	#sig_n_HS_1000.append(Noro_WCA(1000,sig, 10**-20, sig, 10**5))#fig=plt.figure()#ax1=fig.add_subplot(111)#ax1.plot(sig_WCAs,sig_HS_001,ls='-',color='red',label=r'$\epsilon_{WCA} = 0.001$')#ax1.plot(sig_WCAs,sig_HS_01,ls='-',color='orange',label=r'$\epsilon_{WCA} = 0.01$')#ax1.plot(sig_WCAs,sig_HS_1,ls='-',color='yellow',label=r'$\epsilon_{WCA} = 1$')#ax1.plot(sig_WCAs,sig_HS_10,ls='-',color='blue',label=r'$\epsilon_{WCA} = 10$')#ax1.plot(sig_WCAs,sig_HS_100,ls='-',color='indigo',label=r'$\epsilon_{WCA} = 100$')#ax1.plot(sig_WCAs,sig_HS_1000,ls='-',color='violet',label=r'$\epsilon_{WCA} = 1000$')#ax1.plot(sig_WCAs,sig_n_HS_001,ls='--',color='red')#,label=r'$\epsilon_{WCA} = 0.001$')#ax1.plot(sig_WCAs,sig_n_HS_01,ls='--',color='orange')#,label=r'$\epsilon_{WCA} = 0.01$')#ax1.plot(sig_WCAs,sig_n_HS_1,ls='--',color='yellow')#,label=r'$\epsilon_{WCA} = 1$')#ax1.plot(sig_WCAs,sig_n_HS_10,ls='--',color='blue')#,label=r'$\epsilon_{WCA} = 10$')#ax1.plot(sig_WCAs,sig_n_HS_100,ls='--',color='indigo')#,label=r'$\epsilon_{WCA} = 100$')#ax1.plot(sig_WCAs,sig_n_HS_1000,ls='--',color='violet')#,label=r'$\epsilon_{WCA} = 1000$')#ax1.set_xlabel(r'$\sigma_{WCA}$',size='x-large') #ax1.set_ylabel(r'$\sigma_{HS}$',size='x-large')#plt.xlim(xmin=0.0)#plt.xlim(xmax=10.)#plt.ylim(ymin=-0.)##plt.ylim(ymax=10.)  #plt.legend(loc=0)#plt.savefig('sigWCA_vs_sigHS.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #plt.close()  #WCA_pot=[]#HS_pot=[]#r_cut=1.#rs=np.linspace(0.01,5,1000)#for r in rs:#	WCA_pot.append(WCA(eps,r_cut,r))#	if r<r_cut:#		HS_pot.append(1000)#	else:#		HS_pot.append(0)#fig=plt.figure()#ax1=fig.add_subplot(111)#ax1.plot(rs,WCA_pot,ls='-',color='orange',label=r'$U_{WCA}$')#ax1.plot(rs,HS_pot,ls='--',color='blue',label=r'$U_{HS}$')#ax1.set_xlabel(r'$r/\sigma$',size='x-large') #ax1.set_ylabel(r'$U/k_{B}T$',size='x-large')#plt.xlim(xmin=0.0)#plt.xlim(xmax=5.)#plt.ylim(ymin=-0.5)#plt.ylim(ymax=5.)  #plt.legend(loc=0)#plt.savefig('U_WCA_vs_U_HS.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #plt.close()      def InitialPosition(n_total,Lx,Ly,Lz,lam_B,zeta,filename):    """Places ions in their equilibrium configuration according to the input parameters.     This is designed for 040510 models and similar ones (like 032410).          This is an integral part of LAMMPS_GC_inputfile_implicit() and mustn't be erased!Input:    n_total:	the total number of ions requires in the box    Lx,Ly,Lz:   the x,y, and z-length of the simulation box whose edges are +/- 0.5*x    lam_B:      Bjerrum length of system    zeta:       the applied zeta potential of the systemOutput:    none"""        import random    Lammps_text=file(filename,"a")      #These are all values that pertain to either ion type.    rho_bulk=n_total*0.5/(Lx*Ly*Lz) #This really isn't correct since the number of particles can only roughly be specified... - 12/07/10 14:25:33     lam_D_spec=(8.*np.pi*rho_bulk*lam_B)**(-0.5)    area=Lx*Ly       valency=1.    sigma_wall=1.    #    #Histogram Stuff    Numbins=100 #It might work with odd numbers, but always make it even.    bin=np.array([((-Lz/2.)+i*(Lz/float(Numbins))) for i in range(Numbins)]+[Lz*0.5]) #This assembles bins for the whole box,      bin=[x+sigma_wall for x in bin]      bin=bin[0:len(bin)/2+1] #But we only need bins from one wall to the MIDDLE of the box    z_wall=bin[0]    j=0    co_sum,counter_sum=0,0    for (zlo,zhi) in zip(bin[0:len(bin)-1],bin[1:len(bin)]):    	a = zlo - z_wall    	b = zhi - z_wall    		sign = 1 #counter ions	n_counter = round (area * simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000)) 	n_counter=int(n_counter)	sign = -1 #co ions	n_co = round (area * simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000)) 	n_co=int(n_co)    	    	co_sum=co_sum+2*n_co    	counter_sum=co_sum+2*n_counter    	    	#This is for two charged plates	rx=[]	ry=[]	for i in range(n_counter): #Create positions for i particles		x=random.uniform(-0.5*Lx,0.5*Lx)		y=random.uniform(-0.5*Ly,0.5*Ly)		z=random.uniform(zlo,zhi)		while x in rx: #This prevents two particles from being placed atop eachother.			x=random.uniform(-0.5*Lx,0.5*Lx)		while y in ry: #This prevents two particles from being placed atop eachother.			y=random.uniform(-0.5*Ly,0.5*Ly)		rx.append(x)		ry.append(y)			Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (2,x,y,z))		Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (1,x,y,-z))		j+=2			for i in range(n_co): #Create positions for i particles		x=random.uniform(-0.5*Lx,0.5*Lx)		y=random.uniform(-0.5*Ly,0.5*Ly)		z=random.uniform(zlo,zhi)		while x in rx: #This prevents two particles from being placed atop eachother.			x=random.uniform(-0.5*Lx,0.5*Lx)		while y in ry: #This prevents two particles from being placed atop eachother.			y=random.uniform(-0.5*Ly,0.5*Ly)		rx.append(x)		ry.append(y)			Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (1,x,y,z))		Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (2,x,y,-z))			j+=2    lam_D=(8.*np.pi*(j*0.5/(Lx*Ly*Lz))*lam_B)**(-0.5) #Phew, this was definately required...  - 12/07/10 14:27:28    Lammps_text.write("\n#(L_z,lam_D,lam_B,rho_i0,bulk,initialization_zeta,N_tot) = (%1.2f, %1.2f, %1.2f, %1.8f,%1.8f,%i)" % (Lz,lam_D,lam_B,j*0.5/(Lx*Ly*Lz),zeta,j))       Lammps_text.close()        return j    def LAMMPS_GC_inputfile_implicit(Bjerrum,lam_D_spec,sig_WCA,L_z,N_tot,zetas,opt_cut):    """This will create an appropriately names input file for use in LAMMPS for the implicit solvent model!    As written, it can be modified slightly to insert particles randomly (less useful) or an offset lattice    insertion to minimize particle overlap (more useful).	This function needs to be sophisticated before being used in the initilization	schemes of the automated MD system. The known required adjustments are:	1) Specify Sigma_electrode before inserting particles so that N_tot can be guarunteed to be larger than Sig*A*0.5	2) Determine insertion coordinated (off a lattice as done) before actually printing this to the in.file.		This is a guarunteed way to satisfy point (1) and prevent overlap.		And, if there isn't a sufficient number of lattice sites per the integration of GC, these can be pushed off into the bulk.	3) The ions must be inserted in the following format (in order that they can be deleted if need be): type 1 type 2, type 1 type 2. This should be easy.	4) The equilibration scheme will be different.	Unrelated:		For the python control loop, a detailed log of what is occuring must be written so that everything can be recreated if need be.        Input: (always dimensional!)    Bjerrum = Bjerrum length     lam_D_spec = set point screening length    sig_WCA = Weeks-Chandler-Andersen particle diameter    L_z = Total length of box (includes the walls)    N_tot = a set point for the total number of particles placed. This program should get close enough (+/- ~10%)    zetas = a vector of strings of the following form = ['0.000','5.000'] etc. Not sure how to handle >='10.000'...    opt_cut = the optimum cut off for real space Coulomb calcs. This is something that must be manually determined.    NoneOutput:    None"""    zeta_string=''    for z in zetas:    	zeta_string=zeta_string+z[0:4]+'_'    zeta_string=zeta_string[0:len(zeta_string)-1]        #print 'Two ion sizes'    #sig_WCA_2=3*sig_WCA #Make sure sig_WCA_2 is always larger than sig_WCA    #filename = 'in.LB_'+str(Bjerrum)+'_sigr_'+str(sig_WCA_2)+'_zeta_'+zeta_string        #print 'One ion size'    filename = 'in.LB_'+str(Bjerrum)+'_sig_'+str(sig_WCA)+'_zeta_'+zeta_string    input_file=file(filename,"w")    dielectric=Bjerrum**-1    A_xy=4.*np.pi*(lam_D_spec**2)*N_tot/(L_z*dielectric)    L_x=np.sqrt(A_xy)        L_y=L_x    total_steps=0    for ze in zetas:	    input_file.write("""###################################################              ILJ LD SS                        """)	    input_file.write('\n##\t\tzeta_'+ze+'\n')	    input_file.write("""#################################################clear# Initialize simulation boxdimension	3boundary	p p funits		ljatom_style	charge# Create geometry""")	    input_file.write('\nregion  \tsimbox block %1.4f %1.4f %1.4f %1.4f %1.4f %1.4f units box\ncreate_box\t2 simbox\n\n#Insert Particles' % (-0.5*L_x,0.5*L_x,-0.5*L_y,0.5*L_y,-0.5*L_z,0.5*L_z))	    input_file.close()	    if float(ze)>3.:	    	initialization_zeta=3.0#	    	initialization_zeta=float(ze) #This used to be initialization_zeta=1.	    else:	    	initialization_zeta=float(ze) #This used to be initialization_zeta=1.	    	    #Either comment out these next three lines	    #print 'Random insertion'	    #N_tot=InitialPosition(N_tot,L_x,L_y,L_z,Bjerrum,initialization_zeta,filename) #This function will return the actual amount of particles in the simulation	    #lam_D=(8.*np.pi*(N_tot*0.5/(L_x*L_y*L_z))*Bjerrum)**(-0.5) #This is the lam_D after a known number of simulation particles were placed	    #Or comment out these next two	    print 'Lattice insertion, one ion size'	    N_tot,lam_D=InitialPosition_lattice_implicit(N_tot,L_x,L_y,L_z,sig_WCA,Bjerrum,initialization_zeta,filename)	    	    #print 'Lattice insertion, two ion sizes'	    #N_tot,lam_D=InitialPosition_lattice_implicit(N_tot,L_x,L_y,L_z,sig_WCA_2,Bjerrum,initialization_zeta,filename)	                input_file=file(filename,"a")	    input_file.write("""# Create groupsgroup		A type 1group		C type 2group		ions type 1 2# Set masses   mass		1 1.0mass		2 1.0# Set chargesset		group A charge -1set		group C charge 1# Initilize velocitiesvelocity	all create 1.0 3# Miscneighbor	1 nsqneigh_modify	delay 0 every 1 check yes page 1000000 one 10000fix		thermostat all langevin 1.0 1.0 25 3fix		timeintegration all nve""")	    input_file.write('\n\ndielectric	%1.4f #=1/Bjerrum' % (dielectric))		    input_file.write('\n\nfix		anode all wall/lj93 zlo %1.4f 1. 1.165 1.0 units box' % (-0.5*L_z))	    input_file.write('\nfix		cathode all wall/lj93 zhi %1.4f 1. 1.165 1.0 units box' % (0.5*L_z))	 	    print 'This must be determined before the ion positions are printed so that Sigma * Area is less than 0.5 N_tot'	    F_z=-(2./lam_D)*np.sinh(float(ze)/2)	    print (F_z*dielectric)/(dielectric/lam_D_spec)#	    print 'YOU MUST CHECK IF N_TOT equals what lammps says it does. N_tot(python,zeta='+str(ze)+' = %1.4f' % N_tot#	    print 'ALso, the F_z doesnt look correct'	    input_file.write('\n\nfix		A_field A addforce 0.0 0.0 %1.5f # Sigma_s = %1.5f*dielectric' % (-F_z,-F_z))	    input_file.write('\nfix		C_field C addforce 0.0 0.0 %1.5f\n' % (F_z))		    input_file.write("""timestep 	0.001 thermo_style	custom step temp etotal pe ecoul evdwl press cputhermo		1000# Set potentials#This is only to prevent particles from overlapping each other.""")	    #Uncomment the following line to use the anti-overlap pair potential (good for sigma > 5)   	      #One ion size	    input_file.write('\npair_style	soft %1.4f\npair_coeff	* * 60.0 %1.4f\nrun		35000\n' % (sig_WCA*1.0,sig_WCA*1.0))   	      #Two ion sizes	    #input_file.write('\npair_style	soft %1.4f\npair_coeff	* * 60.0 %1.4f\nrun		15000\n' % (sig_WCA_2*1.5,sig_WCA_2*1.5))   	    	    input_file.write('\n\npair_style	lj/cut/coul/long %1.4f %1.3f #The last number in this line must be mannually optimized!' % (sig_WCA,opt_cut))	      #For ions of only one size	    input_file.write('\npair_coeff	* * 1. %1.5f' % (sig_WCA/2.**(1./6.)))	       #For simulations of asymmetrically sized ions:	    #input_file.write('\npair_coeff	1 * 1. %1.5f %1.5f' % (sig_WCA/2.**(1./6.),sig_WCA))	    #input_file.write('\npair_coeff	2 * 1. %1.5f %1.5f' % (sig_WCA_2/2.**(1./6.),sig_WCA_2))	    	    input_file.write("""kspace_style	pppm 1E-4kspace_modify	slab 3.0pair_modify     shift yes""")	    input_file.write('\n\n#dump	        DEBUG_zeta_'+ze+' all custom 1000 1000_DEBUG_zeta_'+ze+'.gz id type x y z xu yu zu vx vy vz fx fy fz')	    input_file.write('\n#run	\t50000\n#write_restart	DEBUG crash\n\nprint "_"\nprint "_"\nprint "Equilibration, zeta_'+ze+' "\nprint "_"\nprint "_"')	    input_file.write('\n#dump	        dump0_zeta_'+ze+' all custom 1000 1000_equil_zeta_'+ze+'.gz id type x y z xu yu zu vx vy vz fx fy fz')	    if float(ze)<1.:	    	equilibration=5000000	    else:	    	equilibration=5000000	    #input_file.write('\nrun  \t\t5000000\nwrite_restart   PM_zeta_'+ze+'_equil_*')	    input_file.write('\write_restart\t\tPM_zeta_'+ze+'_equil_*\nrun  \t\t%i' % equilibration)    	    input_file.write('\n#undump\t\tdump0_zeta_'+ze)   	    input_file.write('\n\nprint "_"\nprint "_"\nprint "Production, zeta_'+ze+' "\nprint "_"\nprint "_"')	    input_file.write('\ndump	        dump1_zeta_'+ze+' all custom 1000 1000_ss_zeta_'+ze+'.gz id type x y z xu yu zu vx vy vz fx fy fz')	    input_file.write('\nrun  \t\t50000000\nwrite_restart   PM_zeta_'+ze+'_prod_*')	    total_steps+=(equilibration+50000000)	    input_file.write('\nundump\t\tdump1_zeta_'+ze+'\ndump	        Movie_dump all atom 1000 dump_zeta_'+ze+'_Movie.all\nrun  \t\t500000')    input_file.write('\n#################################################')    input_file.write('\n\n# The total number of MD steps for this run file is %i' % total_steps)    input_file.close()        returndef InitialPosition_lattice_implicit(n_total,Lx,Ly,Lz,sig_WCA,lam_B,zeta,filename):    """Places ions in their equilibrium configuration according to the input parameters.     This is designed for 040510 models and similar ones (like 032410).          This is an integral part of LAMMPS_GC_inputfile() and mustn't be erased!Input:    n_total:	the total number of ions requires in the box    Lx,Ly,Lz:   the x,y, and z-length of the simulation box whose edges are +/- 0.5*x    lam_B:      Bjerrum length of system    zeta:       the applied zeta potential of the systemOutput:    none"""        import random    Lammps_text=file(filename,"a")      #These are all values that pertain to either ion type.    rho_bulk=n_total*0.5/(Lx*Ly*Lz) #This really isn't correct since the number of particles can only roughly be specified... - 12/07/10 14:25:33     lam_D_spec=(8.*np.pi*rho_bulk*lam_B)**(-0.5)    area=Lx*Ly       valency=1.    sigma_wall=1.        #So that particles are not places outside of Lx or Lz    Lx=Lx-sig_WCA/2    Ly=Ly-sig_WCA/2    #    #Histogram Stuff    Numbins=100 #It might work with odd numbers, but always make it even.    bin=np.array([((-Lz/2.)+i*(Lz/float(Numbins))) for i in range(Numbins)]+[Lz*0.5]) #This assembles bins for the whole box,      bin=[x+sigma_wall for x in bin]      bin=bin[0:len(bin)/2+1] #But we only need bins from one wall to the MIDDLE of the box    z_wall=bin[0]    j=0    k=-1 #Iterator to determine which bin we're looking at    N_middle=[]    #co_sum,counter_sum=0,0    for (zlo,zhi) in zip(bin[0:len(bin)-1],bin[1:len(bin)]):	k+=1    	a = zlo - z_wall    	b = zhi - z_wall    	    	#Not sure, but there may be overlap due to the middlemost bin...    		sign = 1 #counter ions	n_counter = round (area * simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000)) 	n_counter=int(n_counter)	sign = -1 #co ions	n_co = round (area * simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000)) 	n_co=int(n_co)#	print zeta,n_counter,n_co#	if k==10 or k==13 or k==16 or k==18 or k==20 or k == 14:#		print 'One time modification!!!'#		n_co+=3#		n_counter+=3		#	print 'Here, you can insert a loop like, if z>5*lamD, insert 2 or 3X more particles than GC demands'    	    	N_slice=n_co+n_counter    	    	if k>=(Numbins/2-4): #This means that we're looking at the 5 middlemost bins	  N_middle.append(N_slice)		if sig_WCA>=3.:		if k==0:			print 'this needs to be fixed!'		r_z=[zlo+sig_WCA*0.5,zhi-sig_WCA*0.5]		LatSpac_z=0.001	else:		NLat_z=int((zhi-zlo)/(sig_WCA*1.05))		r_z=np.linspace(zlo+sig_WCA*0.5,zhi-sig_WCA*0.5,NLat_z)		LatSpac_z=r_z[1]-r_z[0]	  	if r_z[0]<-250:	  r_z=r_z[1:]	if k==0: #This only needs to happen once		NLat=int(Lx/(sig_WCA*1.05)) #Make "X" in "(sig_WCA*X))" smaller to add more grid points		r=np.linspace(-0.5*Lx,0.5*Lx,NLat)		LatSpac=r[1]-r[0]		if LatSpac<sig_WCA or LatSpac_z<sig_WCA:	   if sig_WCA<2.0:	      print 'Warning: Lattice spacing is smaller than ion diameter - ions will overlap!'		positions=len(r_z)*len(r)**2	if positions < N_slice:	    print 'Not enough insertions per GC'	    print 'Need to offload these to the bulk somehow'	print k,positions,N_slice    	co_count=0	c_count=0	all_pos=range(positions)	co_insert=random.sample(all_pos,n_co)	c_insert=random.sample([x for x in set(all_pos).difference(set(co_insert))],n_counter)	if len(co_insert)!=n_co:		print 'Something is wrong with ion insertion - n_co!'	if len(c_insert)!=n_counter:		print 'Something is wrong with ion insertion - n_counter!'#	if k==0:#	  print NLat_z#	  print zlo,zhi#	  print "r_z"#	  print r_z#	  print 'r_xy'#	  print r#	  print "LatSpac"#	  print LatSpac#	  print 'n_co,n_counter'#	  print n_co,n_counter#	  print 'positions'#	  print positions#	  print 'N_slice'#	  print N_slice  #	print 'in the for loop below, it is important to place the particles types 1,2 then 1,2 then 1,2 and so forth.'#	print 'It might be useful to store all of the positions before printing them. Point is to check if enough particles are inserted in the first place'#	print 'this can be done as a check before they are printed?'	i=-1	for z in r_z:	    for x in r:		for y in r:		    i+=1		    if i in co_insert:		      l_type,r_type=1,2 #Type 1 is co to the LEFT wall		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (l_type,x+random.uniform(-0.1*LatSpac,0.1*LatSpac),y+random.uniform(-0.1*LatSpac,0.1*LatSpac),z+random.uniform(-0.1*LatSpac_z,0.1*LatSpac_z)))		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (r_type,x+random.uniform(-0.1*LatSpac,0.1*LatSpac),y+random.uniform(-0.1*LatSpac,0.1*LatSpac),-z+random.uniform(-0.1*LatSpac_z,0.1*LatSpac_z)))		      co_count+=1		      j+=2		      		    if i in c_insert:		      l_type,r_type=2,1 #Type 1 is counter to the RIGHT wall		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (l_type,x+random.uniform(-0.1*LatSpac,0.1*LatSpac),y+random.uniform(-0.1*LatSpac,0.1*LatSpac),z+random.uniform(-0.1*LatSpac_z,0.1*LatSpac_z)))		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (r_type,x+random.uniform(-0.1*LatSpac,0.1*LatSpac),y+random.uniform(-0.1*LatSpac,0.1*LatSpac),-z+random.uniform(-0.1*LatSpac_z,0.1*LatSpac_z)))		      c_count+=1      		      j+=2 	if c_count!=n_counter: 		print 'error in counter-ion insertion'	 		print c_count,n_counter 	if co_count!=n_co: 		print 'error in co-ion insertion'	 		print co_count,n_co 		    Lx=Lx+sig_WCA/2    Ly=Ly+sig_WCA/2#    print "N_middle"#    print N_middle#    print "zhi,zlo,(zhi-zlo)"#    print zhi,zlo,(zhi-zlo)#    print 'Ly,Lx'#    print Ly,Lx    rho_bulk=0.5*np.mean(N_middle)/((zhi-zlo)*Ly*Lx)    lam_D=(8.*np.pi*rho_bulk*lam_B)**(-0.5) #Phew, this was definately required...  - 12/07/10 14:27:28        sig_HS = Noro_WCA(1,sig_WCA, 10**-20, sig_WCA, 10**5)    print 'zeta,lam_D,lam_B,sig_HS,,N_tot,phi_bulk_HS'    print zeta,lam_D,lam_B,sig_HS,j,2*rho_bulk*(np.pi/6)*sig_HS**3        Lammps_text.write("\n#(L_z,lam_D,lam_B,sig_HS,rho_i0,bulk,phi_bulk_HS,initialization_zeta,N_tot) = (%1.2f, %1.2f, %1.2f, %1.2f, %1.3e, %1.3e, %1.3f,%i)" % (Lz,lam_D,lam_B,sig_HS,rho_bulk,2*rho_bulk*(np.pi/6)*sig_HS**3,zeta,j))       Lammps_text.close()        return j,lam_D#InitialPosition_lattice_implicit(1132*2,447.5052,447.5052,1002,1.0,100,0.0,'test.txt')def LAMMPS_GC_inputfile_explicit(Bjerrum,lam_D_spec,sig_WCA,L_z,N_tot,N_sol,zetas,opt_cut):    """This will create an appropriately names input file for use in LAMMPS for the explicit solvent model!        Input: (always dimensional!)    Bjerrum = Bjerrum length     lam_D_spec = set point screening length    sig_WCA = Weeks-Chandler-Andersen particle diameter    L_z = Total length of box (includes the walls)    N_tot = a set point for the total number of ions placed. This program should get close enough (+/- ~10%)    N_sol = a set point for total number of solvent particles    zetas = a vector of strings of the following form = ['0.000','5.000'] etc. Not sure how to handle >='10.000'...    opt_cut = the optimum cut off for real space Coulomb calcs. This is something that must be manually determined.    NoneOutput:    None"""    print 'Go to http://lammps.sandia.gov/doc/kspace_style.html and look at the pppm/cg, which is pppm for systems where most particles are uncharged'    zeta_string=''    for z in zetas:    	zeta_string=zeta_string+z[0:4]+'_'    zeta_string=zeta_string[0:len(zeta_string)-1]        	##Old code for implict model, may eventually be useful    #print 'Two ion sizes'    #sig_WCA_2=3*sig_WCA #Make sure sig_WCA_2 is always larger than sig_WCA    #filename = 'in.LB_'+str(Bjerrum)+'_sigr_'+str(sig_WCA_2)+'_zeta_'+zeta_string        #print 'One ion size'    filename = 'in.LB_'+str(Bjerrum)+'_sig_'+str(sig_WCA)+'_zeta_'+zeta_string    input_file=file(filename,"w")    dielectric=Bjerrum**-1    A_xy=4.*np.pi*(lam_D_spec**2)*N_tot/(L_z*dielectric)    L_x=np.sqrt(A_xy)        L_y=L_x    total_steps=0    print 'Only provide single element lists to this function!'    for ze in zetas:	    input_file.write("""###################################################              ELJ LD SS                        """)	    input_file.write('\n##\t\tzeta_'+ze+'\n')	    input_file.write("""#################################################clear# Initialize simulation boxdimension	3boundary	p p funits		ljatom_style	charge# Create geometry""")	    input_file.write('\nregion  \tsimbox block %1.4f %1.4f %1.4f %1.4f %1.4f %1.4f units box\ncreate_box\t3 simbox\n\n#Insert Particles' % (-0.5*L_x,0.5*L_x,-0.5*L_y,0.5*L_y,-0.5*L_z,0.5*L_z))	    input_file.close()	    if float(ze)<1.:	    	initialization_zeta=float(ze)	    else:	    	initialization_zeta=float(ze) #This used to be initialization_zeta=1.	    		    print 'Lattice insertion, one ion size'	    N_tot,lam_D=InitialPosition_lattice_explicit(N_tot,N_sol,L_x,L_y,L_z,sig_WCA,Bjerrum,initialization_zeta,filename)			##Old code for implict model, may eventually be useful	    #print 'Lattice insertion, two ion sizes'	    #N_tot,lam_D=InitialPosition_lattice_implicit(N_tot,L_x,L_y,L_z,sig_WCA_2,Bjerrum,initialization_zeta,filename)	                input_file=file(filename,"a")	    input_file.write("""# Create groupsgroup		A type 1group		C type 2group		S type 3group		ions type 1 2# Set masses   mass		1 1.0mass		2 1.0mass		3 1.0# Set chargesset		group A charge -1set		group C charge 1set		group S charge 0# Initilize velocitiesvelocity	all create 1.0 3# Miscneighbor	1 nsqneigh_modify	delay 0 every 1 check yes page 1000000 one 10000fix		thermostat all langevin 1.0 1.0 25 3fix		timeintegration all nve""")	    input_file.write('\n\ndielectric	%1.4f #=1/Bjerrum' % (dielectric))		    input_file.write('\n\nfix		anode all wall/lj93 zlo %1.4f 1. 1.165 1.0 units box' % (-0.5*L_z))	    input_file.write('\nfix		cathode all wall/lj93 zhi %1.4f 1. 1.165 1.0 units box' % (0.5*L_z))	 	    F_z=-(2./lam_D)*np.sinh(float(ze)/2)#	    print 'YOU MUST CHECK IF N_TOT equals what lammps says it does. N_tot(python,zeta='+str(ze)+' = %1.4f' % N_tot#	    print 'ALso, the F_z doesnt look correct'	    input_file.write('\n\nfix		A_field A addforce 0.0 0.0 %1.5f # Sigma_s = %1.5f*dielectric' % (-F_z,-F_z))	    input_file.write('\nfix		C_field C addforce 0.0 0.0 %1.5f\n' % (F_z))		    input_file.write("""timestep 	0.001 thermo_style	custom step temp etotal pe ecoul evdwl press cputhermo		1000# Set potentials#This is only to prevent particles from overlapping each other.""")	    #Uncomment the following line to use the anti-overlap pair potential (good for sigma > 5)   	      #One ion size	    input_file.write('\npair_style	soft %1.4f\npair_coeff	* * 60.0 %1.4f\nrun		15000\n' % (sig_WCA,sig_WCA))   	      #Two ion sizes, Old code for implict model, may eventually be useful	    #input_file.write('\npair_style	soft %1.4f\npair_coeff	* * 60.0 %1.4f\nrun		15000\n' % (sig_WCA_2*1.5,sig_WCA_2*1.5))   	    	    input_file.write('\n\npair_style	lj/cut/coul/long %1.4f %1.3f #The last number in this line must be mannually optimized!' % (sig_WCA,opt_cut))	      #For ions of only one size	    input_file.write('\npair_coeff	* * 1. %1.5f' % (sig_WCA/2.**(1./6.)))	    	    	       #For simulations of asymmetrically sized ions, Old code for implict model, may eventually be useful:	    #input_file.write('\npair_coeff	1 * 1. %1.5f %1.5f' % (sig_WCA/2.**(1./6.),sig_WCA))	    #input_file.write('\npair_coeff	2 * 1. %1.5f %1.5f' % (sig_WCA_2/2.**(1./6.),sig_WCA_2))	    	    	    input_file.write("""kspace_style	pppm 1E-4kspace_modify	slab 3.0pair_modify     shift yes""")	    input_file.write('\n\n#dump	        DEBUG_zeta_'+ze+' all custom 1000 1000_DEBUG_zeta_'+ze+'.gz id type x y z xu yu zu vx vy vz fx fy fz')	    input_file.write('\n#run	\t50000\n#write_restart	DEBUG crash\n\nprint "_"\nprint "_"\nprint "Equilibration, zeta_'+ze+' "\nprint "_"\nprint "_"')	    input_file.write('\n#dump	        dump0_zeta_'+ze+' all custom 1000 1000_equil_zeta_'+ze+'.gz id type x y z xu yu zu vx vy vz fx fy fz')	    if float(ze)<1.:	    	equilibration=5000000	    else:	    	equilibration=5000000	    input_file.write('\nrun  \t\t%i' % equilibration)	    input_file.write('\nwrite_restart   PM_zeta_'+ze+'_equil_*')    	    input_file.write('\n#undump\t\tdump0_zeta_'+ze)     	    	    input_file.write('\n\nprint "_"\nprint "_"\nprint "Production, zeta_'+ze+' "\nprint "_"\nprint "_"')	    c_rad=2*sig_WCA*1.05	    input_file.write('\ncompute \tcoordnum all coord/atom %1.3f' % c_rad) 	    input_file.write('\ndump	        cnum all custom 5000 5000_cnum_zeta_'+ze+'.txt type c_coordnum z')    	    input_file.write('\ndump	        dump1_zeta_'+ze+' ions custom 1000 1000_ss_zeta_'+ze+'.txt id type x y z xu yu zu vx vy vz fx fy fz')	    input_file.write('\ndump	        dump2_zeta_'+ze+' S custom 10000 10000_sol_zeta_'+ze+'.txt id type x y z xu yu zu vx vy vz fx fy fz')	    input_file.write('\nrestart  \t1000000 ExpSol_zeta_'+ze+'_prod_*')	    input_file.write('\nrun  \t\t50000000')	    total_steps+=(equilibration+50000000)	    	    restart_file=file(filename+'_restart',"w")	    restart_file.write("""clearread_restart 	ExpSol_zeta_0.000_prod_*fix		thermostat all langevin 1.0 1.0 25 3fix		timeintegration all nve""")	    restart_file.write('\n\ndielectric	%1.4f #=1/Bjerrum\n' % (dielectric))	    	    restart_file.write("""fix		anode all wall/lj93 zlo -51.0000 1. 1.165 1.0 units boxfix		cathode all wall/lj93 zhi 51.0000 1. 1.165 1.0 units box""")	    restart_file.write('\n\nfix		A_field A addforce 0.0 0.0 %1.5f # Sigma_s = %1.5f*dielectric' % (-F_z,-F_z))	    restart_file.write('\nfix		C_field C addforce 0.0 0.0 %1.5f\n' % (F_z))	    restart_file.write("""timestep 	0.001 thermo_style	custom step temp etotal pe ecoul evdwl press cputhermo		1000""")	    restart_file.write('\n\npair_style	lj/cut/coul/long %1.4f %1.3f #The last number in this line must be mannually optimized!' % (sig_WCA,opt_cut))	    restart_file.write('\npair_coeff	* * 1. %1.5f' % (sig_WCA/2.**(1./6.)))	    restart_file.write("""kspace_style	pppm 1E-4kspace_modify	slab 3.0pair_modify     shift yesprint "_"print "Simulation run, continued"print "_"""")	    restart_file.write('compute \tcoordnum all coord/atom %1.3f' % c_rad) 	    restart_file.write('\ndump	        cnum all custom 5000 5000_cnum_zeta_'+ze+'.txt type c_coordnum z')    	    restart_file.write('\ndump	        dump1_zeta_'+ze+' ions custom 1000 1000_ss_zeta_'+ze+'.txt id type x y z xu yu zu vx vy vz fx fy fz')	    restart_file.write('\ndump	        dump2_zeta_'+ze+' S custom 10000 10000_sol_zeta_'+ze+'.txt id type x y z xu yu zu vx vy vz fx fy fz')	    restart_file.write("""dump_modify	cnum append yesdump_modify	dump1_zeta_0.000 append yesdump_modify	dump2_zeta_0.000 append yes""")	    	    restart_file.write('\nrestart  \t1000000 ExpSol_zeta_'+ze+'_prod_*')	    restart_file.write('\nrun \t\t60025000 upto') 	        input_file.write('\n#################################################')    input_file.write('\n\n# The total number of MD steps for this run file is %i' % total_steps)    input_file.close()    restart_file.close()            returndef InitialPosition_lattice_explicit(n_total,n_sol,Lx,Ly,Lz,sig_WCA,lam_B,zeta,filename):    """Places ions in their equilibrium configuration according to the input parameters.     This is designed for 040510 models and similar ones (like 032410).          This is an integral part of LAMMPS_GC_inputfile() and mustn't be erased!Input:    n_total:	the total number of ions requires in the box    n_sol:	total number of explicit solvent particles    Lx,Ly,Lz:   the x,y, and z-length of the simulation box whose edges are +/- 0.5*x    lam_B:      Bjerrum length of system    zeta:       the applied zeta potential of the systemOutput:    none"""        import random    Lammps_text=file(filename,"a")      #These are all values that pertain to either ion type.    rho_bulk=n_total*0.5/(Lx*Ly*Lz) #This really isn't correct since the number of particles can only roughly be specified... - 12/07/10 14:25:33     lam_D_spec=(8.*np.pi*rho_bulk*lam_B)**(-0.5)    area=Lx*Ly       valency=1.    sigma_wall=1.        #So that particles are not placed outside of Lx or Lz    Lx=Lx-sig_WCA/2    Ly=Ly-sig_WCA/2    #    #Histogram Stuff    Numbins=50 #It might work with odd numbers, but always make it even.    n_sol=int(n_sol/Numbins)    bin=np.array([((-Lz/2.)+i*(Lz/float(Numbins))) for i in range(Numbins)]+[Lz*0.5]) #This assembles bins for the whole box,      bin=[x+sigma_wall for x in bin]      bin=bin[0:len(bin)/2+1] #But we only need bins from one wall to the MIDDLE of the box    z_wall=bin[0]    j=0    s=0    k=-1 #Iterator to determine which bin we're looking at    N_middle=[]    #co_sum,counter_sum=0,0    for (zlo,zhi) in zip(bin[0:len(bin)-1],bin[1:len(bin)]):	k+=1    	a = zlo - z_wall    	b = zhi - z_wall    	    	#Not sure, but there may be overlap due to the middlemost bin...    		sign = 1 #counter ions	n_counter = round (area * simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000)) 	n_counter=int(n_counter)	sign = -1 #co ions	n_co = round (area * simpson(lam_D_spec,zeta,rho_bulk,sign, a, b, N=1000)) 	n_co=int(n_co)    	    	N_slice=n_co+n_counter    	    	if k>=(Numbins/2-4): #This means that we're looking at the 5 middlemost bins	  N_middle.append(N_slice)		if sig_WCA>=2.0:		r_z=[zlo+sig_WCA*0.5,zhi-sig_WCA*0.5]		LatSpac_z=0.001	else:		NLat_z=int((zhi-zlo)/(sig_WCA*1.05))		r_z=np.linspace(zlo+sig_WCA*0.5,zhi-sig_WCA*0.5,NLat_z)		LatSpac_z=r_z[1]-r_z[0]	  		if r_z[0]<-100:	  r_z=r_z[1:]	if k==0: #This only needs to happen once		NLat=int(Lx/(sig_WCA*1.1)) #Make "X" in "(sig_WCA*X" smaller to add more grid points		r=np.linspace(-0.5*Lx,0.5*Lx,NLat)		LatSpac=r[1]-r[0]		if LatSpac<sig_WCA or LatSpac_z<sig_WCA:	   if sig_WCA<2.0:	      print 'Warning: Lattice spacing is smaller than particle diameter - particles will overlap!'		positions=len(r_z)*len(r)**2	if positions < N_slice:	    print 'Not enough insertions per GC'	    	co_count=0	c_count=0	s_count=0	all_pos=range(positions)#	print range(positions)	co_insert=random.sample(all_pos,n_co)#	print 'co_insert'#	print co_insert	c_insert=random.sample([x for x in set(all_pos).difference(set(co_insert))],n_counter)		if n_sol>(len(all_pos)-len(co_insert)-len(c_insert)): #If too many solvent particles are requested..	    print 'Solvent particles defaulted to maximum allowed value'	    n_sol = len(all_pos)-len(co_insert)-len(c_insert)	  	s_insert=random.sample([x for x in set(all_pos).difference(set(co_insert+c_insert))],n_sol)	#	print 'c_insert'#	print c_insert	if len(co_insert)!=n_co:		print 'Something is wrong with ion insertion - n_co!'	if len(c_insert)!=n_counter:		print 'Something is wrong with ion insertion - n_counter!'	if len(s_insert)!=n_sol:		print 'Something is wrong with solvent insertion - n_sol!'#	if k==0:#	  print NLat_z#	  print zlo,zhi#	  print "r_z"#	  print r_z#	  print 'r_xy'#	  print r#	  print "LatSpac"#	  print LatSpac#	  print 'n_co,n_counter'#	  print n_co,n_counter#	  print 'positions'#	  print positions#	  print 'N_slice'#	  print N_slice  	i=-1	random_adjust=0.02	for z in r_z:	    for x in r:		for y in r:		    i+=1		    		    if i in co_insert:		      l_type,r_type=1,2 #Type 1 is co to the LEFT wall		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (l_type,x+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),y+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),z+random.uniform(-random_adjust*LatSpac_z,random_adjust*LatSpac_z)))		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (r_type,x+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),y+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),-z+random.uniform(-random_adjust*LatSpac_z,random_adjust*LatSpac_z)))		      co_count+=1		      j+=2		      		    if i in c_insert:		      l_type,r_type=2,1 #Type 1 is counter to the RIGHT wall		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (l_type,x+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),y+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),z+random.uniform(-random_adjust*LatSpac_z,random_adjust*LatSpac_z)))		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (r_type,x+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),y+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),-z+random.uniform(-random_adjust*LatSpac_z,random_adjust*LatSpac_z)))		      c_count+=1      		      j+=2		    if i in s_insert:		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (3,x+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),y+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),z+random.uniform(-random_adjust*LatSpac_z,random_adjust*LatSpac_z)))		      Lammps_text.write("\ncreate_atoms	%i single %1.2f %1.2f %1.2f units box" % (3,x+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),y+random.uniform(-random_adjust*LatSpac,random_adjust*LatSpac),-z+random.uniform(-random_adjust*LatSpac_z,random_adjust*LatSpac_z)))		      s_count+=1      		      s+=2 	if c_count!=n_counter: 		print 'error in counter-ion insertion'	 		print c_count,n_counter 	if co_count!=n_co: 		print 'error in co-ion insertion'	 		print co_count,n_co 		    Lx=Lx+sig_WCA/2    Ly=Ly+sig_WCA/2    rho_bulk=0.5*np.mean(N_middle)/((zhi-zlo)*Ly*Lx)        lam_D=(8.*np.pi*rho_bulk*lam_B)**(-0.5) #Phew, this was definately required...  - 12/07/10 14:27:28    tot_vol_frac=((s+j)/(Lx*Ly*(Lz-2)))*(np.pi/6)*sig_WCA**3            print 'lam_D,N_tot,N_sol,tot_vol_frac,zeta'    print lam_D,j,s,tot_vol_frac,zeta    Lammps_text.write("\n#(L_z,lam_D,lam_B,rho_i0,bulk,initialization_zeta,N_ions,N_solvent) = (%1.2f, %1.2f, %1.2f, %1.8f,%1.8f,%i,%i)" % (Lz,lam_D,lam_B,rho_bulk,zeta,j,s))       Lammps_text.close()        return j,lam_Ddef LAMMPS_Validation():    """This validated newly updated LAMMPS code by doing SingleParticle(FILES), where FILES are all those output by in.Validate    Input:    NoneOutput:    None, pdfs of the histograms with theory curves are generated in the     directory that the script was run."""	    SingleParticle('100_sig_0.000.txt')    SingleParticle('100_sig_0.001.txt')    SingleParticle('100_sig_0.005.txt')    SingleParticle('100_sig_0.010.txt')    SingleParticle('100_sig_0.050.txt')    SingleParticle('100_sig_0.100.txt')    SingleParticle('100_sig_0.200.txt')    SingleParticle('100_sig_0.300.txt')    SingleParticle('100_sig_0.500.txt')    SingleParticle('100_sig_0.700.txt')    returndef SingleParticle(filename):    """This is used for data analysis on the single particle system used    to validate the code. It was developed specifically for 110409_CenC & 110509_SurC    Input:    filename: the name of the input fileOutput:    None, pdfs of the histograms with theory curves are generated in the     directory that the script was run."""       Data=[[float(x) for x in line.split()] for line in file(filename,"r").readlines() if not line.startswith("ITEM")]    print '\n'    print filename    print "Loaded data..."         #These are hard coded values that cannot be determined from Data[]        r_wall=1.0    r_ion=0.01    z_wall=r_wall-r_ion    area=abs(Data[2][0]-Data[2][1])*abs(Data[3][0]-Data[3][1]) #width times height of the box    L_box=22.    L=L_box    #Histogram Stuff - might need to add after sorting    Numbins=50        bin=[((-L_box/2.)+i*(L_box/float(Numbins))) for i in range(Numbins)] #Numbins + 1    mid_bin=[(x+y)/2. for (x,y) in zip(bin[0:len(bin)-1],bin[1:len(bin)])]    z_vals=bin[0:len(bin)-1] #coords of left edge of hist bins    L_bin=(bin[1]-bin[0])    graph_prefix=filename[0:len(filename)-4]    bin=np.array(bin)    mid_bin=np.array(mid_bin)      #Create empty vectors to fill    BA_Data,BA_z=[],[]    i,k=0,0    for x in Data:      if len(x)<=2:	i+=1	if i==6: #This means an entire timestep worth of data is had	  if k==0: #This indicates that the first timestep worth of data having been collected	    BA_qty=len(BA_z)	    k+=1	  BA_Data.append(sorted(BA_z))	  BA_z=[]	  	  i=1      elif x[1]==2:        BA_z.append(x[4])               print "Sorted data..."    #Theory Stuff    sigma=float("0." + filename[-7:-4])    L_theory=L_box-2.*r_wall #this might need to be changed    #Bin data into histograms    k=-1    hist,bin_edges=np.histogram(np.array(BA_Data[0]), bin, (min(bin),max(bin)))    bin_fix=bin_edges+L_bin/2.    MH_BA=[[x] for x in hist.tolist()]       for BA in BA_Data[1:]:              i=0        hist,bin_edges=np.histogram(np.array(BA), bin, (min(bin),max(bin)))        for x in hist.tolist():            MH_BA[i].append(x)            i+=1    BA_den=[np.mean(np.array(x)) for x in MH_BA]/abs(bin_fix[1]-bin_fix[0]) #Normalize this better? Divide by vol_bin#    print "The bin width is:    %1.4f" % abs(bin_fix[1]-bin_fix[0])#    print "Number of bins:    %i" % len(bin_fix)#    #    print "Bin length is %i and bin is:" % len(bin)#    print bin#    #    print "Bin_fix length is %i and bin is:" % len(bin_fix)#    print bin_fix#    #    print "BA_den length is %i and bin is:" % len(BA_den)#    print bin    L=L_theory    Po=4*np.pi*sigma/(np.sinh(8*sigma*(L/2.)*np.pi))    if sigma!=0:        prob=[Po*np.exp(-8*np.pi*sigma*z) for z in mid_bin]        plot_prob=[Po*np.exp(-8*np.pi*sigma*z) for z in np.arange(-L/2.,L/2.,0.001)]    else:        prob=[(1./L) for z in mid_bin]	plot_prob=[(1./L) for z in np.arange(-L/2.,L/2.,0.001)]    plt.errorbar(np.arange(-L/2.,L/2.,0.001),plot_prob,yerr=None,marker='None',c='k',label='Boltz Dist')            bin_fix=bin_fix[0:len(bin_fix)-1]    plt.errorbar(bin_fix,BA_den,yerr=None,marker='s',c='k',ls='None',mfc='blue',label='Simulation Data')      plt.ylabel(r'P(z)')    plt.xlabel(r'z Coordinates')    plt.title(r'$\~\Sigma$='+str(sigma))    plt.xticks(range(-11,12,1), tuple([str(x) for x in range(-11,12,1)]),rotation=90)    plt.ylim(ymin=0)        if sigma>=0.05:        plot_max=np.max(BA_den)+0.1    graph_name=graph_prefix+'_'+str(L)+".pdf"    plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)    plt.close()    log_BA_den=[]    lin_bin_fix=[]    log_error=[]    if sigma!=0:        for (x,y) in zip(bin_fix,BA_den):            if y!=0:                log_BA_den.append(y)                lin_bin_fix.append(x)	plt.semilogy(np.arange(-L/2.,L/2.,0.001),plot_prob,c='k',label='Boltz Dist')	plt.errorbar(lin_bin_fix,log_BA_den,yerr=None,marker='s',c='k',ls='None',mfc='blue',label='Simulation Data')                plt.title(r'$\~\Sigma$='+str(sigma))        plt.ylim(ymin=min(log_BA_den)/100.)        plt.xlim(xmax=max(lin_bin_fix)+1)        plt.xlim(xmin=-11.5)        plt.xticks(range(-11,12,1), tuple([str(x) for x in range(-11,12,1)]),rotation=90)        graph_name=graph_prefix+'_'+str(L)+"_log.pdf"        plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)        plt.close()    print "Generated density profiles..."        return    def badSSDiffusion(filename,lambda_D):    """***THIS FUNCTION IS MATHEMATICALLY CORRECT BUT WILL	CRASH ON A CLUSTER BECAUSE OF POOR MEMORY		MANAGEMENT.****    This function finds an the diffusion constant.    This code could easily be modified to find multiple diffusion constants in order to get an    error on the valueInput:    Data:     (N,3) array of atomic positions    lambda_D: Dimless Debye-LengthOutput:    None, only printed statements that are written to a .txt file from the command line"""    #This is a one-time deal function. It wasn't designed to be used for every data set, but could    # be modfied to allow for this kind of functionality    LAMMPS_dt=0.001 #This must be manually entered!    r_wall=1.0    print 'This function is working...'    if filename[-3:]=='.gz':        Data=[[float(x) for x in line.split()] for line in gzip.GzipFile(fileobj=open(filename,'rb')).readlines() if not line.startswith("ITEM")]	filename=filename[0:len(filename)-2]+'txt'    else:        Data=[[float(x) for x in line.split()] for line in file(filename,"r").readlines() if not line.startswith("ITEM")]        print '\n'    print filename    print "Loaded data..."            #"Data" for this function must be a system that is equilibrated 1MM+ runs or more    L=np.sum(abs(Data[4][0]-Data[4][1]))-2*r_wall    #This isn't correct, since the occupiable volume varies per ion, but this is relatively     #volume=abs(Data[2][0]-Data[2][1])*abs(Data[3][0]-Data[3][1])*L#-wall_qty*(4./3.)*np.pi*(r_wall)**3 #width times height of the box    #Need to hardwire in timestep difference, easy to do                      #Various iterators    i,j,k,l=0,0,0,0 #l can go    a,b,c,d=0,0,-1,-1 #not sure why these are here    #Create empty vectors to fill    BA_xyz,BA_0,MSD_BA=[],[],[]    BC_xyz,BC_0,MSD_BC=[],[],[]#    SA_xyz,SA_0,MSD_SA=[],[],[]#    SC_xyz,SC_0,MSD_SC=[],[],[]#    So_xyz,So_0,MSD_So=[],[],[]    #walls=[]        del_time=int(np.sum(Data[int(np.sum(Data[1]))+5])-np.sum(Data[0]))              for x in Data:      if len(x)!=14:	i+=1	#Sorting keeps atoms' XYZ data in order	BA_xyz=sorted(BA_xyz)	BC_xyz=sorted(BC_xyz)#	SA_xyz=sorted(SA_xyz)#	SC_xyz=sorted(SC_xyz)#	So_xyz=sorted(So_xyz)		if i==6: #This means an entire timestep worth of data is had	  if k==0: #This indicates that it's the first timestep worth of data having been collected, Pos0's need to be generated	    l+=1 #Not sure what this l's doing, 99.9% sure it can be deleted#	    BA_qty=len(BA_xyz)#	    BC_qty=len(BC_xyz)#	    SA_qty=len(SA_xyz)#	    SC_qty=len(SC_xyz)#	    So_qty=len(So_xyz)     	    BA_xyz0=copy.deepcopy(BA_xyz)	    BC_xyz0=copy.deepcopy(BC_xyz)#	    SA_xyz0=copy.deepcopy(SA_xyz)#	    SC_xyz0=copy.deepcopy(SC_xyz)#	    So_xyz0=copy.deepcopy(So_xyz)	    k+=1 #This stops XX_0 positions to be copied again	    #	  print np.mean([((xyz[1][0]-xyz0[1][0])**2+(xyz[1][1]-xyz0[1][1])**2+(xyz[1][2]-xyz0[1][2])**2) for (xyz,xyz0) in zip(BA_xyz,BA_xyz0)])	  MSD_BA.append(np.mean([((xyz[1][0]-xyz0[1][0])**2+(xyz[1][1]-xyz0[1][1])**2+(xyz[1][2]-xyz0[1][2])**2) for (xyz,xyz0) in zip(BA_xyz,BA_xyz0)]))	  MSD_BC.append(np.mean([((xyz[1][0]-xyz0[1][0])**2+(xyz[1][1]-xyz0[1][1])**2+(xyz[1][2]-xyz0[1][2])**2) for (xyz,xyz0) in zip(BC_xyz,BC_xyz0)]))#	  MSD_SA.append(np.mean([((xyz[1][0]-xyz0[1][0])**2+(xyz[1][1]-xyz0[1][1])**2+(xyz[1][2]-xyz0[1][2])**2) for (xyz,xyz0) in zip(SA_xyz,SA_xyz0)]))#	  MSD_SC.append(np.mean([((xyz[1][0]-xyz0[1][0])**2+(xyz[1][1]-xyz0[1][1])**2+(xyz[1][2]-xyz0[1][2])**2) for (xyz,xyz0) in zip(SC_xyz,SC_xyz0)]))#	  MSD_So.append(np.mean([((xyz[1][0]-xyz0[1][0])**2+(xyz[1][1]-xyz0[1][1])**2+(xyz[1][2]-xyz0[1][2])**2) for (xyz,xyz0) in zip(So_xyz,So_xyz0)]))	  BA_xyz=[]	  BC_xyz=[]#	  SA_xyz=[]#	  SC_xyz=[]#	  So_xyz=[]	  i=1      #XYZ data is stored for every timestep for each particle type      elif x[1]==1:  #this is only for the two type model	point=[x[0],x[5:8]]	BA_xyz.append(point)      elif x[1]==2: #this is only for the two type model	point=[x[0],x[5:8]]	BC_xyz.append(point)#      elif x[1]==5:#	point=[x[0],x[5:8]]#	SA_xyz.append(point)#      elif x[1]==6:#	point=[x[0],x[5:8]]#	SC_xyz.append(point)  #      elif x[1]==7:#	point=[x[0],x[5:8]]#	So_xyz.append(point)      #elif (x[1]==1 or x[1]==2) and l==0:	#walls.append(x[4])    print "L and L_D are:"    print L,lambda_D    print 'The average D_AB = %1.5f' % ((np.polyfit([del_time*x for x in range(len(MSD_BA))], MSD_BA, 1)[0]*(1./6.)+np.polyfit([del_time*x for x in range(len(MSD_BC))], MSD_BC, 1)[0]*(1./6.))*0.5)    tau_BA=int((lambda_D*L)/np.polyfit([del_time*x/LAMMPS_dt for x in range(len(MSD_BA))], MSD_BA, 1)[0]*(1./6.))    tau_BC=int((lambda_D*L)/np.polyfit([del_time*x/LAMMPS_dt for x in range(len(MSD_BC))], MSD_BC, 1)[0]*(1./6.))        Diff_output=file("OLDDiffusion_Results.txt","a")       Diff_output.write(filename)       Diff_output.write("\nThe diffusion constant for BA is %1.4f, which gives a tau_charge = (Lam_D * d / dt*D_AB) = %i timesteps.\n" % (np.polyfit([del_time*x for x in range(len(MSD_BA))], MSD_BA, 1)[0]*(1./6.),int((lambda_D*L)/np.polyfit([del_time*x/LAMMPS_dt for x in range(len(MSD_BA))], MSD_BA, 1)[0]*(1./6.))))    Diff_output.write("The diffusion constant for BC is %1.4f, which gives a tau_charge = (Lam_D * d / dt*D_AB) = %i timesteps.\n" % (np.polyfit([del_time*x for x in range(len(MSD_BC))], MSD_BC, 1)[0]*(1./6.),int((lambda_D*L)/np.polyfit([del_time*x/LAMMPS_dt for x in range(len(MSD_BC))], MSD_BC, 1)[0]*(1./6.))))    Diff_output.write("Averaged together this is: tau_charge = %i timesteps\n\nNow time, MSD data:\n" % (int(np.mean([tau_BA,tau_BC]))))	#Use this commented out text for plotting purposes    time_plot=[]    MSD_plot=[]#    print "MSD Data for BA"    for (t,MSD) in zip([del_time*x for x in range(len(MSD_BA))],MSD_BA):      Diff_output.write("\n%1.8f\t\t%1.8f" % (t,MSD))#      time_plot.append(t)#      MSD_plot.append(MSD)#    plt.plot(time_plot,MSD_plot)##    plt.show()#    plt.savefig('Diffusion_' +filename+ '.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)    Diff_output.close()    return#badSSDiffusion('1000_Dab_zeta_3.776.txt',15.)#badSSDiffusion('1000_tr_zeta_3.776.txt',15.)#badSSDiffusion('1000_Dab_zeta_0.000.gz',15.)#badSSDiffusion('1000_SD_zeta_0.500.gz',15)def TStat(filename):    """Plots temperature profiles and gives info on the average temp valueInput:    T_Data: Array of LAMMPS output in the format of: step temp etotal pe ecoul evdwl press cpuOutput:    None, plots are generated and waverage info is printed to the screen"""	#This code below gives T(timestep) for one filename. It's modified below to		#put T(timestep) data for multiple LAMMPS input files 12/09/09 12:53:53     T_Data=[[x for x in line.split()] for line in file(filename,"r").readlines()]    print '\n'    print filename    print "Loaded data..."#    #Initialize empty vectors to fill with data    step,temp=[],[]        GET_TEMP_DATA='True'        for x in T_Data:        if x ==['Step', 'Temp', 'TotEng', 'PotEng', 'E_coul', 'E_vdwl', 'Press', 'CPU']:            GET_TEMP_DATA=True#        elif x[0]=="Loop": #This signifies the end of a run#            GET_TEMP_DATA=False #So stop collecting data        elif GET_TEMP_DATA:            step.append(float(x[0]))            temp.append(float(x[1]))    plt.plot(step,temp,c='orange',label=r'$T_{simulation}$') #PLAY WITH SETTINGS LATER      plt.plot(step,np.ones(len(step)),c='blue',lw=2.0,label=r'$T_{setpoint}$')    plt.ylabel(r'T(timestep)')    plt.xlabel(r'timestep')        plt.title(r'(L,$\lambda_D$,$\lambda_B$,$\sigma_{ion}$) =(100,1,1,0.1)') # Fill this out everytime    plt.ylim(ymin=0.0)    plt.legend(loc=1)    plt.savefig(filename+'.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)    plt.show()    temp=[]    return tempdef EnergyPlot(filename):    """Plots temperature profiles and gives info on the average temp valueInput:    E_Data: Array of LAMMPS output in the format of: step temp etotal pe ecoul evdwl press cpuOutput:    None, plots are generated and waverage info is printed to the screen"""##	This code below gives TotalE(timestep) for one filename. It's modified below to##		put T(timestep) data for multiple LAMMPS input files 12/14/09 13:55:06     filename='THERMO_copy.txt'    E_Data=[[x for x in line.split()] for line in file(filename,"r").readlines()]#    E_Data=[]#    for x in E_Data1:#    	if type(x[0])!=type('a string'):#    	     print x[0],type(x[0])#    	     E_Data.append(float(x))#    E_Data=E_Data1    print '\n'    print filename    print "Loaded data..."    #Initialize empty vectors to fill with data    step,energy,temp=[],[],[]        n_average=1700    GET_TEMP_DATA=False#    print E_Data    for x in E_Data:	    step.append(float(x[0]))	    temp.append(float(x[1])) #Comment out if unneeded	    energy.append(float(x[2]))#        if x ==['Step', 'Temp', 'TotEng', 'PotEng', 'E_coul', 'E_vdwl', 'Press', 'CPU']:#            GET_TEMP_DATA=True#        elif x[0]=="Loop": #This signifies the end of a run#            GET_TEMP_DATA=False #So stop collecting data#        elif GET_TEMP_DATA:#            step.append(float(x[0]))#            temp.append(float(x[1])) #Comment out if unneeded#            energy.append(float(x[2]))    #    plt.plot(step,energy,c='orange',label=r'$E_{simulation}$') #PLAY WITH SETTINGS LATER #    plt.plot(step,temp,c='blue',label=r'$T_{simulation}$') #PLAY WITH SETTINGS LATER ##    plt.plot(step,np.ones(len(step)),c='black',lw=2.0,label=r'$T_{setpoint}$')#    plt.ylabel(r'E & T(timestep)')#    plt.xlabel(r'timestep')#    plt.xlim(xmin=2.4E6)#    plt.title(r'(PPPM,Langevin thermostat) = (On,Off)')#    plt.legend(loc=0)#    plt.savefig('ZoomIn.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)#    plt.show()    plt.plot(step,energy,c='orange',label=r'$E_{simulation}$') #PLAY WITH SETTINGS LATER     plt.plot(step,temp,c='blue',label=r'$T_{simulation}$') #PLAY WITH SETTINGS LATER     plt.plot(step,np.ones(len(step)),c='black',lw=2.0,label=r'$T_{setpoint}$')    plt.ylabel(r'E & T(timestep)')    plt.xlabel(r'timestep')    plt.ylim(ymin=0.0)    plt.legend(loc=0)    plt.savefig('ZoomOut.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)    plt.show()        energy=[]    return energy    def PBS_script(path,fileprefix,zetas,nodes,ppn):    """This generates pbs files to run with qsubInput:       path = is the ~/path to the directory that contains the input files for the qsub computer      fileprefix = the prefix for the filenames - for pbs and input files      zetas = zeta tags for run files      nodes = number of nodes to run code on      ppm = processers per node to run code onOutput: This generates pbs files to run with qsub"""    zetas.sort()    i=-1    for ze in zetas:      i+=1      filename=fileprefix+'_zeta_'+ze[0:-1]      print str(i)      print '_'+path      print '_'+ze[0:-1]#      PBS_file=file(str(i)+'_'+path+'_'+ze[0:-1],"w")      PBS_file=file(str(i),"w")      PBS_file.write("""#!/bin/bash#PBS -A bgiera""")      PBS_file.write("#PBS -l nodes=%i:ppn=%i,walltime=250:00:00" % (nodes,ppn))      PBS_file.write("\n#PBS -o c4hdn-la:/home/bgiera/%s" % (path))      PBS_file.write("\n#PBS -e c4hdn-la:/home/bgiera/%s" % (path))      PBS_file.write("""#PBS -W umask=0000# Set the max number of threads to use for programs using OpenMP. Should be <= ppn. Does nothing if the program doesn't use OpenMP.export OMP_NUM_THREADS=2export PATH=/usr/local/bin:/usr/bin:/bin# The following line changes to the directory that you submit your job from#cd $PBS_O_WORKDIR### You must set this to the directory the in.__ files are in""")      PBS_file.write("\ncd /home/bgiera/%s" % (path))      PBS_file.write("\nmpirun -np %i  /home/estella/gpulammps/src/lmp_mpi -log THERMO_%s.txt -in in.%s\nexit 0" % (nodes*ppn,filename,filename))    returndef residuals1(p, y, x,lam_B): 	err = y-peval1(x,p,lam_B) 	return errdef peval1(zetas, p,lam_B): 	"""This function is needed to fit Sigma_s vs. zeta for standard GC theory"""	return ((2.*np.pi*lam_B*p[0])**-1)*np.sinh(zetas/2.) #It would be nice to have the dielectric formalism here, but this is correct as writtendef residuals2(p, y, x, sigma, lam_B): 	err = y-peval2(x,p,sigma, lam_B) 	return errdef peval2(zetas, p,sigma,lam_B): 	"""This function is needed to fit Sigma_s vs. zeta for Bikerman theory	Note: This should technically have a signum function, thus we	reasonably assume this is OK since we'll always expect a positive zeta..."""	c0=1/(8*np.pi*lam_B*p[0]**2)#	v_Bik=c0*(np.pi/3)*sigma**3#	return 2.*c0*p[0]*np.sqrt((2./v_Bik)*np.log(1+2*v_Bik*np.sinh(zetas/2.)**2))	return 2.*c0*p[0]*np.sqrt((2./p[1])*np.log(1+2*p[1]*np.sinh(zetas/2.)**2))#	return 2.*(p[1]*3/(np.pi*sigma**3))*p[0]*np.sqrt((2./p[1])*np.log(1+2*p[1]*np.sinh(zetas/2.)**2))def GC_Cap_fit(zeta_measured,Sigma_s,LD0,v0,lam_B,sigma,if_plot):    """Input:    zeta_measured: measured zeta values from simulation    Sigma_s:	   the applied surface charge densities from which zeta_measured were obtained    LD0:	   initial guess for screening length we're fitting    v0:		   initial guess for 2*v_ion*n0    lam_B:	   the Bjerrum length    sigma:	   ion diameter    if_plot:	   Used to show quality of Sig_s vs zeta plotOutput:    xy data for a capacitance vs. voltage plot"""    p0 = np.array(LD0)    plsq = leastsq(residuals1, p0, args=(np.array(Sigma_s), np.array(zeta_measured), lam_B), maxfev=2000)    lam_D_GC=plsq[0]    if v0!='no':    	p0=np.array([LD0,v0])    	plsq = leastsq(residuals2, p0, args=(np.array(Sigma_s), np.array(zeta_measured), sigma, lam_B), maxfev=2000)    	lam_D_Bik=plsq[0][0]    	v_Bik=plsq[0][1]#	lam_D_Bik=plsq[0]#	v_Bik=(8*np.pi*lam_B*lam_D_Bik**2)*(np.pi/3)*sigma**3#	print lam_D_Bik,v_Bik    if if_plot=='yes':	zetas_GC=np.linspace(0,np.max(zeta_measured)+0.5)	dielectric=(4*np.pi*lam_B)**-1		Sigma_theory=[(2*dielectric/LD0)*np.sinh(zeta/2) for zeta in zetas_GC]	C_dif_GC=[(dielectric/LD0)*np.cosh(zeta/2.) for zeta in zetas_GC]	C_dif_sim=[(dielectric/lam_D_GC)*np.cosh(zeta/2.) for zeta in zetas_GC]    	graph_name='Sig_s_vs_zeta.pdf'        plt.plot(zeta_measured,Sigma_s,marker='s',mfc='orange',ms=5.,ls='None',color='orange',label=r'$Simulation$')        if v0!='no':            	Sigma_Bik_theory=[2.*(v_Bik*3/(np.pi*sigma**3))*lam_D_Bik*np.sqrt((2./v_Bik)*np.log(1+2*v_Bik*np.sinh(zeta/2.)**2)) for zeta in zetas_GC]        	plt.plot(zetas_GC,Sigma_Bik_theory,ls='--',lw=1.5,color='blue',label=r'$Bikerman$')	plt.plot(zetas_GC,Sigma_theory,ls='-',lw=1.5,color='blue',label=r'$Gouy-Chapman$')	#        plt.ylim(ymin=0)#	plt.ylim(ymax=0.15)	plt.xlim(xmax=np.max(zeta_measured)+0.75)		plt.xlim(xmin=np.min(zeta_measured))	plt.title(r'Surface Charge vs. Surface Potential')	plt.ylabel(r'$\Sigma_{s}$',size='x-large')	plt.xlabel(r'$\tilde \zeta$',size='x-large')	#graph_name='Zeta_vs_Sig_s.pdf'        #plt.plot(Sigma_s,zeta_measured,marker='s',mfc='orange',ms=5.,ls='None',color='orange',label=r'$Simulated$')	#plt.plot(Sigma_theory,zetas_GC,ls='-',lw=1.5,color='blue',label=r'$GC Theory$')		#plt.xlim(xmax=np.max(Sigma_s))		#plt.title(r'Surface Potential vs. Surface Charge')	#plt.xlabel(r'$\tilde \Sigma_{s}$',size='x-large')	#plt.ylabel(r'$\tilde \zeta$',size='x-large')		plt.grid(True)	plt.legend(loc=0)	plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   	plt.close()   	    	graph_name='Cap_vs_zeta_for_lamB_' + str(lam_B) + '.pdf'        plt.plot(zetas_GC,C_dif_sim,ls='--',lw=2.5,color='orange',label=r'$Simulated$')	plt.plot(zetas_GC,C_dif_GC,ls='-',lw=1.5,color='blue',label=r'$GC$' +' '+ '$Theory$')	        plt.ylim(ymin=0)	plt.ylim(ymax=0.4)	plt.xlim(xmax=np.max(zeta_measured)+0.75)	plt.grid(True)	plt.title(r'Capacitance vs. Surface Potential')	plt.ylabel(r'$Capacitance$',size='x-large')	plt.xlabel(r'$\tilde \zeta$',size='x-large')	plt.legend(loc=0)	plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   	plt.close()     returndef GC_Cap_fit_restore(zeta_measured,Sigma_s,LD0,lam_B,if_plot):    """Input:    zeta_measured: measured zeta values from simulation    Sigma_s:	   the applied surface charge densities from which zeta_measured were obtained    LD0:	   initial guess for screening length we're fitting    lam_B:	   the Bjerrum length    if_plot:	   Used to show quality of Sig_s vs zeta plotOutput:    xy data for a capacitance vs. voltage plot"""    p0 = np.array(LD0)    plsq = leastsq(residuals1, p0, args=(np.array(Sigma_s), np.array(zeta_measured), lam_B), maxfev=2000)#    print plsq[0]    if if_plot=='yes':	zetas_GC=np.linspace(0,np.max(zeta_measured)+0.5)	dielectric=(4*np.pi*lam_B)**-1		Sigma_theory=[(2*dielectric/LD0)*np.sinh(zeta/2) for zeta in zetas_GC]	C_dif_GC=[(dielectric/LD0)*np.cosh(zeta/2.) for zeta in zetas_GC]	C_dif_sim=[(dielectric/plsq[0])*np.cosh(zeta/2.) for zeta in zetas_GC]    	graph_name='Sig_s_vs_zeta.pdf'        plt.plot(zeta_measured,Sigma_s,marker='s',mfc='orange',ms=5.,ls='None',color='orange',label=r'$Simulated$')	plt.plot(zetas_GC,Sigma_theory,ls='-',lw=1.5,color='blue',label=r'$GC Theory$')	#        plt.ylim(ymin=0)#	plt.ylim(ymax=0.15)	plt.xlim(xmax=np.max(zeta_measured)+0.75)		plt.title(r'Surface Charge vs. Surface Potential')	plt.ylabel(r'$\tilde \Sigma_{s}$',size='x-large')	plt.xlabel(r'$\tilde \zeta$',size='x-large')	#graph_name='Zeta_vs_Sig_s.pdf'        #plt.plot(Sigma_s,zeta_measured,marker='s',mfc='orange',ms=5.,ls='None',color='orange',label=r'$Simulated$')	#plt.plot(Sigma_theory,zetas_GC,ls='-',lw=1.5,color='blue',label=r'$GC Theory$')		#plt.xlim(xmax=np.max(Sigma_s))		#plt.title(r'Surface Potential vs. Surface Charge')	#plt.xlabel(r'$\tilde \Sigma_{s}$',size='x-large')	#plt.ylabel(r'$\tilde \zeta$',size='x-large')		plt.grid(True)	plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   	plt.close()   	    	graph_name='Cap_vs_zeta_for_lamB_' + str(lam_B) + '.pdf'        plt.plot(zetas_GC,C_dif_sim,ls='--',lw=2.5,color='orange',label=r'$Simulated$')	plt.plot(zetas_GC,C_dif_GC,ls='-',lw=1.5,color='blue',label=r'$GC$' +' '+ '$Theory$')	        plt.ylim(ymin=0)	plt.ylim(ymax=0.4)	plt.xlim(xmax=np.max(zeta_measured)+0.75)	plt.grid(True)	plt.title(r'Capacitance vs. Surface Potential')	plt.ylabel(r'$Capacitance$',size='x-large')	plt.xlabel(r'$\tilde \zeta$',size='x-large')	plt.legend(loc=0)	plt.savefig(graph_name, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   	plt.close() 	#This was moved from below return in so that the function would collapse - 01-13-11 @ ~3p	#GC_Cap_fit([0.00767,0.24494,0.39247,0.88296,1.22084,1.8591],[0,0.00189,0.0038,0.00789,0.01009,0.01778],10.0,1.0,'no')    returndef floatRgb(mag, cmin, cmax):       """       Return a tuple of floats between 0 and 1 for the red, green and       blue amplitudes.       """       import math       try:              # normalize to [0,1]              x = float(mag-cmin)/float(cmax-cmin)       except:              # cmax = cmin              x = 0.5       blue = min((max((4*(0.75-x), 0.)), 1.))       red  = min((max((4*(x-0.25), 0.)), 1.))       green= min((max((4*math.fabs(x-0.5)-1., 0.)), 1.))       return (red, green, blue)def ROYGBIV_map(value,max_value,sat=1):    import colorsys    return colorsys.hsv_to_rgb(value / max_value / (1.1), sat, sat)def  Plot_Analysis(zetas):    """This generates superimposed plots of voltage(z), Electric field(z), n_+(Z), n_-(z), Cap(zeta_meas) all with Guoy-Chapman Theory.    	It also plots Shell CapacitanceInput:       zetas - An element in the list of zetas provides the names (keys) of Analyzed__ss_zeta_0.500_DATA.txt   Output: Plots as meantioned above.Notes: Would be nice to extende Bikerman theory, too."""    ##Why now do I need to include these? Ask Scott.    import numpy as np    import matplotlib.pyplot as plt    from matplotlib.colors import LinearSegmentedColormap        zetas=sorted(zetas)    Volts=[]    dipole_avgs=[]    dipole_avg_sqs=[]    Fields=[]    N_plusS=[]    N_minusS=[]    LDs=[]    n0s=[]    SIGMAS=[]    BJERRUMs=[]        muex_EVs=[]    muex_EV_tot=[]        Bikerman='n0'    z_wall=1.	#This is (reasonably) assumed to always be the case #    print 'Thoughts, what about looking at the force profile?\n That would give the mean force, which could be relevant for making new theory'    #This loop build all the necessary data to superimpose plots.     print 'Loading Data...'    i=0    for ze in zetas:    	#This all needs to be cleaned up, more or less.  - 12/14/10 10:52:33   	    	i+=1#    	filename='Analyzed_' + '_ss_zeta_' + ze + '_DATA.txt'    	filename='Analyzed_muexEV_10' + '_ss_zeta_' + ze + '_DATA.txt'#    	filename='Analyzed_error' + '_ss_zeta_' + ze + '_DATA.txt'		##This is special, for Uncharged particles - 08/31/11 13:22:07 #    	filename='Analyzed_muexEV_10' + '_ss_phis_' + ze + '_DATA.txt'    	z_50=np.array([[float(x) for x in line.split()] for line in file(filename,"r").readlines()])    	#Trim incoming data	z_positions=z_50[:,0]        SIGMAS.append(z_positions[-1])        L_z = z_positions[-2] - 2*z_wall#This includes the wall, but this number really doesn't matter...        	Psi_tot=z_50[:,1]	dipole_avgs.append(Psi_tot[-1])	Volts.append(Psi_tot[:-1].tolist())		E_tot=z_50[:,2]	dipole_avg_sqs.append(E_tot[-1])	Fields.append(E_tot[:-1].tolist())	N_plus=z_50[:,3]#	if i==1: #This reasonably assumes equal areas for all input files. Not sure what this is need for.#		#FOR NOW, it also assumes equal Bjerrum for all	area=N_plus[-2]#	print area,ze	Bjerrum=N_plus[-1]	dielectric=(4*np.pi*Bjerrum)**-1	eps_wall=1.0	N_plusS.append(N_plus[:-2])	N_minus=z_50[:,4]	lam_D=N_minus[-2]#        print 'lam_D = ',lam_D	LDs.append(N_minus[-2])	n0s.append((8.*np.pi*Bjerrum*lam_D**2)**-1)	if i==1: #For now, this reasonably assumes sig=2*r_ion for all input files.		sig=2.*N_minus[-1]		#This reasonably assumes epsilon_WCA = 1		sig_HS = Noro_WCA(1,sig, 10**-20, sig, 10**5)	N_minusS.append(N_minus[:-2])	muex_EV=z_50[:,5]	muex_EV_tot = muex_EV[-1]#	print muex_EV_tot	muex_EV = muex_EV[:-1]  #Perhaps need to subtract off the bulk value on this		N_tot = int(round(np.sum(N_minus[:-2])+np.sum(N_plus[:-2])))	Xi = z_positions[-1]*2.*np.pi*Bjerrum**2#	if i==1:#		print N_plus[:-2].tolist()+[lam_D,sig*0.5]#		print [lam_D,sig*0.5]#	print len(z_positions[:-1].tolist()+[z_positions[-1]])#	print len(Psi_tot[:-1].tolist()+[1e9])#	print len(E_tot[:-1].tolist()+[-1e9])#	print len(N_minus[:-2].tolist()+[area,Bjerrum])#	print len(N_plus[:-2].tolist()+[lam_D,sig*0.5])#	print len(muex_EV.tolist()+[muex_EV_tot])	newname = 'Analyzed_GC_'+str(N_tot)+'_'+str(Xi)+'_'+str(Bjerrum)+'_'+str(sig)+'_'+str(L_z)+'_'+str(round(np.sqrt(area),2))	print newname	ReFormat = file(newname+".txt","w")     	for (z,V,E,Np,Nm,muexEV) in zip(z_positions[:-1].tolist()+[z_positions[-1]],Psi_tot[:-1].tolist()+[1e9],E_tot[:-1].tolist()+[-1e9],N_minus[:-2].tolist()+[area,Bjerrum],N_plus[:-2].tolist()+[lam_D,sig*0.5],muex_EV.tolist()+[muex_EV_tot]):    		ReFormat.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV))#    		print z,V,E,Np,Nm,muexEV    	ReFormat.close()    #	    total_prefix='Analyzed_P1_' + filename[:len(filename)-4]#	    total_output=file(total_prefix+".txt","w")#	    for (z,V,E,Np,Nm,muexEV) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[z_min],E_tot.tolist()+[z_max],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion],muex_EV.tolist()+[muex_EV_total]):#	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV))   #	    total_output.close()    #    This function reasonably assumes all files have same z_positions and z_pos spacing    L_bin=z_positions[1]-z_positions[0]    z_positions=z_positions[:-1].tolist()    L_z=z_positions[-1]    z_density=[(x+y)/(L_z*2.) for (x,y) in zip(z_positions[0:len(z_positions)-1],z_positions[1:len(z_positions)])]##	    total_prefix='Analyzed_P1_' + filename[:len(filename)-4]##	    total_output=#    for     print "This is the starting format..."#	    total_prefix='Analyzed_muexEV_' + str(M_per_slice) + filename[4:len(filename)-4]#	    total_output=file(total_prefix+"_DATA.txt","w")#	    for (z,V,E,Np,Nm,muexEV) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion],muex_EV.tolist()+[muex_EV_total]):#	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV))   #	    total_output.close()      temperature = 1.0    valency = 1.0    for x in n0s:    	print 2*x*(np.pi/6)*sig**3        ##For all plots:    characteristic_length=sig#    characteristic_length=L_z    print 'Plotting Voltages & Assembling Theory...'    nonDim='yes'  #This is actually important for the RMS deviation calculation below    Bikerman='yes'    Bikerman='no'    CarnahanStarling='yes'    CarnahanStarling='no'        MPBoltz='yes'    MPBoltz='no'            if Bikerman=='yes':    	print '\t...with Bikerman theory...'    if CarnahanStarling=='yes':    	print '\t...with Carnahan-Starling theory...'    if MPBoltz=='yes':    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'    #This plots voltages, measures zeta, and prepares GC Field and GC density theorys    zeta_dataL,zeta_dataR=[],[]    E_theorys=[]    volt_theoryS=[]    P_Theory=[]    M_Theory=[]    rhof_Theory=[]       SIGMA_Theory=[]      colors=[]    i=-1    for ze in zetas:      i+=1      #colors.append(floatRgb(float(ze), float(zetas[0]), float(zetas[-1])))      colors.append(ROYGBIV_map(float(ze),float(zetas[-1])))    markers=['v','o','>','s','^','d','<','*','3','D','4','p','h','1','H','2']        i=-1    fig=plt.figure()    fig.subplots_adjust(right=0.85)    ax1=fig.add_subplot(111)    for (V,Sigma_s,lam_D,ze,n0) in zip(Volts,SIGMAS,LDs,zetas,n0s):    	i+=1	if ze=='1.500':		colors[i]='k'    	if i==len(colors): #This resets the colors    		i=0    	if i==0:	  z_positions=[z/L_z for z in z_positions] #NonDim distances	  n=5000*2	  if Bjerrum>10.:	  	n=5000*2	  z_den_theory=np.linspace(0.+z_wall/L_z,1.-z_wall/L_z,2*n) 	  graphname = 'Voltages' + '.pdf'		v_T_cat,v_T_ano=[],[]	zeta_measL=V[0]  #Shit on a stick, I think this is supposed to be V[0]...	zeta_measR=V[-1]	zeta_dataL.append(zeta_measL)	zeta_dataR.append(zeta_measR)	SIGMA_Theory.append(0.5*(np.sinh(zeta_measL/2)*(2*np.pi*lam_D*Bjerrum)**-1+np.sinh(zeta_measR/2)*(2*np.pi*lam_D*Bjerrum)**-1))	sign=1	E_theoryL,E_theoryR=[],[]		###########################	## To get E_field working, possibly try integrating the finalized voltage.	##  Or really shouldn't this simply be sinh(zeta/2) or other...?	###########################	for z in z_positions[:len(z_positions)/2]:    		v_T_cat.append(-np.log(GC_density(z,lam_D/L_z,zeta_measL,n0,sign)/n0))    		v_T_ano.append(-np.log(GC_density(z,lam_D/L_z,zeta_measR,n0,sign)/n0))    		E_theoryL.append((-4*np.exp(-z/(lam_D/L_z))*np.tanh(zeta_measL/4))/((lam_D/L_z)*(np.exp(2*z/(lam_D/L_z))-np.tanh(zeta_measL)**2)))    		E_theoryR.append((-4*np.exp(-z/(lam_D/L_z))*np.tanh(zeta_measR/4))/((lam_D/L_z)*(np.exp(2*z/(lam_D/L_z))-np.tanh(zeta_measR)**2)))	if len(z_positions) % 2: #If there are an even number of z_positions		v_T_cat.append(-np.log(GC_density(z_positions[len(z_positions)/2],lam_D/L_z,zeta_measL,n0,sign)/n0))		z=z_positions[len(z_positions)/2]		E_theoryL.append((-4*np.exp(-z/(lam_D/L_z))*np.tanh(zeta_measL/4))/((lam_D/L_z)*(np.exp(2*z/(lam_D/L_z))-np.tanh(zeta_measL)**2)))	v_T_ano.reverse()	volt_theory=v_T_cat+v_T_ano	volt_theory=-np.array(volt_theory)	E_theoryR.reverse()	E_theorys.append(E_theoryL+E_theoryR)	#print ze,Sigma_s	#print V[0:5]	#print volt_theory[0:5]	#print np.array(z_positions[0:5])*(L_z/characteristic_length)		rhoP=np.exp(-volt_theory)	rhoM=np.exp(volt_theory)    	P_Theory.append(rhoP)    	M_Theory.append(rhoM)	rhof_Theory.append([(-x+y) for (x,y) in zip(rhoM,rhoP)]) #I think I'm only plotting this from now on	#Finally plot the Voltage		#	muex_EC_p_bulk=np.mean(muex_EC_p[len(muex_EC_p)/2-2:len(muex_EC_p)/2+2])	ax1.errorbar(np.array(z_positions)*(L_z/characteristic_length),V,yerr=None,marker='+',ms=7.0,color=colors[i],ls='None')#,label=r'$\Sigma_{s}$'+' = ' + str(round(Sigma_s,3)))	if Bikerman=='yes':	   Bik_file='_Bik_zeta_' + ze + '.txt'	   x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]	   volt_Bik=[[float(x) for x in line.split()] for line in file('volt' + Bik_file,"r").readlines()]	   volt_Bik=np.array(volt_Bik[0])		##new code (this could fuck things up!) - 07/14/11 09:13:40 	   volt_Bik_bulk=np.mean(volt_Bik[len(volt_Bik)/2-2:len(volt_Bik)/2+2])	   ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),volt_Bik-volt_Bik_bulk,color=colors[i],lw=1.5,ls='--')	if CarnahanStarling=='yes':	   CS_file='_CS_zeta_' + ze + '.txt'	   x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]	   volt_CS=[[float(x) for x in line.split()] for line in file('volt' + CS_file,"r").readlines()]	   volt_CS=np.array(volt_CS[0])		##new code (this could fuck things up!) - 07/14/11 09:13:40 	   volt_CS_bulk=np.mean(volt_CS[len(volt_CS)/2-2:len(volt_CS)/2+2])	   ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),volt_CS-volt_CS_bulk,color=colors[i],lw=1.5,ls='-.')		##new code (this could fuck things up!) - 07/14/11 09:13:40 	if MPBoltz=='yes':	   MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'#	   if i==0: #This reasonably assumes the Bikerman plots all share the same x-axis#	      x_MPBoltz=[[float(x) for x in line.split()] for line in file('x_MPBoltz.txt',"r").readlines()]           x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      			   volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]	   volt_MPBoltz=np.array(volt_MPBoltz[0])	   volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])	   ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),volt_MPBoltz-volt_MPBoltz_bulk,color=colors[i],lw=2.0,ls=':')	volt_theory_bulk=np.mean(volt_theory[len(volt_theory)/2-2:len(volt_theory)/2+2])	volt_theoryS.append(volt_theory)	ax1.errorbar(np.array(z_positions)*(L_z/characteristic_length),volt_theory,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))    if characteristic_length==L_z:      ax1.set_xlabel(r'$z/L_{box}$',size='x-large')       plt.xlim(xmin=0.0)      plt.xlim(xmax=0.15)      plt.ylim(ymin=-0.25)    elif characteristic_length==sig:#      ax1.set_xlabel(r'$z/ \sigma_{WCA,-}$',size='x-large')      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')      plt.xlim(xmin=0.0)      plt.xlim(xmax=0.35*L_z/sig)      plt.xlim(xmax=15.)#      if np.mean(LDs)>30:#      	plt.xlim(xmax=0.45*L_z/sig)      	      plt.ylim(ymin=-0.25)    ax1.set_ylabel(r'$\~\psi$',size='x-large')    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    plt.show()    plt.close()    zeta_data=[(abs(zL)+abs(zR))/2. for (zL,zR) in zip(zeta_dataL,zeta_dataR)]  #Do NOT use np.mean for these...    z_den_theory=z_positions	#Done plotting voltages    #    ##This plots N_free(z) for simulation and GC theory#    print 'This plotting routine is a work in progress.'##    nonDim='no'#    nonDim='yes'###    Bikerman='yes'##    Bikerman='no'###    CarnahanStarling='yes'##    CarnahanStarling='no'##    MPBoltz='yes'##    MPBoltz='no' ##    if nonDim=='yes':##      print 'Plotting NonDim N_free(z) matching...'##    else:##      print 'Plotting Dim N_free(z) matching...'	##    if Bikerman=='yes':##		print '\t\t...with Bikerman theory...'##		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m##    if CarnahanStarling=='yes':##	      print '\t...with Carnahan-Starling theory...'##    if MPBoltz=='yes':##    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'#    graphname = 'Nf_compare.pdf'#    fig=plt.figure()#    fig.subplots_adjust(right=0.85)#    ax1=fig.add_subplot(111)#    Nf_max = [(npl-nm)/(area*L_bin) for (npl,nm) in zip(N_minusS[-1],N_plusS[-1])] #Check to see if this works#    i=-1#    for (Nm,Np,Sigma_s,n0) in zip(N_minusS[1:],N_plusS[1:],SIGMAS[1:],n0s[1:]):  #    	i+=1#	if i==len(markers): #This resets the colors#		i=0#			#    	index=-1#    	Sig_eff = Sigma_s*1.1#    	while Sig_eff > Sigma_s: #Thus, exit this loop if Sig_eff<= Sigma_s#    		index+=1#    		Sig_eff = SIGMAS[-1] - sum([L_bin*nf for nf in Nf_max[0:index]]) #There may be issues with negative signs#    		if index>=len(Nf_max)/2:#    			print 'fail',fail#	ax1.errorbar(np.array(z_density[index:])*(L_z/characteristic_length),[(npl-nm)/(area*L_bin*n0) for (npl,nm) in zip(Np[index:],Nm[index:])],yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='-',label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))#    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') #      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1)#      plt.ylim(ymin=-10.0)#      plt.ylim(ymax=0.25)#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$\~z=z/ \sigma_{WCA}$',size='x-large')#      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1*L_z/sig)#      plt.xlim(xmax=25.)##      if np.mean(LDs)>40:##      	plt.xlim(xmax=0.25*L_z/sig)   #      plt.ylim(ymax=1)##      plt.ylim(ymax=0.25)#    ax1.set_ylabel(r'$\~N_{free}$',size='x-large')#    ax1.legend(loc=0) #    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    #plt.show()#    plt.close()	   #      #    print 'Plotting MF Compare...'#    graphname = 'MF_Compare' + '.pdf'#    Bikerman='yes'#    Bikerman='no'#    if Bikerman=='yes':#    	print '\t...with Bikerman theory...'#    CarnahanStarling='yes'##    CarnahanStarling='no'#    if CarnahanStarling=='yes':#    	print '\t...with Carnahan-Starling theory...'#    fig=plt.figure()#    ax1=fig.add_subplot(111)#    x_data,y_data=[],[]#    i=-1#    for (LD,Sigma_s,ze) in zip(LDs,SIGMAS,zeta_data):#      i+=1#      if i==0:#	  q_ion=1. #This is reasonably assumed to be constant, but kept here just as a reminder in case things change.#      y_data.append(Sigma_s*LD/(2*dielectric))#      x_data.append(q_ion*np.sinh(ze/2.))#      if q_ion*np.sinh(ze/2.)<0:#	 print '\t\t***Consider forcing this to be positive via abs(XXX)***'#    LB_min,LB_max=0.5,10#    sig_min,sig_max=1,15#    x_theory=np.linspace(0,100,1000)#    ax1.errorbar(x_theory,x_theory,yerr=None,ls='-',color='k',label='Guoy-Chapman')#    couple_plot=[]#    ###	  #For (lam_B,sig) = (1,5) - Data added 5/26/11      ##    y_plot = [0.0,0.125286086707,0.25340278358,0.384359283548,0.522794765802,0.673155915353,0.828029327521,1.00208724217,1.19669652918,1.6497302685,1.93244132746,2.23671482572,2.69350292785,3.0096286524,4.03745807901,7.8084124279]##    x_plot = [0.00182250100891,0.112168893703,0.246742483955,0.393192692338,0.567454129226,0.723256564213,0.933998278585,1.16158311072,1.45241123934,2.17993256163,2.83562122368,3.62782929349,5.18227296081,6.57536467922,13.8500949684,156.88925321]##    LDs_temp = [10.01432,9.96995,10.00752,9.97923,9.98864,10.05029,10.02167,10.06228,10.13086,10.24835,10.38695,10.45168,10.62678,10.73263,11.07708,12.84228]##    ze_temp = [0.003645,0.22387,0.48861,0.767415,1.081435,1.34323,1.66785,1.98229,2.336145,3.04265,3.530285,4.000515,4.695145,5.16442,6.64548,11.497395]##    sig_temp,Bjerrum_temp=5.00000,1.00000    ##    color=ROYGBIV_map(sig_temp, sig_max)##    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]##    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.##    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]##    #couple_plot.append(cp)##    i=-1##    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):##	  i+=1##	  m='D'#########	  z_c=-np.log(sig_temp**3/(48*0.65*Bjerrum_temp*lam_D**2))##	  if i==0:##	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)##	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))##	  if ze<z_c:##		  m='x'##	  if xi>=1:##	  	m='^'##	  if i==0:##		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')##	  else:##		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')##    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=0.5,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')##    if Bikerman=='yes':##	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1##	    phi_bulk=(sig_HS_temp**3)*rho_bulk##	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]##	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]##	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)##    if CarnahanStarling=='yes':##	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(int(Bjerrum_temp)) + '_sig_' + str(int(sig_temp)) + '.txt'##	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]##	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=2.0,c=color)##    print '\t\tPlotted (lam_B,sig) = (1,5)'#	  #For (lam_B,sig) = (1,6)  - Data added 5/26/11#    y_plot = [0.0,0.125646490216,0.253866162213,0.384257601504,0.52263879578,0.669171349196,0.829029076551,1.0015584273,1.19156168395,1.36548074649,1.44663240128,1.64710315311,1.68037480021,1.82321654083,1.9146051821,1.88031762562,2.22442236177,2.75607419021]#    x_plot = [0.00342750671091,0.145741064544,0.273230278372,0.413886461621,0.5348149156,0.706942734837,0.933604919595,1.1486385529,1.49831827154,1.82623796666,2.08382095918,2.49837508779,2.5797457019,2.9509101257,3.29155662687,3.28200583275,4.50817693117,12.2625744073]#    LDs_temp = [10.01323,9.99863,10.02582,9.97659,9.98566,9.9908,10.03377,10.05697,10.08739,9.90985,9.87725,10.23203,9.89419,10.25712,10.29108,9.87337,10.39424,9.82843]#    ze_temp = [0.006855,0.29046,0.53988,0.805795,1.024265,1.31669,1.667275,1.965345,2.38766,2.726225,2.96101,3.293255,3.352895,3.605615,3.813645,3.808085,4.42224,6.402715]#    sig_temp,Bjerrum_temp=6.00000,1.00000#    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	  i+=1#	  m='D'#	  if i==0:#	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	  if ze<z_c:#		  m='x'#	  if xi>=1:#	  	m='^'#	  if i==0:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	  else:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(int(Bjerrum_temp)) + '_sig_' + str(int(sig_temp)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=2.0,c=color)#    print '\t\tPlotted (lam_B,sig) = (1,6)'#	  #For (lam_B,sig) = (1,7) - Data added 5/26/11#    y_plot = [0.0,0.1255523681,0.252669480563,0.384070799263,0.523216094218,0.670375627218,0.82683293364,0.99923004847,1.19143765387,1.24155621284,1.35931542808,1.40500554966,1.63266850625,1.66905193417,1.90527129858,1.98165135605,2.21006688681,2.7172048684]#    x_plot = [0.00385000951111,0.110209391888,0.243602153614,0.389275975192,0.537367841934,0.707062141589,0.922108518915,1.22706091743,1.58501602554,1.63854630481,1.93913563877,2.10862542332,2.80171332988,2.98844941114,4.01232511361,4.6353445661,5.83757809494,13.7667508145]#    LDs_temp = [9.9981,9.99114,9.97856,9.97174,9.99669,10.00878,10.00719,10.03359,10.08634,9.89979,10.12836,9.89003,10.14236,9.82752,10.24091,9.83748,10.32716,9.73782]#    ze_temp = [0.0077,0.219975,0.48251,0.76012,1.028765,1.316885,1.65042,2.066365,2.48203,2.538475,2.83216,2.98237,3.50761,3.629575,4.195395,4.47659,4.92944,6.63344]#    sig_temp,Bjerrum_temp=7.00000,1.00000#    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	  i+=1#	  m='D'#	  if i==0:#	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	  if ze<z_c:#		  m='x'#	  if xi>=1:#	  	m='^'#	  if i==0:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	  else:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(int(Bjerrum_temp)) + '_sig_' + str(int(sig_temp)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=2.0,c=color)#    print '\t\tPlotted (lam_B,sig) = (1,7)'##	  #For (lam_B,sig) = (1,8)#    y_plot = [0.0,0.12571987782,0.252088479444,0.383172823384,0.519516575443,0.660764143777,0.818192940604,1.0669274683,1.15864139321,1.35639210135,1.57524702111]#    x_plot = [0.0095401447091,0.11403572096,0.248931773981,0.347602171634,0.534891463932,0.690224771405,0.901777422893,1.3757657726,1.55783591389,2.13899538479,3.05325827645]#    LDs_temp = [10.03405,10.00447,9.98038,9.98099,9.9739,9.91177,9.94801,9.90127,9.86115,9.84389,9.8317]#    ze_temp = [0.01908,0.22758,0.49286,0.681915,1.0244,1.28928,1.620375,2.24763,2.452845,3.008245,3.67031]#    sig_temp,Bjerrum_temp=8.00000,1.00000#    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	  i+=1#	  m='D'#	  if i==0:#	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	  if ze<z_c:#		  m='x'#	  if xi>=1:#	  	m='^'#	  if i==0:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	  else:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(int(Bjerrum_temp)) + '_sig_' + str(int(sig_temp)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=2.0,c=color)#    print '\t\tPlotted (lam_B,sig) = (1,8)'#####These are r3_PHI_0.185#    y_plot = [0.0,0.124886582181,0.252552615829,0.383453651922,0.517547472418,0.658797619748,0.813864806732]#    x_plot = [0.0135129112064,0.114606917361,0.237333400958,0.362564767566,0.563307096055,0.737189800278,0.985277784643]#    LDs_temp = [16.13442,16.14648,16.1946,16.18365,16.09108,16.01266,16.033]#    ze_temp = [0.027025,0.228715,0.47032,0.710115,1.074215,1.365735,1.74185]#    sig_temp,Bjerrum_temp=5.40000,0.10000#    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	  i+=1#	  m='D'#	  if i==0:#	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	  if ze<z_c:#		  m='x'#	  if xi>=1:#	  	m='^'#	  if i==0:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	  else:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(round(Bjerrum_temp,1)) + '_sig_' + str(round(sig_temp,1)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=3.0,c=color)#    print '\t\tPlotted (lam_B,sig,lam_D) = (0.1,5.4,16.1), r3_Phi_0.185'#####These are r4_PHI_0.185#    y_plot = [0.0,0.125518056882,0.252215880765,0.382479415766,0.516530550688,0.653064378277,0.797350872896,0.951613826173,1.11501301915]#    x_plot = [0.0107302058972,0.112546253324,0.252620052414,0.407729629174,0.534769554776,0.742937373557,0.985302352029,1.30930633711,1.72851272626]#    LDs_temp = [38.56188,38.41696,38.33945,38.26115,38.05944,37.63158,37.2366,36.87705,36.43191]#    ze_temp = [0.02146,0.22462,0.500015,0.794405,1.024185,1.374975,1.741885,2.168225,2.630375]#    sig_temp,Bjerrum_temp=9.60000,0.10000#    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	  i+=1#	  m='D'#	  if i==0:#	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	  if ze<z_c:#		  m='x'#	  if xi>=1:#	  	m='^'#	  if i==0:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	  else:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(round(Bjerrum_temp,1)) + '_sig_' + str(round(sig_temp,1)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=3.0,c=color)#    print '\t\tPlotted (lam_B,sig,lam_D) = (0.1,9.6,~38.1), r4_Phi_0.185'#####These are r5_PHI_0.289#    y_plot = [0.0,0.126527993594,0.254285034532,0.382643072197,0.51591509899,0.649276306425,0.792489802765,0.930660244932,1.08324538189]#    x_plot = [0.00571753115071,0.119515210149,0.257431788096,0.396859110208,0.563654314208,0.750381684263,0.981308852027,1.33052308218,1.82305968649]#    LDs_temp = [60.55338,60.47314,60.40406,59.76402,59.41421,58.4477,57.83066,56.36194,55.31083]#    ze_temp = [0.011435,0.238465,0.50934,0.774235,1.07482,1.386905,1.73619,2.19385,2.72317]#    sig_temp,Bjerrum_temp=15.00000,0.10000#    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	  i+=1#	  m='D'#	  if i==0:#	  	sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	  z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	  if ze<z_c:#		  m='x'#	  if xi>=1:#	  	m='^'#	  if i==0:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	  else:#		  ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(round(Bjerrum_temp,1)) + '_sig_' + str(int(sig_temp)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=3.0,c=color)#    print '\t\tPlotted (lam_B,sig,lam_D) = (0.1,9.6,~38.1), r5_Phi_0.289'#    ###########Lambda_B is varied here out#	  ##For (lam_B,sig) = (0.5,1) - Data added 05/26/11#    #y_plot = [0.0,0.124968609605,0.255023000929,0.384311478561,0.520232794794,0.667427936804,0.821327709718,0.989798104537,1.17443066906,1.60440826838,1.86069985542,2.14063587584,2.78383035608,3.61005616343,6.0376643699]#    #x_plot = [0.00122500030638,0.133518561347,0.273162896336,0.414081276399,0.563614137569,0.731129662232,0.91152311763,1.09224460128,1.31831715588,1.85566743501,2.18775678233,2.53641206689,3.50570836889,4.86797817915,9.95309642617]#    #LDs_temp = [9.97754,9.96961,10.09656,10.01065,9.98163,10.01173,9.98994,9.9893,9.99286,10.01567,10.05226,10.0529,9.97659,9.95337,9.97948]#    #ze_temp = [0.00245,0.26625,0.53975,0.806155,1.07475,1.355965,1.634815,1.89024,2.17914,2.75432,3.049165,3.32134,3.934575,4.572425,5.98709]#    #sig_temp,Bjerrum_temp=1.00000,0.50000#    #color=ROYGBIV_map(Bjerrum_temp, LB_max,0.75)#    #Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    #Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    #cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    #i=-1#    #for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	    #i+=1#	    #m='D'#	    #if i==0:#		  #sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	    #z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	    #if ze<z_c:#		    #m='x'#	    #if xi>=1:#		  #m='^'#	    #if i==0:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	    #else:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    #ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    #print '\t\tPlotted (lam_B,sig) = (0.5,1)'#	    #For (lam_B,sig) = (1,1)  - Data added on 5/26/11#    y_plot = [0.0,0.125904603468,0.252422900725,0.384364073221,0.522270447183,0.661334126074,0.814248379487,0.987985824664,1.16591554365,1.59238268116,1.83990727596,2.1001501355,2.77167274626,3.60537335035,6.01155827845]#    x_plot = [0.0024875025653,0.148118822832,0.259996023536,0.418885549394,0.572072219606,0.720885266337,0.904489186966,1.11674642556,1.29741668462,1.84452649513,2.11250232411,2.45804306465,3.45534537107,4.7961950661,9.42191590108]#    LDs_temp = [9.98647,10.01917,9.99362,10.01202,10.02677,9.92032,9.90005,9.97101,9.92306,9.93865,9.93993,9.86277,9.93302,9.94132,9.93633]#    ze_temp = [0.004975,0.295165,0.514305,0.815025,1.08946,1.339385,1.6244,1.92313,2.15375,2.743725,2.98569,3.26307,3.90676,4.54333,5.87798]#    sig_temp,Bjerrum_temp=1.00000,1.00000   #    color=ROYGBIV_map(sig_temp, sig_max)#    Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    couple_plot.append(cp)#    i=-1#    for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	    i+=1#	    m='D'#	    if i==0:#		  sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	    z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	    if ze<z_c:#		    m='x'#	    if xi>=1:#		  m='^'#	    if i==0:#		    ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	    else:#		    ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    if Bikerman=='yes':#	    rho_bulk=(8.*np.pi*Bjerrum_temp*np.mean(LDs_temp)**2)**-1#	    phi_bulk=(sig_HS_temp**3)*rho_bulk#	    zeta_Bik_theory=[2*np.arcsinh(x) for x in x_theory]#	    y_BIK=[(2.*np.pi*Bjerrum_temp)*2.*rho_bulk*(np.mean(LDs_temp)**2)*np.sqrt((2./phi_bulk)*np.log(1.+2.*phi_bulk*np.sinh(zeta/2)**2)) for zeta in zeta_Bik_theory]#	    ax1.errorbar(x_theory,y_BIK,yerr=None,ls='--',lw=2.0,c=color)#    if CarnahanStarling=='yes':#	    MF_CS_Compare_filename='MF_Compare_CS_Bjerrum_' + str(int(Bjerrum_temp)) + '_sig_' + str(int(sig_temp)) + '.txt'#	    MF_CS=[[float(x) for x in line.split()] for line in file(MF_CS_Compare_filename,"r").readlines()]#	    ax1.errorbar([x[0] for x in MF_CS],np.array([x[1] for x in MF_CS])*(1/np.mean(LDs_temp)),yerr=None,ls='-.',lw=2.0,c=color)#    print '\t\tPlotted (lam_B,sig) = (1,1)'#  ##	For (lam_B,sig) = (3,1)   - Data added 5/26/11#    #y_plot = [0.0,0.126314757239,0.251337547065,0.382714032104,0.517302620959,0.667182863046,0.819157328495,0.991956606141,1.1757576646,1.38121639347,1.6021433582,1.85937266949,2.13084755906,2.4497197192,2.78014595968,3.57782528232,6.07387560964]#    #x_plot = [0.00215500166798,0.134419034891,0.297265094981,0.433639734727,0.580792522102,0.736205464425,0.915674651246,1.11977301468,1.32242896113,1.54986256736,1.83004605818,2.12658146634,2.4671662925,2.84954287578,3.32114224836,4.46168673911,8.34150856576]#    #LDs_temp = [10.00414,10.0018,9.95065,9.95275,9.94339,9.99863,9.96735,10.00474,10.01218,10.02405,9.99957,10.04509,10.00398,10.03565,9.96563,9.86536,10.03829]#    #ze_temp = [0.00431,0.268035,0.586105,0.84217,1.10457,1.36415,1.640945,1.927165,2.184105,2.444215,2.72988,2.997705,3.269935,3.539525,3.830775,4.402005,5.63593]#    #sig_temp,Bjerrum_temp=1.00000,3.00000   #    #color=ROYGBIV_map(Bjerrum_temp, LB_max,0.75)#    #Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    #Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    #cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    #i=-1#    #for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	    #i+=1#	    #m='D'#	    #if i==0:#		  #sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	    #z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	    #if ze<z_c:#		    #m='x'#	    #if xi>=1:#		  #m='^'#	    #if i==0:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	    #else:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    #ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    #print '\t\tPlotted (lam_B,sig) = (3,1)'#  ##	For (lam_B,sig) = (5,1)     - Data added 5/26/11 #    #y_plot = [0.0,0.125108677828,0.25111152204,0.381024819725,0.522200425481,0.669390415593,0.83226770986,1.0001348303,1.20511559537,1.65418790573,1.93440777911,2.26478077902,3.03970267339,4.10009772441,8.09898245671]#    #x_plot = [0.00408251134038,0.148022787042,0.280641623278,0.425267856973,0.586512374072,0.747217882124,0.942177088114,1.14100779508,1.33860701895,1.91797656148,2.24028452625,2.57450727704,3.54873119852,4.93333628603,10.018428664]#    #LDs_temp = [10.2393,10.21111,10.2476,10.19193,10.26059,10.29341,10.3484,10.33613,10.48088,10.57318,10.68995,10.88976,11.14709,11.57005,13.69812]#    #ze_temp = [0.008165,0.294975,0.554165,0.826785,1.11445,1.38184,1.67978,1.955305,2.203545,2.81268,3.09241,3.349105,3.958045,4.59856,6.00011]#    #sig_temp,Bjerrum_temp=1.00000,5.00000#    #color=ROYGBIV_map(Bjerrum_temp, LB_max,0.75)#    #Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    #Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    #cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    #i=-1#    #for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	    #i+=1#	    #m='D'#	    #if i==0:#		  #sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	    #z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	    #if ze<z_c:#		    #m='x'#	    #if xi>=1:#		  #m='^'#	    #if i==0:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	    #else:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    #ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    #print '\t\tPlotted (lam_B,sig) = (5,1)'#  ###	For (lam_B,sig) = (7,1)  - Data added 5/26/11#    #y_plot = [0.0,0.127547386249,0.250926728534,0.381774700299,0.519677212616,0.669755665323,0.823004384001,0.992683305531,1.17199042252,1.37623566032,1.61190295077,1.86024823954,2.14905564952,2.46846917455,2.8009644422,3.62128969295,6.06972660247]#    #x_plot = [0.0020650014676,0.159751807739,0.305819361945,0.457464858633,0.612199271971,0.795496181306,0.981522524977,1.19516241518,1.40713121094,1.63772582887,1.90194740881,2.17336326319,2.50085866677,2.91341700747,3.31703449322,4.32913450079,7.28536892723]#    #LDs_temp = [9.99357,9.9999,10.00908,9.97723,10.01322,10.01832,10.00651,10.03114,9.9801,9.99702,10.06838,10.04641,10.09542,10.11246,10.04478,9.98002,10.02935]#    #ze_temp = [0.00413,0.31816,0.602485,0.885695,1.158515,1.458295,1.736495,2.025745,2.28424,2.53762,2.79781,3.037165,3.2951,3.58141,3.828405,4.34319,5.367385]#    #sig_temp,Bjerrum_temp=1.00000,7.00000#    #color=ROYGBIV_map(Bjerrum_temp, LB_max,0.75)#    #Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    #Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    #cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    #i=-1#    #for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	    #i+=1#	    #m='D'#	    #if i==0:#		  #sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	    #z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	    #if ze<z_c:#		    #m='x'#	    #if xi>=1:#		  #m='^'#	    #if i==0:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	    #else:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    #ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    #print '\t\tPlotted (lam_B,sig) = (7,1) - Consider abs(x_axis)'#  ##	For (lam_B,sig) = (10,1)  - Data added 5/26/11#    #y_plot = [0.0,0.126413918469,0.250087111508,0.383847298822,0.523710344025,0.663558039407,0.825862058988,0.995746326952,1.17417430693,1.39069968988,1.61525265886,1.87178591009,2.15369819712,2.49929086884,2.82786994395,3.63504148072,6.19686228929]#    #x_plot = [0.0105526958471,0.186026563381,0.383187034632,0.598872109488,0.800114291212,1.04258867286,1.24216235683,1.49119206096,1.78565416757,2.10610622292,2.4562258758,2.7325648374,3.20063341762,3.67855386187,4.11990127941,5.36098673088,8.82377464292]#    #LDs_temp = [9.93832,10.0597,9.95065,10.01495,10.0423,9.96307,10.03359,10.03025,9.99335,10.1067,10.08139,10.09844,10.11126,10.25192,10.1367,10.0266,10.24155]#    #ze_temp = [0.021105,0.36994,0.74876,1.135715,1.465515,1.82234,2.085375,2.379735,2.686905,2.98021,3.2617,3.460605,3.760105,4.0273,4.24678,4.761765,5.747585]#    #sig_temp,Bjerrum_temp=1.00000,10.00000    #    #color=ROYGBIV_map(Bjerrum_temp, LB_max,0.75)#    #Sig_s=[x/(2.*np.pi*l*Bjerrum_temp) for (x,l) in zip(x_plot,LDs_temp)]#    #Xi=[2.*np.pi*(Bjerrum_temp**2)*Sig for Sig in Sig_s] #This assumes valency is always 1.#    #cp=[Sig_s,Xi,[sig_temp,Bjerrum_temp,color]]#    #couple_plot.append(cp)#    #i=-1#    #for (x,y,ze,lam_D,xi) in zip (x_plot,y_plot,ze_temp,LDs_temp,Xi):#	    #i+=1#	    #m='D'#	    #if i==0:#		  #sig_HS_temp = Noro_WCA(1,sig_temp, 10**-20, sig_temp, 10**5)#	    #z_c=-np.log(sig_HS_temp**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	    #if ze<z_c:#		    #m='x'#	    #if xi>=1:#		  #m='^'#	    #if i==0:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,ls='None')#,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#	    #else:#		    #ax1.errorbar(x,y,yerr=None,marker=m,ms=5.0,markerfacecolor=color,markeredgecolor=color,ls='None')#    #ax1.errorbar(x_plot,y_plot,yerr=None,ls=':',lw=1.0,c=color,label=r'$(\lambda_B,\sigma)=$'+'('+str(Bjerrum_temp)+','+str(sig_temp)+')')#    #print '\t\tPlotted (lam_B,sig) = (10,1)'#####      Uncomment below to obtain data to superimpose an additional plot#    x_string,y_string,LDs_string,ze_string='[','[','[','['#    for (x,y,lam_D,ze) in zip(x_data,y_data,LDs,zeta_data):#	  x_string+=str(x)+','#	  y_string+=str(y)+','#	  LDs_string+=str(lam_D)+','#	  ze_string+=str(ze)+','#    x_string=x_string[0:-1]+']'#    y_string=y_string[0:-1]+']'#    LDs_string=LDs_string[0:-1]+']'#    ze_string=ze_string[0:-1]+']'#    print '\ny_plot = %s' % y_string#    print 'x_plot = %s' % x_string#    print 'LDs_temp = %s' % LDs_string#    print 'ze_temp = %s' % ze_string#    print 'sig_temp,Bjerrum_temp=%1.5f,%1.5f\n' % (sig,Bjerrum)#    if graphname[-10:-4]=='loglog':#      ax1.set_xscale("log", nonposx='clip')#      ax1.set_yscale("log", nonposy='clip')#      ax1.set_ylabel(r'$\log[2 \pi \Sigma \lambda_D \lambda_B= \Xi(\lambda_D/\lambda_B)]$',size='x-large')#      ax1.set_xlabel(r'$\log[q \sinh( \tilde \zeta /2)]$',size='x-large')#      plt.suptitle('All data on a log log plot')#    else:#      ax1.set_ylabel(r'$2 \pi \Sigma \lambda_D \lambda_B = \Xi(\lambda_D/\lambda_B)$',size='x-large')#      ax1.set_xlabel(r'$q \sinh( \tilde \zeta /2 )$',size='x-large')##      plt.title('All Data')##      plt.title('Data for varied Bjerrum lengths')      #    plt.xlim(xmin=-0.001)#    plt.xlim(xmax=2.)#    plt.ylim(ymin=0)#    plt.ylim(ymax=2.0)  #    ax1.legend(loc=0) #    #plt.show()#    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    plt.close()    ##   ##Finished plotting GC Check    ##This requires     #print 'Plotting coupling parameter...'    ##This Netz's coupling parameter Xi = 2*np.pi*lam_B**2*Sig_s vs. Sig_s, assuming valency is always 1.    #i=-1    #fig=plt.figure()    #fig.subplots_adjust(right=0.85)    #ax1=fig.add_subplot(111)    #graphname = 'Xi_vs_Sig' + '.pdf'    #for c_p in couple_plot:	    #i+=1	    #ax1.errorbar(c_p[0],c_p[1],yerr=None,ls='-',lw=1.5,c=c_p[2][2],label=r'$\lambda_B=$'+str(c_p[2][1]))	    #if i==0:		#first_cp=cp  ##    	ax1.errorbar(c_p[0],c_p[1],yerr=None,ls='-',lw=2.0,c=c_p[2][2],label=r'$(\lambda_B,\sigma)=$'+'('+str(c_p[2][1])+','+str(c_p[2][0])+')')    #ax1.errorbar(first_cp[0],np.ones(len(first_cp[0])),yerr=None,ls='--',lw=1.0,c='k')    #ax1.set_ylabel(r'$\Xi = 2 \pi q^{3} \lambda_{B}^{2} \Sigma = \lambda_B / \mu_{Guoy}$',size='x-large')    #ax1.set_xlabel(r'$\Sigma$',size='x-large')    ##plt.xlim(xmin=0.0)    #plt.xlim(xmax=np.max(first_cp[0]))    ##plt.ylim(ymin=np.min(y_data))  ##    plt.ylim(ymax=1.5)      #ax1.legend(loc=0)     ##plt.show()    #plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)       #plt.close()         ##Finished plotting coupling parameter#    print 'Plotting electric fields...'#    #This plots electric Field for simulation and GC theory#    i=-1#    fig=plt.figure()#    fig.subplots_adjust(right=0.85)#    ax1=fig.add_subplot(111)#    for (E,E_T,Sigma_s) in zip(Fields,E_theorys,SIGMAS):#    	i+=1#    	if i==len(colors): #This resets the colors#    		i=0#    	if i==0:#	  graphname = 'Fields_inprogress' + '.pdf'#	  print '\tFields still a work in progress'#	ax1.errorbar(z_positions,E,yerr=None,marker='+',ms=5.0,color=colors[i],ls='None')#	#ax1.errorbar(z_positions,E_T,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))    #if characteristic_length==L_z:      #ax1.set_xlabel(r'$z/L_{box}$',size='x-large')     #elif characteristic_length==sigma:      #ax1.set_xlabel(r'$z/\simga_{WCA}$',size='x-large')#    ax1.set_ylabel(r'$E_{field}$',size='x-large')##    plt.title('TITLE')#    plt.xlim(xmin=0.0)#    plt.xlim(xmax=1.0)#    #plt.ylim(ymin=-0.05)##    plt.ylim(ymax=2.)  #    #ax1.legend(loc=0) #    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   ##    plt.show()#    plt.close()	##Finished plotting E-field		##Erase this at some point - 08/31/11 15:34:21     mean_PHI = [0.025,0.048,0.107,0.133]      ###    This plots N+(z) for simulation and GC theory    nonDim='no'    nonDim='yes'    #phi='yes'    phi='no'    Bikerman='yes'    Bikerman='no'    CarnahanStarling='yes'    CarnahanStarling='no'    MPBoltz='yes'    MPBoltz='no'     if nonDim=='yes' and phi=='yes':      print 'Plotting NonDim N_+(z) with volume fractions...'    elif nonDim=='yes' and phi!='yes':      print 'Plotting NonDim N_+(z)...'    elif nonDim!='yes' and phi!='yes':      print 'Plotting Dim N_+(z)...'	    else:      print 'Plotting Dim N_+(z) with volume fractions...'	    if Bikerman=='yes':      print '\t\t...with Bikerman theory...'    if CarnahanStarling=='yes':	    print '\t...with Carnahan-Starling theory...'    if MPBoltz=='yes':    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'    i=-1    fig=plt.figure()    fig.subplots_adjust(right=0.85)    ax1=fig.add_subplot(111)    for (Np,P_T,n0,Sigma_s,ze,lam_D) in zip(N_plusS,P_Theory,n0s,SIGMAS,zetas,LDs):	      i+=1	      if i==len(markers): #This resets the colors		      i=0	      if nonDim=='yes':		      Np=[npl/(area*L_bin*n0) for npl in Np]		      graphname = 'N_plus_NDim' + '.pdf'		      ylabel=r'$\~N_{+}$'	      else: #This is dimensional		      Np=[npl/(area*L_bin) for npl in Np]		      P_T=[n0*t for t in P_T]		      graphname = 'N_plus_Dim' + '.pdf'		      ylabel=r'$\~N_{+}$'			##Comment out to restore debugging code for Phi plots - 09/14/11 14:43:08 #    	      label1=r'$\bar \Phi$'+' = ' + str(mean_PHI[i])#	      ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Np,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None',label=label1)    	      #Restore the original code with the commented out lines below	      ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Np,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None')	      ax1.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),P_T,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))	      	      if Bikerman=='yes':		Bik_file='_Bik_zeta_' + ze + '.txt'		x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]		co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]		ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),co_Bik[0],color=colors[i],lw=1.5,ls='--')	      if CarnahanStarling=='yes':		CS_file='_CS_zeta_' + ze + '.txt'	        x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]		co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]		ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),co_CS[0],color=colors[i],lw=1.5,ls='-.')		      if MPBoltz=='yes':		MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'                x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      				volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]		volt_MPBoltz=np.array(volt_MPBoltz[0])		volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])		if nonDim=='yes':		   	ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),np.exp(-volt_MPBoltz+volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')		elif nonDim=='no':		   	ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),n0*np.exp(-volt_MPBoltz+volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')		    locs3=[] # A stupid name, but actually the words that print out on the right y-axis    if phi=='yes':	      locs1,labels=plt.yticks()	      for y in [x*(4.*np.pi/3.)*(sig*0.5)**3 for x in locs1]:		      s='%1.1E' % y		      locs3.append(s)  	      locs3.reverse()	      ax2=ax1.twinx()  		      locs,labels=plt.yticks()  #These are the location of the new axis	      ax2.grid(True)	      plt.ylim(ymin=0)	      locs = [(x-min(locs1))/(max(locs1)-min(locs1)) for x in locs1] #What a pain in my ass to figure this shit out...	      locs.reverse()	      plt.yticks(locs, locs3,rotation=15)	      ax2.set_ylabel(r'$\Phi_{\sigma}$',size='x-large')     if characteristic_length==L_z:      ax1.set_xlabel(r'$z/L_{box}$',size='x-large')       plt.xlim(xmin=0.0)      plt.xlim(xmax=0.2)      plt.ylim(ymin=-0.05)      plt.ylim(ymax=1.10)    elif characteristic_length==sig:      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')      plt.xlim(xmin=0.0)      plt.xlim(xmax=15)#      plt.xlim(xmax=0.25*L_z/sig)#      if np.mean(LDs)>40:#      	plt.xlim(xmax=0.55*L_z/sig)         plt.ylim(ymax=1.5)       plt.ylim(ymin=-0.05)    ax1.set_ylabel(ylabel,size='x-large')    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)     #    plt.show()    plt.close()	###Finished plotting N_plus  ###    #This plots N-(z) for simulation and GC theory    nonDim='no'    nonDim='yes'    phi='no'  #    phi='yes'    Bikerman='yes'    Bikerman='no'    CarnahanStarling='yes'    CarnahanStarling='no'    MPBoltz='yes'    MPBoltz='no'     if nonDim=='yes' and phi=='yes':      print 'Plotting NonDim N_-(z) with volume fractions...'    elif nonDim=='yes' and phi!='yes':      print 'Plotting NonDim N_-(z)...'    elif nonDim!='yes' and phi!='yes':      print 'Plotting Dim N_-(z)...'	    else:      print 'Plotting Dim N_-(z) with volume fractions...'	    if Bikerman=='yes':		print '\t\t...with Bikerman theory...'		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/MATLAB_Solvers/PBik_Solver_zLzR.m    if CarnahanStarling=='yes':	      print '\t...with Carnahan-Starling theory...'    if MPBoltz=='yes':    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'    i=-1    fig=plt.figure()    fig.subplots_adjust(right=0.85)    ax1=fig.add_subplot(111)    for (Nm,M_T,n0,Sigma_s,ze,lam_D) in zip(N_minusS,M_Theory,n0s,SIGMAS,zetas,LDs):		i+=1		if i==len(markers): #This resets the colors			i=0		if nonDim=='yes':			Nm=[nm/(area*L_bin*n0) for nm in Nm]			graphname = 'N_minus_NDim' + '.pdf'			ylabel=r'$\~N_{-}$'		else: #This is dimensional			Nm=[nm/(area*L_bin) for nm in Nm]			M_T=[n0*t for t in M_T]			graphname = 'N_minus_Dim' + '.pdf'			ylabel=r'$\~N_{-}$'			##Comment out to restore debugging code for Phi plots - 09/14/11 14:43:08 #    	        label1=r'$\bar \Phi$'+' = ' + str(mean_PHI[i])#	        ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Nm,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None',label=label1)##			#Restore code with commented lines below - 08/31/11 15:36:39 				ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Nm,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None')		ax1.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),M_T,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))			if Bikerman=='yes':		   Bik_file='_Bik_zeta_' + ze + '.txt'		   x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]		   c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]		   ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),c_Bik[0],color=colors[i],lw=1.5,ls='--') 		if CarnahanStarling=='yes':		   CS_file='_CS_zeta_' + ze + '.txt'		   x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]		   c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]		   ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),c_CS[0],color=colors[i],lw=1.5,ls='-.') 		if MPBoltz=='yes':		   MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'                   x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      				   volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]		   volt_MPBoltz=np.array(volt_MPBoltz[0])		   volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])		   if nonDim=='yes':		   	ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),np.exp(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')		   elif nonDim=='no':	   			   	ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),n0*np.exp(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')    locs3=[] # A stupid name, but actually the words that print out on the right y-axis    if phi=='yes':		locs1,labels=plt.yticks()		for y in [x*(4.*np.pi/3.)*(sig*0.5)**3 for x in locs1]:			s='%1.1E' % y			locs3.append(s)  		locs3.reverse()		ax2=ax1.twinx()  			locs,labels=plt.yticks()  #These are the location of the new axis		ax2.grid(True)		plt.ylim(ymin=0)		locs = [(x-min(locs1))/(max(locs1)-min(locs1)) for x in locs1] #What a pain in my ass to figure this shit out...		locs.reverse()		plt.yticks(locs, locs3,rotation=15)		ax2.set_ylabel(r'$\Phi_{\sigma}$',size='x-large')     if characteristic_length==L_z:      ax1.set_xlabel(r'$z/L_{box}$',size='x-large')       plt.xlim(xmin=0.0)      plt.xlim(xmax=0.1)      plt.ylim(ymax=10.0)    elif characteristic_length==sig:      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1*L_z/sig)      plt.xlim(xmax=15.)#      if np.mean(LDs)>40:#      	plt.xlim(xmax=0.25*L_z/sig)   #      plt.ylim(ymax=14.)    ax1.set_ylabel(ylabel,size='x-large')    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)     #    plt.show()    plt.close()      ###Finished plotting N_minus    ##This plots N_free(z) for simulation and GC theory    nonDim='no'    nonDim='yes'    Bikerman='yes'    Bikerman='no'    CarnahanStarling='yes'    CarnahanStarling='no'    MPBoltz='yes'    MPBoltz='no'     if nonDim=='yes':      print 'Plotting NonDim N_free(z)...'    else:      print 'Plotting Dim N_free(z)...'	    if Bikerman=='yes':		print '\t\t...with Bikerman theory...'		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m    if CarnahanStarling=='yes':	      print '\t...with Carnahan-Starling theory...'    if MPBoltz=='yes':    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'    i=-1    fig=plt.figure()    fig.subplots_adjust(right=0.85)    ax1=fig.add_subplot(111)    for (Nm,Np,rf_T,n0,Sigma_s,ze,lam_D) in zip(N_minusS,N_plusS,rhof_Theory,n0s,SIGMAS,zetas,LDs):		i+=1		if i==len(markers): #This resets the colors			i=0					if nonDim=='yes':			Nf=[(npl-nm)/(area*L_bin*n0) for (npl,nm) in zip(Np,Nm)]			graphname = 'N_free_NDim' + '.pdf'			ylabel=r'$\~N_{free}$'		else: #This is dimensional			Nf=[(npl-nm)/(area*L_bin) for (npl,nm) in zip(Np,Nm)]			rf_T=[n0*t for t in rf_T]			graphname = 'N_free_Dim' + '.pdf'			ylabel=r'$\~N_{free}$'				  		##Comment out to restore debugging code for Phi plots - 09/14/11 14:43:08 #    	        label1=r'$\bar \Phi$'+' = ' + str(mean_PHI[i])#	        ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Nf,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None',label=label1)#np.mean(muex_EV[len(muex_EV)/2-2:len(muex_EV)/2+2]))#		print np.array(z_density[0:len(z_density)/2])*L_z#		if i==0:#			print 'Scaling information'#			print Bjerrum,'\t',area,'\t',area*500,'\n\n'		Sig_m=-n0*sum([L_bin*nf for nf in Nf[0:len(Nf)/2]])#		print '%1.5f\t%1.5f\t%1.5f\t%1.8f\t%i\t%1.2f\t%1.2f' % (Sigma_s,Sig_m,1.-Sig_m/Sigma_s,n0,int(round(sum(Np)+sum(Nm))),2.*area*n0,lam_D)#		print Sigma_s,'\t',-sum([L_bin*nf for nf in Nf[0:len(Nf)/2]]),'\t',n0,'\t',area,'\t',int(round(sum(Np)+sum(Nm),1))			##Restore code with commented out lines below - 08/31/11 15:39:38 		ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Nf,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None')		ax1.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),rf_T,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))		if Bikerman=='yes':		  Bik_file='_Bik_zeta_' + ze + '.txt'		  x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]		  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]		  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]		  ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),np.array(co_Bik[0])-np.array(c_Bik[0]),color=colors[i],lw=1.5,ls='--') #		  print lam_D,characteristic_length,x_Bik[0][:5],x_Bik[0][-5:]		if CarnahanStarling=='yes':		  CS_file='_CS_zeta_' + ze + '.txt'		  x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]		  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]		  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	      		  ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),np.array(co_CS[0])-np.array(c_CS[0]),color=colors[i],lw=1.5,ls='-.')		if MPBoltz=='yes':		   MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'#		   if i==0: #This reasonably assumes the Bikerman plots all share the same x-axis#		      x_MPBoltz=[[float(x) for x in line.split()] for line in file('x_MPBoltz.txt',"r").readlines()]                   x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      				   volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]		   volt_MPBoltz=np.array(volt_MPBoltz[0])		   volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])		   if nonDim=='yes':  			   ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),-np.sinh(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')		   elif nonDim=='no':	   		   		   ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),-n0*np.sinh(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')    if characteristic_length==L_z:      ax1.set_xlabel(r'$z/L_{box}$',size='x-large')       plt.xlim(xmin=0.0)      plt.xlim(xmax=0.1)      plt.ylim(ymin=-10.0)      plt.ylim(ymax=0.25)    elif characteristic_length==sig:      ax1.set_xlabel(r'$\~z=z/ \sigma_{WCA}$',size='x-large')      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1*L_z/sig)      plt.xlim(xmax=15.)#      if np.mean(LDs)>40:#      	plt.xlim(xmax=0.25*L_z/sig)   #      plt.ylim(ymin=-7.)      plt.ylim(ymax=0.25)      plt.ylim(ymin=-5.)    ax1.set_ylabel(r'$\~N_{free}$',size='x-large')    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)       #plt.show()    plt.close()      ##Finished plottting N_free#    #This plots N_free(z) vs y_Shell for simulation and GC theory#    print 'Plotting NonDim N_free(z) vs y_Shell...'#    i=-1#    fig=plt.figure()#    fig.subplots_adjust(left=0.16)#    fig.subplots_adjust(bottom=0.14)#    ax1=fig.add_subplot(111)#    datamin=1000#    i2=-1#    y_Data,rhof_Data='[','['   #    LD_Data,ND_Sigs='[','['#    for (Volt,Nm,Np,n0,Sigma_s,ze,lam_D,rho_fT,Sig_T) in zip(Volts,N_minusS,N_plusS,n0s,SIGMAS,zetas,LDs,rhof_Theory,SIGMA_Theory):#		i+=1#		i2+=1#		if i==len(markers): #This resets the colors#			i=0#		if i==0:#			graphname = 'N_free_v_Shell_y'#			ylabel=r'$\~ \rho_{f}(\~ y)$'#			z_den_T = np.array(np.linspace(0.+z_wall/L_z,1.-z_wall/L_z,2*5000))*L_z##		NTOTAL = np.sum(Nm)+np.sum(Np)##		print lam_D,np.sqrt(dielectric*temperature*area*L_z/NTOTAL) #These give same number, which is good##		##This plots my data#		Nf=np.array([(npl-nm)/(area*L_bin) for (npl,nm) in zip(Np,Nm)])#		Npl=np.array([npl/(area*L_bin) for npl in Np])#		Nmi=np.array([nmi/(area*L_bin) for nmi in Nm])##		print len(Volt),len(Npl)##		print Volt[0:5]##		print Npl[0:5]#		#		muex_p = -np.log(Npl) - np.array(Volt[1:])  #Not too sure about [1:], but needed to so the vectors would align#		muex_m = -np.log(Nmi) + np.array(Volt[1:])#		muex_p = muex_p - np.mean(muex_p[len(muex_p)/2-2:len(muex_p)/2+2])#		muex_m = muex_m - np.mean(muex_m[len(muex_m)/2-2:len(muex_m)/2+2])#		##		print muex_p[0:4]#		Nf_idealized = Npl/np.exp(-muex_p) - Nmi/np.exp(-muex_m)#		Nf_idealized = 0.5*Nf_idealized/(dielectric*temperature/(valency*lam_D**2)) ##This didn't exactly work on the first try...#		Nf=0.5*Nf/(dielectric*temperature/(valency*lam_D**2)) ##Assumes temp and valency are 1		#		ND_Sig = Sigma_s / (dielectric*temperature / (valency*lam_D))			#		rho_f,y_Shell=[],[]#		rho_fi=[]#		f=0#		for (nfi,nfree,z) in zip(Nf_idealized,Nf,np.array(z_density)*L_z):#			if z<L_z*0.5:#				rho_f.append(nfree)#				rho_fi.append(nfi)#				y_Shell.append(np.exp(-z/lam_D)*(np.sqrt(1+(ND_Sig/2.)**-2)-(ND_Sig/2.)**-1))#			else:#				f+=1#				rho_f[-f]=0.5*(rho_f[-f]-nfree) ##Take average value of these#				rho_fi[-f]=0.5*(rho_fi[-f]-nfi)#				##				print z,rho_f[-f],nfree#		datamin=np.min([datamin,np.min(rho_f)])#		Sigma_s=ND_Sig #		ax1.errorbar(y_Shell[1:],rho_f[1:],ls='None',yerr=None,color=colors[i],marker=markers[i],label=r'$\tilde \Sigma$'+' = ' + str(round(Sigma_s,3)))##		ax1.errorbar(y_Shell[1:],rho_fi[1:],ls='None',yerr=None,color='orange',marker=markers[i]) #color=colors[i]#		##ALSO, complete this analysis for Scott!##	    	if Sigma_s!=0:		##			for (y,rf) in zip(y_Shell[1:],rho_f[1:]):##				rf_t = -2*y*(y**2+1)/(1-y**2)**2##				print y,rf_t-rf#		#The code below generates theory lines#		if i2==len(zetas)-1:#			z_ND = z_den_T[z_den_T<L_z*0.5]/lam_D#			y = np.exp(-z_ND)*(np.sqrt(1+(ND_Sig/2.)**-2)-(ND_Sig/2.)**-1) #This is GC#			ax1.errorbar(y,-2*y*(y**2+1)/(1-y**2)**2,yerr=None,ls='-',lw=2.5,color='k',marker='None')##			print 'Testing to see if there is a missing factor'##			ax1.errorbar(y,-(np.pi/2)*2*y*(y**2+1)/(1-y**2)**2,yerr=None,ls='-',lw=2.5,color='red',marker='None')#			xmax=np.max(y)#			#The code below gives Bikerman predictions, which are about the same as GC##			r = 0.5*(dielectric*temperature/(valency*lam_D**2))*((np.pi/6)*sig_HS**3)/0.74048##			y2 = (np.sqrt(1+(ND_Sig/2.)**-2)-(ND_Sig/2.)**-1)*np.exp(r*(2.+ND_Sig**2)/(2.*np.sqrt(4.+ND_Sig**2)) - z_ND)##			Psi_Bik = 2.*np.arcsinh(np.sqrt((np.exp(0.5*r*ND_Sig**2)-1.)/(2.*r)))- ND_Sig*z_ND + (1./(2.*r)) * np.sqrt((1.-np.exp(-0.5*r*ND_Sig**2))*(1.-np.exp(-0.5*r*ND_Sig**2)*(1.-2.*r)))*z_ND**2##			rf_Bik=-np.sinh(Psi_Bik) / ( 1. + 2.*r*np.sinh(Psi_Bik/2.)**2)##			y = y2##			ax1.errorbar(y,-2*y*(y**2+1)/(1-y**2)**2,yerr=None,ls='-',lw=2.5,color='red',marker='None')##			xmax=np.max([np.max(y2),xmax])#	    	#The code below is used to print out all information from the plot, for later consolidation   #	    	if Sigma_s!=0:#			LD_Data+=str(lam_D)+','#			ND_Sigs+=str(ND_Sig)+','    	#			for (yD,rD) in zip(y_Shell[1:],rho_f[1:]):#				  y_Data+=str(round(yD,4))+','#				  rhof_Data+=str(round(rD,4))+','#    ax1.set_xlabel(r'$\~y=\exp(-z/\lambda_{D}) \left [ \sqrt{2\tilde \Sigma_{s}^{-2} + 1} - 2\tilde \Sigma_{s}^{-1} \right ]$',size='x-large')#    ax1.set_xlim(0,xmax*1.5)#    ax1.set_ylim(ymax=0)#    ax1.set_ylabel(ylabel,size='x-large')#    plt.savefig(graphname+'_nl.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    ax1.legend(loc=0) #    plt.savefig(graphname+'_l.pdf', dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)          ##    plt.show()#    plt.close()    	###Print for consolidation purposes#    LD_Data=LD_Data[:-1]+']'#    ND_Sigs=ND_Sigs[:-1]+']'#    y_Data=y_Data[:-1]+']'#    rhof_Data=rhof_Data[:-1]+']'#    label_str = """r'$(\\bar{"""+'\lambda_{D}},\lambda_{B},\sigma_{WCA})$ = ('+str(round(np.mean(LDs),2))+','+str(int(Bjerrum))+','+str(sig)+')'#    label_str = """r'$"""+'\lambda_{B}$ = '+str(int(Bjerrum))+'\''#    print '\n    i+=1\n    label_str = ' +  label_str #    print '    LD_Data = ' + LD_Data#    print '    ND_Sigs = ' + ND_Sigs#    print '    y_Data = ' + y_Data#    print '    rhof_Data = ' + rhof_Data      #Finished plottting N_free(y_Shell)#    print [(np.pi/6)*sig_HS**3/(lD*lD*Bjerrum*8*np.pi) for lD in LDs]#    print "Need to mimic out put, only with different name: Analyzed_GC_ ..."##	    total_prefix='Analyzed_P1_' + filename[:len(filename)-4]##	    total_output=file(total_prefix+".txt","w")##	    for (z,V,E,Np,Nm,muexEV) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[z_min],E_tot.tolist()+[z_max],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion],muex_EV.tolist()+[muex_EV_total]):##	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV))   ##	    total_output.close()        #    print "This is the starting format..."#	    total_prefix='Analyzed_muexEV_' + str(M_per_slice) + filename[4:len(filename)-4]#	    total_output=file(total_prefix+"_DATA.txt","w")#	    for (z,V,E,Np,Nm,muexEV) in zip(Shell_bin.tolist()+[Sigma_s],Psi_tot.tolist()+[dipole_avg],E_tot.tolist()+[dipole_avg_sq],A_count.tolist()+[area,Bjerrum],C_count.tolist()+[lambda_D,r_ion],muex_EV.tolist()+[muex_EV_total]):#	    	total_output.write("%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\t\t\t\t%-1.5f\n" % (z,V,E,Np,Nm,muexEV))   #	    total_output.close()  #    ##This plots N_free(z) and Psi(z) for simulation and GC theory#    characteristic_length=np.mean(LDs)#    nonDim='yes'#    Bikerman='yes'#    Bikerman='no'#    CarnahanStarling='yes'#    CarnahanStarling='no'#    MPBoltz='yes'#    MPBoltz='no' #    if nonDim=='yes':#      print 'Plotting NonDim Voltage(z) and then N_free(z)...'#    else:#      print 'ERROR',crash	#    if Bikerman=='yes':#		print '\t\t...with Bikerman theory...'#		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m#    if CarnahanStarling=='yes':#	      print '\t...with Carnahan-Starling theory...'#    if MPBoltz=='yes':#    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'#    i=-1#    fig=plt.figure()##    fig.subplots_adjust(right=0.85)#    ax1=fig.add_subplot(111)#    for (Nm,Np,rf_T,n0,Sigma_s,ze,lam_D,V,volt_theory) in zip(N_minusS,N_plusS,rhof_Theory,n0s,SIGMAS,zetas,LDs,Volts,volt_theoryS):#		i+=1#		if i==len(markers): #This resets the colors#			i=0#			#		if nonDim=='yes':##			Nf=[(npl-nm)/(area*L_bin*n0) for (npl,nm) in zip(Np,Nm)]#			graphname = 'Voltage_and_N_free' + '.pdf'##			ylabel=r'$\~N_{free}$'		##			ax1.set_ylabel(r'$\~ \psi$',size='x-large')	  #		color_perm=colors[i]#		colors[i]='blue'#		ax1.errorbar(np.array(z_positions)*(L_z/characteristic_length),V,yerr=None,marker='+',ms=7.0,color=colors[i],ls='None')#,label=r'$\Sigma_{s}$'+' = ' + str(round(Sigma_s,3)))#		ax1.errorbar(np.array(z_positions)*(L_z/characteristic_length),volt_theory,yerr=None,ls='-',lw=2.0,color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))#		colors[i]=color_perm##	        ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Nf,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None',label=label1)##		ax1.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),rf_T,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))##		if Bikerman=='yes':##		  Bik_file='_Bik_zeta_' + ze + '.txt'##		  x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]##		  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]##		  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]##		  ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),np.array(co_Bik[0])-np.array(c_Bik[0]),color=colors[i],lw=1.5,ls='--') ###		  print lam_D,characteristic_length,x_Bik[0][:5],x_Bik[0][-5:]##		if CarnahanStarling=='yes':##		  CS_file='_CS_zeta_' + ze + '.txt'##		  x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]##		  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]##		  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	      ##		  ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),np.array(co_CS[0])-np.array(c_CS[0]),color=colors[i],lw=1.5,ls='-.')##		if MPBoltz=='yes':##		   MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'###		   if i==0: #This reasonably assumes the Bikerman plots all share the same x-axis###		      x_MPBoltz=[[float(x) for x in line.split()] for line in file('x_MPBoltz.txt',"r").readlines()]##                   x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      		##		   volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]##		   volt_MPBoltz=np.array(volt_MPBoltz[0])##		   volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])##		   if nonDim=='yes':##  			   ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),-np.sinh(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')##		   elif nonDim=='no':	   	##	   		   ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),-n0*np.sinh(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')#    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') #      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1)#      plt.ylim(ymin=-10.0)#      plt.ylim(ymax=0.25)#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$\~z=z/ \sigma_{WCA}$',size='x-large')#      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1*L_z/sig)#      plt.xlim(xmax=35.)##      if np.mean(LDs)>40:##      	plt.xlim(xmax=0.25*L_z/sig)   ##      plt.ylim(ymin=-7.)#      plt.ylim(ymax=0.25)#    elif characteristic_length==np.mean(LDs):#      ax1.set_xlabel(r'$z/ \lambda_{D}$',size='x-large')#      plt.xlim(xmin=0.0)#      plt.xlim(xmax=L_z/np.mean(LDs))##      plt.ylim(ymax=0.25)##    ax1.legend(loc=0)  #Not sure about this#    ax2 = ax1.twinx()#    i=-1#    mini,maxi=100,-100#    for (Nm,Np,rf_T,n0,Sigma_s,ze,lam_D) in zip(N_minusS,N_plusS,rhof_Theory,n0s,SIGMAS,zetas,LDs):#		i+=1#		if i==len(markers): #This resets the colors#			i=0##			ax2.set_ylabel(r'$\~N_{free}$',size='x-large')	 #			#		if nonDim=='yes':#			Nf=[(npl-nm)/(area*L_bin*n0) for (npl,nm) in zip(Np,Nm)]#			mini=np.min([np.min(Nf),mini])#			maxi=np.max([np.max(Nf),maxi])# 		color_perm=colors[i]#		colors[i]='orange'# 		markers_perm=markers[i]# 		markers[i]='s'# 		ax2.errorbar(np.array(z_density)*(L_z/characteristic_length),Nf,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None')#,label=label1)#		ax2.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),rf_T,yerr=None,ls='-',lw=2.0,color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))#		colors[i]=color_perm# 		markers[i]=markers_perm#		#		if Bikerman=='yes':#		  Bik_file='_Bik_zeta_' + ze + '.txt'#		  x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]#		  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]#		  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]#		  ax2.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),np.array(co_Bik[0])-np.array(c_Bik[0]),color=colors[i],lw=1.5,ls='--') ##		  print lam_D,characteristic_length,x_Bik[0][:5],x_Bik[0][-5:]#		if CarnahanStarling=='yes':#		  CS_file='_CS_zeta_' + ze + '.txt'#		  x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]#		  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]#		  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	      #		  ax2.plot(np.array(x_CS[0])*(lam_D/characteristic_length),np.array(co_CS[0])-np.array(c_CS[0]),color=colors[i],lw=1.5,ls='-.')#		if MPBoltz=='yes':#		   MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'##		   if i==0: #This reasonably assumes the Bikerman plots all share the same x-axis##		      x_MPBoltz=[[float(x) for x in line.split()] for line in file('x_MPBoltz.txt',"r").readlines()]#                   x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      		#		   volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]#		   volt_MPBoltz=np.array(volt_MPBoltz[0])#		   volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])#		   if nonDim=='yes':#  			   ax2.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),-np.sinh(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')#		   elif nonDim=='no':	   	#	   		   ax2.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),-n0*np.sinh(volt_MPBoltz-volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')#    if characteristic_length==L_z:#      ax2.set_xlabel(r'$z/L_{box}$',size='x-large') ##      plt.xlim(xmin=0.0)##      plt.xlim(xmax=0.1)##      plt.ylim(ymin=-10.0)##      plt.ylim(ymax=0.25)#    elif characteristic_length==sig:#      ax2.set_xlabel(r'$\~z=z/ \sigma_{WCA}$',size='x-large')##      plt.xlim(xmin=0.0)##      plt.xlim(xmax=0.1*L_z/sig)##      plt.xlim(xmax=35.)##      if np.mean(LDs)>40:##      	plt.xlim(xmax=0.25*L_z/sig)   ##      plt.ylim(ymin=-7.)#      plt.ylim(ymax=0.25)#    elif characteristic_length==np.mean(LDs):#      ax2.set_ylim(mini,maxi)#      ax2.set_ylim(-10,10)#      plt.xlim(xmin=0.0)#      plt.xlim(xmax=L_z/np.mean(LDs))##      ax1.set_xlabel(r'$z/ \lambda_{D}$',size='x-large')##      plt.xlim(xmin=0.0)##      plt.xlim(xmax=35.)##      plt.ylim(ymax=0.25)##    ax2.legend(loc=0)  #Not sure about this#    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   ##    plt.show()#    plt.close()#    characteristic_length=sig#      ##Finished plottting Voltage and N_free#    ion_sizes=[4.0,5.0,6.5,7.0,8.0,9.0,10.0]    ##This plots N_tot(z) for simulation and GC theory    nonDim='no'    nonDim='yes'    Bikerman='yes'    Bikerman='no'    CarnahanStarling='yes'    CarnahanStarling='no'    MPBoltz='yes'    MPBoltz='no'     if nonDim=='yes':      print 'Plotting NonDim N_tot(z)...'    else:      print 'Plotting Dim N_tot(z)...'	    if Bikerman=='yes':		print '\t\t...with Bikerman theory...'		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m    if CarnahanStarling=='yes':	      print '\t...with Carnahan-Starling theory...'    if MPBoltz=='yes':    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'    i=-1    fig=plt.figure()    fig.subplots_adjust(right=0.85)    ax1=fig.add_subplot(111)    for (Nm,Np,M_T,P_T,n0,Sigma_s,ze,lam_D) in zip(N_minusS,N_plusS,M_Theory,P_Theory,n0s,SIGMAS,zetas,LDs):		i+=1		if i==len(markers): #This resets the colors			i=0					if i ==0:			graphname = 'N_tot' + '.pdf'			ylabel=r'$\~ N+{tot}$'#		sig_HS=Noro_WCA(1,ion_sizes[i], 10**-20, ion_sizes[i], 10**5)			if nonDim=='yes':			Nt=[(npl+nm)/(area*L_bin*n0) for (npl,nm) in zip(Np,Nm)]			graphname = 'N_tot_NDim' + '.pdf'		else: #This is dimensional			Nt=[(npl+nm)/(area*L_bin) for (npl,nm) in zip(Np,Nm)]#			rf_T=[n0*t for t in rf_T]			graphname = 'N_tot_Dim' + '.pdf'				  #    	        label1=r'$\bar \Phi$'+' = ' + str(mean_PHI[i])#	 	Phi = n0*(Nm+Np)*(np.pi/6.)*sig_HS**3#	        ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Phi,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None',label=label1)			#Restore code with commented out lines below - 08/31/11 15:39:38 		ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Nt,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None')		ax1.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),(M_T+P_T),yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))		if Bikerman=='yes':		  Bik_file='_Bik_zeta_' + ze + '.txt'		  x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]		  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]		  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]		  ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),np.array(co_Bik[0])+np.array(c_Bik[0]),color=colors[i],lw=1.5,ls='--') #		  print lam_D,characteristic_length,x_Bik[0][:5],x_Bik[0][-5:]		if CarnahanStarling=='yes':		  CS_file='_CS_zeta_' + ze + '.txt'		  x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]		  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]		  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	  		  if nonDim=='yes':			  ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),np.array(co_CS[0])+np.array(c_CS[0]),color=colors[i],lw=1.5,ls='-.') 				  		 		  elif nonDim=='no':		  	  print 'Not too sure'			  ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),n0*np.array(co_CS[0])+n0*np.array(c_CS[0]),color=colors[i],lw=1.5,ls='-.') 		  			if MPBoltz=='yes':		   MPBoltz_file='_MPBoltz_zeta_' + ze + '.txt'                   x_MPBoltz=[[float(x) for x in line.split()] for line in file('x' + MPBoltz_file,"r").readlines()]      				   volt_MPBoltz=[[float(x) for x in line.split()] for line in file('volt' + MPBoltz_file,"r").readlines()]		   volt_MPBoltz=np.array(volt_MPBoltz[0])		   volt_MPBoltz_bulk=np.mean(volt_MPBoltz[len(volt_MPBoltz)/2-2:len(volt_MPBoltz)/2+2])		   if nonDim=='yes':		   	ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),np.exp(-volt_MPBoltz)+np.exp(volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')		   elif nonDim=='no':		   	ax1.plot(np.array(x_MPBoltz[0])*(lam_D/characteristic_length),n0*np.exp(-volt_MPBoltz)+n0*np.exp(volt_MPBoltz_bulk),color=colors[i],lw=2.0,ls=':')       if characteristic_length==L_z:      ax1.set_xlabel(r'$z/L_{box}$',size='x-large')       plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1)      plt.ylim(ymin=-10.0)      plt.ylim(ymax=0.25)    elif characteristic_length==sig:      ax1.set_xlabel(r'$\~z=z/ \sigma_{WCA}$',size='x-large')      plt.xlim(xmin=0.0)      plt.xlim(xmax=15.)#      plt.xlim(xmax=1.0*L_z/sig)      if np.mean(LDs)>40:      	plt.xlim(xmin=0.0)         	plt.xlim(xmax=15)   #      plt.ylim(ymin=0.0)#      plt.ylim(ymax=0.001) #0.00005    ax1.set_ylabel(r'$\tilde N_{tot}$',size='x-large')    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    plt.show()    plt.close()      ##Finished plotting N_tot#    ion_sizes=[4.0,5.0,6.5,7.0,8.0,9.0,10.0]    ##This plots Phi_tot(z) for simulation and GC theory    nonDim='no'    nonDim='yes'    Bikerman='yes'    Bikerman='no'    CarnahanStarling='yes'    CarnahanStarling='no'    MPBoltz='yes'    MPBoltz='no'     if nonDim=='yes':      print 'Plotting NonDim Phi_tot(z)...'    else:      print 'Plotting Dim Phi_tot(z)...'	    if Bikerman=='yes':		print '\t\t...with Bikerman theory...'		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m    if CarnahanStarling=='yes':	      print '\t...with Carnahan-Starling theory...'    if MPBoltz=='yes':    	print '\t...with Modified Poisson w/Boltzmann distribution theory...'    i=-1    fig=plt.figure()    fig.subplots_adjust(right=0.85)    ax1=fig.add_subplot(111)    for (Nm,Np,M_T,P_T,n0,Sigma_s,ze,lam_D) in zip(N_minusS,N_plusS,M_Theory,P_Theory,n0s,SIGMAS,zetas,LDs):		i+=1		if i==len(markers): #This resets the colors			i=0					if i ==0:			ylabel=r'$\~ Phi_{tot}$'			graphname = 'Phi_tot' + '.pdf'					Nt=np.array([(npl+nm)/(area*L_bin) for (npl,nm) in zip(Np,Nm)])		Pt = Nt*(np.pi/6)*sig**3#    	        label1=r'$\bar \Phi$'+' = ' + str(mean_PHI[i])#	 	Phi = n0*(Nm+Np)*(np.pi/6.)*sig_HS**3#	        ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Phi,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None',label=label1)			#Restore code with commented out lines below - 08/31/11 15:39:38 		ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),Pt,yerr=None,marker=markers[i],ms=5.0,color=colors[i],ls='None')		ax1.errorbar(np.array(z_den_theory)*(L_z/characteristic_length),n0*(M_T+P_T)*(np.pi/6)*sig**3,yerr=None,ls='-',color=colors[i],label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))		if Bikerman=='yes':		  Bik_file='_Bik_zeta_' + ze + '.txt'		  x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]		  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]		  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]		  ax1.plot(np.array(x_Bik[0])*(lam_D/characteristic_length),n0*(np.array(co_Bik[0])+np.array(c_Bik[0]))*(np.pi/6)*sig**3,color=colors[i],lw=1.5,ls='--') #		  print lam_D,characteristic_length,x_Bik[0][:5],x_Bik[0][-5:]		if CarnahanStarling=='yes':		  CS_file='_CS_zeta_' + ze + '.txt'		  x_CS=[[float(x) for x in line.split()] for line in file('x' + CS_file,"r").readlines()]		  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]		  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	  		  ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),n0*(np.array(co_CS[0])+np.array(c_CS[0]))*(np.pi/6)*sig**3,color=colors[i],lw=1.5,ls='-.') 				  		     if characteristic_length==L_z:      ax1.set_xlabel(r'$z/L_{box}$',size='x-large')       plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.1)      plt.ylim(ymin=-10.0)      plt.ylim(ymax=0.25)    elif characteristic_length==sig:      ax1.set_xlabel(r'$\~z=z/ \sigma_{WCA}$',size='x-large')      plt.xlim(xmin=0.0)      plt.xlim(xmax=15.)      plt.ylim(ymin=0.2)      plt.ylim(ymax=0.4)    ax1.set_ylabel(r'$\Phi_{tot}$',size='x-large')    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    plt.show()    plt.close()      ##Finished plotting Phi_tot#    temp =[]####    mean_PHI = [0.025,0.048,0.107,0.133]##    ##This plots mu_ex^EV(z) for simulation and modified theories##    nonDim='no'#    nonDim='yes'#    Bikerman='yes'#    Bikerman='no'#    CarnahanStarling='yes'#    CarnahanStarling='no'#    if nonDim=='yes':#      print 'Plotting NonDim mu_ex^EV(z)...'#    else:#      print 'Plotting Dim mu_ex^EV(z)...'	#    if Bikerman=='yes':#		print '\t\t...with Bikerman theory...'#		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m#    if CarnahanStarling=='yes':#	      print '\t...with Carnahan-Starling theory...'##    M=10##    colors=['k','g','r','c','m','y','b','orange','yellow','grey']#    for (Sigma_s,ze) in zip(zetas,SIGMAS):#      i+=1#      colors.append(ROYGBIV_map(float(ze),float(zetas[-1])))#    muex_EVs=[]##    zeta_muex='1.500'#    i=-1#    fig=plt.figure()#    ax1=fig.add_subplot(111)#    fig.subplots_adjust(right=0.90)#    for (Sigma_s,ze,lamD) in zip(SIGMAS,zetas,LDs):#    	#This all needs to be cleaned up, more or less.  - 12/14/10 10:52:33   	#    	i+=1#    	filename='Analyzed_muexEV_' +  '15' + '_ss_zeta_' + ze + '_DATA.txt'##    	filename='Analyzed_muexEV_' +  '10' + '_ss_zeta_' + ze + '_DATA.txt'#    			##This is special, for Uncharged particles - 08/31/11 13:22:07 ##    	filename='Analyzed_muexEV_15' + '_ss_phis_' + ze + '_DATA.txt'#	if i==len(markers): #This resets the colors#			i=0#    	z_50=np.array([[float(x) for x in line.split()] for line in file(filename,"r").readlines()])#	muex_EV=z_50[:,5]#	muex_EV_tot = muex_EV[-1]#	muex_EV = muex_EV[:-2]  #Perhaps need to subtract off the bulk value on this#	label1=r'$\Sigma$'+' = ' + str(round(Sigma_s,3))##	label1=r'$\bar \Phi$'+' = ' + str(mean_PHI[i])#	ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),muex_EV-np.mean(muex_EV[len(muex_EV)/2-2:len(muex_EV)/2+2]),yerr=None,marker=markers[i],ms=3.0,color=colors[i],ls='None',label=label1)#	muex_EVs.append(muex_EV-np.mean(muex_EV[len(muex_EV)/2-2:len(muex_EV)/2+2]))#	#	graphname_1 = 'muex_EV_z' + '.pdf'#	ylabel_1=r'$\~\mu_{ex}^{EV}$'#	if Bikerman=='yes':#	  Bik_file='_Bik_zeta_' + ze + '.txt'#	  x_Bik=[[float(x) for x in line.split()] for line in file('x' + Bik_file,"r").readlines()]#	  x_Bik=np.array(x_Bik)*lam_D/characteristic_length#	  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]#	  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]#	  ax1.plot(x_Bik[0],-0.5*np.log(np.array(co_Bik[0])*np.array(c_Bik[0])),color=colors[i],lw=1.5,ls='--') #	if CarnahanStarling=='yes':#	  CS_file='_CS_zeta_' + ze + '.txt'#          x_CS=[[float(x) for x in line.split()] for line in file('x'+CS_file,"r").readlines()]#          x_CS=np.array(x_CS)*lam_D/characteristic_length#	  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]#	  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	      #	  if sig==1:#	  	ax1.plot(x_CS[0],0.5*np.log(np.array(co_CS[0])*np.array(c_CS[0])),color=colors[i],lw=1.5,ls='-.')#	  else:#	  	ax1.plot(x_CS[0],-0.5*np.log(np.array(co_CS[0])*np.array(c_CS[0])),color=colors[i],lw=1.5,ls='-.')##  	  temp.append(-0.5*np.log(np.array(co_CS[0])*np.array(c_CS[0])))#    ax1.set_ylabel(ylabel_1,size='x-large') #    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') #      ax2.set_xlabel(r'$Insertion / bin$',size='x-large')#      plt.xlim(xmin=np.min(M_range))#      plt.xlim(xmax=np.max(M_range))#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')#      ax1.set_xlim(0,15)##      ax1.set_ylim(-0.05,0.05)##      if sig==8:##	      ax1.set_xlim(0,10)##      if np.mean(LDs)>16:##      	plt.xlim(xmax=10.0)#    ax1.legend(loc=0) #    plt.savefig(graphname_1, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   ##    plt.show()#    plt.close()#    #Done plotting mu_excess^EV(z)#    print 'Cross-Plotting mu^EV_{ex,tot,sim} vsmu^EV_{ex,tot,CS}...'#    M=10 #    i=-1#    fig=plt.figure()#    ax1=fig.add_subplot(111)#    fig.subplots_adjust(right=0.90)#    for (Nm,Np,Sigma_s,ze,n0) in zip(N_minusS,N_plusS,SIGMAS,zetas,n0s):        #    	i+=1##    	filename='Analyzed_muexEV_' +  '15' + '_ss_zeta_' + ze + '_DATA.txt'#    	filename='Analyzed_muexEV_' +  '10' + '_ss_zeta_' + ze + '_DATA.txt'#		##This is special, for Uncharged particles - 08/31/11 13:22:07 ##    	filename='Analyzed_muexEV_10' + '_ss_phis_' + ze + '_DATA.txt'##	print filename#	#	if i==len(markers): #This resets the colors#			i=0#	if i==0:#		graphname_1 = 'Crossplot_muex_EV_Data_CS' + '.pdf'#		index_truncation=10*0##		Phi_max=-1.##		muex_EV_max=-10000.##		muex_EV_min=10000.##		##		Phi=np.linspace(0,0.95)##		muex_EV_Bik=-np.log(1-Phi*(6/np.pi))###		ax1.errorbar(Phi,muex_EV_Bik,yerr=None,ms=3.0,color='k',ls='--')##		muex_EV_CS = Phi*(8-9*Phi+3*Phi**2)/((1-Phi)**3)###		ax1.errorbar(Phi,muex_EV_CS ,yerr=None,ms=3.0,color='k',ls='-.')	#	label1=r'$\Sigma$'+' = ' + str(round(Sigma_s,3))#    	z_50=np.array([[float(x) for x in line.split()] for line in file(filename,"r").readlines()])#	muex_EV=z_50[:,5]#	muex_EV_tot = muex_EV[-1]  #This was verified to be correct - 11/08/11 16:19:09 #	muex_EV = muex_EV[:-2] #	muex_EV = muex_EV-np.mean(muex_EV[len(muex_EV)/2-2:len(muex_EV)/2+2])#	##The code below checks to see if simulation agrees better with CS predictions#		##when we truncate the regions where there is ordering (at the walls)#	if index_truncation!=0:#		exp_muex = [50000.*np.exp(-m) for m in muex_EV]  ##exp_muex here = exp(-U_0j)]#		exp_muex = exp_muex[index_truncation:-index_truncation]##	print muex_EV_tot,-np.log(sum(exp_muex)/(len(exp_muex)*50000.))#		muex_EV_tot=-np.log(sum(exp_muex)/(len(exp_muex)*50000.))#	if CarnahanStarling=='yes':#	  CS_file='_CS_zeta_' + ze + '.txt'#          x_CS=[[float(x) for x in line.split()] for line in file('x'+CS_file,"r").readlines()]#          x_CS=np.array(x_CS[0])*lam_D/characteristic_length#	  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]#	  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	      #	muex_EV_CS = -0.5*np.log(np.array(co_CS[0])*np.array(c_CS[0]))#	###The code below gives an identical way of getting "muex_EV_CS"##	Phi_CS = (np.array(c_CS[0])+np.array(co_CS[0]))*2.*n0*(np.pi/6.)*sig_HS**3##	muex_EV_CS1 = Phi_CS*(8-9*Phi_CS+3*Phi_CS**2)/((1-Phi_CS)**3) #y-axis##	muex_EV_CS1 = muex_EV_CS1 -np.mean(muex_EV_CS1[len(muex_EV_CS1)/2-2:len(muex_EV_CS1)/2+2])#	integral=0.#	dx = x_CS[1]-x_CS[0]##	print x_CS[0:10]*characteristic_length##	print np.array(z_density[4:-4])*characteristic_length#	z_lo,z_hi =z_density[index_truncation]*characteristic_length,z_density[-index_truncation-1]*characteristic_length##	print z_lo,z_hi#	temp1=[]#	for (z,CS) in zip(x_CS*characteristic_length,muex_EV_CS):#		if (z>=z_lo and z<=z_hi):#			temp1.append(CS)#	muex_EV_CS=np.array(temp1)#	#	for (y1,y2) in zip(np.exp(-muex_EV_CS[0:len(muex_EV_CS)-1]),np.exp(-muex_EV_CS[1:])):#		integral+=(min(y1,y2)*dx + (max(y1,y2)-min(y1,y2))*dx*0.5)#	ax1.errorbar(integral,np.exp(-muex_EV_tot),yerr=None,color=colors[i],marker=markers[i],ms=3.0,ls='',label=label1)	#    ax1.set_ylabel(ylabel_1,size='x-large')#    ax1.errorbar(np.linspace(0,10),np.linspace(0,10),yerr=None,color='k',ls='-')     #    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') ##      ax2.set_xlabel(r'$Insertion / bin$',size='x-large')#      plt.xlim(xmin=np.min(M_range))#      plt.xlim(xmax=np.max(M_range))#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$ \exp(-\~ \mu_{ex}^{tot,CS}) = \int \exp(-\~ \mu_{ex}^{CS}(\~z)) d\~z $',size='x-large')#      ax1.set_ylabel(r'$ \exp(-\~ \mu_{ex}^{tot,EV}) $',size='x-large')#      ax1.set_xlim(0,1.5)#      ax1.set_ylim(0,1.5)#    ax1.legend(loc=0) #    plt.savefig(graphname_1, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   ##    plt.show()#    plt.close()#    #Done cross plotting mu_excess^EV,tot for data and CS theory####    This plots mu_excess^EC(z) for simulation and GC theory#	Temporary...#    muex_EVs=[muex_EV]#    print 'Plotting muex^EC_pm(z)...'#    i=-1#    fig=plt.figure()##    ax1=fig.add_subplot(111)##    fig.subplots_adjust(right=0.90)#    ax1=fig.add_subplot(211)#    ax2=fig.add_subplot(212)#    muex_EC_pS,muex_EC_mS=[],[]#    for (Nm,Np,Sigma_s,ze,Psi,EV,zd) in zip(N_minusS,N_plusS,SIGMAS,zetas,Volts,muex_EVs,zeta_data):#	i+=1#	#	if i==0:#		graphname = 'muex_EC_z' + '.pdf'#	if i==1:#		ax1.errorbar(np.array(z_plot)*(L_z/characteristic_length),np.zeros(len(z_plot)),yerr=None,color='k',ls=':')#		ax2.errorbar(np.array(z_plot)*(L_z/characteristic_length),np.zeros(len(z_plot)),yerr=None,color='k',ls=':')#		#	if i==len(markers): #This resets the colors#		i=0#	#This may eventully be hard-coded... after error analysis is determined#	z_plot=z_density##	z_L=z_plot[0]#	z_R=z_plot[-1]#        if (Bjerrum==1. and sig==1.0) or (sig==1.0):#		if ze=='0.000':#			z_L=-250.08201#			z_R=250.08195#		if ze=='0.250':#			z_L=-250.08148#			z_R=250.08200#		if ze=='0.500':#			z_L=-250.08114#			z_R=250.08153#		if ze=='0.750':#			z_L=-250.08287#			z_R=250.08213#		if ze=='1.000':#			z_L=-250.08211#			z_R=250.08148#		if ze=='1.250':#			z_L=-250.08214#			z_R=250.08248#		if ze=='1.500':#			z_L=-250.08290#			z_R=250.08168#		if ze=='1.750':#			z_L=-250.08248#			z_R=250.08234#		if ze=='2.000':#			z_L=-250.08204#			z_R=250.08198#		if ze=='2.500':#			z_L=-250.08314#			z_R=250.08293#		if ze=='2.750':#			z_L=-250.08260#			z_R=250.08295#		if ze=='3.000':#			z_L=-250.08295#			z_R=250.08265#		if ze=='3.500':#			z_L=-250.08335#			z_R=250.08318#		if ze=='4.000':#			z_L=-250.08377#			z_R=250.08401#		if ze=='5.000':#			print '\t\tFake Values used for z_wall of ions'#			z_L=-250.08503#			z_R=250.08510#        elif Bjerrum==0.1 and sig==5.4:#		if ze=='0.000':#			z_L=-250.08319#			z_R=250.08310#		if ze=='0.250':#			z_L=-250.08285#			z_R=250.08370#		if ze=='0.500':#			z_L=-250.08413#			z_R=250.08302#		if ze=='0.750':#			z_L=-250.08336#			z_R=250.08319#		if ze=='1.000':#			z_L=-250.08324#			z_R=250.08301#		if ze=='1.250':#			z_L=-250.08381#			z_R=250.08328#		if ze=='1.500':#			z_L=-250.08391#			z_R=250.08393#        elif Bjerrum==0.1 and sig==9.6:#		if ze=='0.000':#			z_L=-250.08257#			z_R=250.08213#		if ze=='0.250':#			z_L=-250.08207#			z_R=250.08240#		if ze=='0.500':#			z_L=-250.08293#			z_R=250.08242#		if ze=='0.750':#			z_L=-250.08247#			z_R=250.08265#		if ze=='1.000':#			z_L=-250.08233#			z_R=250.08224#		if ze=='1.250':#			z_L=-250.08310#			z_R=250.08275#		if ze=='1.500':#			z_L=-250.08269#			z_R=250.08320#		if ze=='1.750':#			z_L=-250.08322#			z_R=250.08303#		if ze=='2.000':#			z_L=-250.08300#			z_R=250.08350#	z_plot[0]=(z_L+0.5*L_z)/L_z#	z_plot[-1]=(z_R+0.5*L_z)/L_z#	if i==0:#		z_walls=[z_L,z_R]#		mu_ex_wall=np.zeros(len(z_density),dtype=float)#		k=-1#		for z in z_walls:#			k+=1#			if z<=z_wall:#				zt=z#				mu_ex_wall[0]=eps_wall*((2./15.)*(1.165/zt)**9.-(1.165/zt)**3.-(2./15.)*((2./5.)**(-1./6.)*1.)**9.+((2./5.)**(-1./6.)*1.)**3.)#			if z>=L_z:#			   	zt=(L_z+z_wall)-z#				mu_ex_wall[-1]=eps_wall*((2./15.)*(1.165/zt)**9.-(1.165/zt)**3.-(2./15.)*((2./5.)**(-1./6.)*1.)**9.+((2./5.)**(-1./6.)*1.)**3.)#	mu_ex_wall=np.zeros(len(z_density),dtype=float)#	muex_EC_p=-(np.log(Np)+np.array(Psi[:-1])+EV+mu_ex_wall)#	muex_EC_p_bulk=np.mean(muex_EC_p[len(muex_EC_p)/2-2:len(muex_EC_p)/2+2])#	muex_EC_m=-(np.log(Nm)-np.array(Psi[:-1])+EV+mu_ex_wall)#	muex_EC_m_bulk=np.mean(muex_EC_m[len(muex_EC_m)/2-2:len(muex_EC_m)/2+2])#	ax1.errorbar(np.array(z_plot[1:])*(L_z/characteristic_length),muex_EC_p[1:]-muex_EC_p_bulk,yerr=None,marker='+',ms=7.0,color=colors[i],ls='-',label=r'$\Sigma$'+' = ' + str(round(Sigma_s,4)))#	ax2.errorbar(np.array(z_plot[1:])*(L_z/characteristic_length),muex_EC_m[1:]-muex_EC_m_bulk,yerr=None,marker='_',ms=7.0,color=colors[i],ls='--',label=r'$\~ \zeta$'+' = ' + str(round(zd,3)))#	muex_EC_pS.append(muex_EC_p)#	muex_EC_mS.append(muex_EC_m)#    ax1.set_ylabel(r'$\~\mu_{ex,+}^{EC}$',size='x-large') #    ax2.set_ylabel(r'$\~\mu_{ex,-}^{EC}$',size='x-large') #    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') #      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.25)##      plt.ylim(ymin=-0.75)##      plt.ylim(ymax=3.0)#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')#      ax2.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')##      ax1.set_xlim(0,40)##      ax1.set_ylim(-4,1)##      ax2.set_xlim(0,40)##      ax2.set_ylim(-1,2)##      if sig==8:##      	ax1.set_xlim(0,10)##      	ax2.set_xlim(0,10)##      plt.xlim(xmin=0.0)##      plt.xlim(xmax=25.0)##      if np.mean(LDs)>16:##      	plt.xlim(xmax=10.0)##      plt.ylim(ymin=-2.5)##      plt.ylim(ymax=3.0)##    ax1.legend(loc=0) ##    ax2.legend(loc=0) #    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    #plt.show()#    plt.close()#      #Finished plottting excess chemical potential DUE TO ELECTROSTATICS = f(z)#    print 'Determining k-analysis on muex^EC_pm(z)...'#    i=-1#    fig=plt.figure()##    ax1=fig.add_subplot(111)##    fig.subplots_adjust(right=0.90)#    ax1=fig.add_subplot(211)#    ax2=fig.add_subplot(212)#    for (ex_p,ex_m,Sigma_s,zd) in zip(muex_EC_pS,muex_EC_mS,SIGMAS,zeta_data):#	i+=1#	#	if i==0:#		graphname = 'k_of_z' + '.pdf'#		exEC_max_lp=np.array(muex_EC_pS[-1])#		exEC_max_lm=np.array(muex_EC_mS[-1])#		ihalf=len(exEC_max_lp)/2#		print ihalf ##Need this to only perform analysis for half the box!#		#		##		ax1.errorbar(np.array(z_plot)*(L_z/characteristic_length),np.zeros(len(z_plot)),yerr=None,color='k',ls=':')##		ax2.errorbar(np.array(z_plot)*(L_z/characteristic_length),np.zeros(len(z_plot)),yerr=None,color='k',ls=':')#		#	if i==len(markers): #This resets the colors#		i=0#	muex_EC_p_bulk=np.mean(ex_p[len(ex_p)/2-2:len(ex_p)/2+2])#	muex_EC_m_bulk=np.mean(ex_m[len(ex_m)/2-2:len(ex_m)/2+2])#	print muex_EC_p_bulk,muex_EC_m_bulk#	ax1.errorbar(np.array(z_density)*(L_z/characteristic_length),(ex_p-muex_EC_p_bulk)/exEC_max_lp,yerr=None,marker='+',ms=7.0,color=colors[i],ls='-',label=r'$\Sigma$'+' = ' + str(round(Sigma_s,4)))#	ax2.errorbar(np.array(z_density)*(L_z/characteristic_length),(ex_m-muex_EC_m_bulk)/exEC_max_lm,yerr=None,marker='_',ms=7.0,color=colors[i],ls='--',label=r'$\~ \zeta$'+' = ' + str(round(zd,3)))#    ax1.set_ylabel(r'$CHANGE THESE \~\mu_{ex,+}^{EC}$',size='x-large') #    ax2.set_ylabel(r'$CHANGE THESE \~\mu_{ex,-}^{EC}$',size='x-large') #    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') #      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.25)##      plt.ylim(ymin=-0.75)##      plt.ylim(ymax=3.0)#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')#      ax2.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')##      ax1.set_xlim(0,40)##      ax1.set_ylim(-4,1)##      ax2.set_xlim(0,40)##      ax2.set_ylim(-1,2)#      if sig==8:#      	ax1.set_xlim(0,10)##      	ax2.set_xlim(0,10)##    ax1.legend(loc=0) ##    ax2.legend(loc=0) #    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    #plt.show()#    plt.close()#      #Finished plottting excess chemical potential DUE TO ELECTROSTATICS = f(z)    ##This plots mu_excess(z) for simulation and GC theory#    Bikerman='yes'#    Bikerman='no'#    CarnahanStarling='yes'#    CarnahanStarling='no'#    if nonDim=='yes':#      print 'Plotting mu_excess(z)...'#    if Bikerman=='yes':#		print '\t\t...with Bikerman theory...'#		#Note to user: Bikerman theory must already be evaluated using MATLAB code, which is in ~/sims/PBik_Solver.m#    if CarnahanStarling=='yes':#	      print '\t...with Carnahan-Starling theory...'#    i=-1#    fig=plt.figure()#    fig.subplots_adjust(right=0.85)#    ax1=fig.add_subplot(111)#    for (Nm,Np,M_T,P_T,Sigma_s,ze,n0) in zip(N_minusS,N_plusS,M_Theory,P_Theory,SIGMAS,zetas,n0s):#		i+=1#		if i==len(markers): #This resets the colors#			i=0#			#		if i==0:#			graphname = 'mu_ex_z' + '.pdf'#			ylabel=r'$\~\mu_{ex}$'#			z_walls=list(np.linspace(0.01,z_wall,50))+list(np.linspace(L_z,(L_z+z_wall-0.01),50))#			mu_ex_wall=[]#			for z in z_walls:#				if z<=z_wall:#					zt=z#					mu_ex_wall.append(eps_wall*((2./15.)*(1.165/zt)**9.-(1.165/zt)**3.-(2./15.)*((2./5.)**(-1./6.)*1.)**9.+((2./5.)**(-1./6.)*1.)**3.))#				if z>=L_z:#				   	zt=(L_z+z_wall)-z#					mu_ex_wall.append(eps_wall*((2./15.)*(1.165/zt)**9.-(1.165/zt)**3.-(2./15.)*((2./5.)**(-1./6.)*1.)**9.+((2./5.)**(-1./6.)*1.)**3.))#			ax1.plot(np.array(z_walls)/characteristic_length,mu_ex_wall,color='k',lw=1.0,ls='-',label=r'$\tilde \mu_{ex}^{wall}$')#		mu_ex_z=-0.5*np.log(np.array(Nm)*np.array(Np))#		#This may eventully be hard-coded... after error analysis is determined#		z_plot=z_density#		z_L=z_plot[0]#		z_R=z_plot[-1]#                if Bjerrum==1. and sig==1.0:#			if ze=='0.000':#				z_L=-250.08201#				z_R=250.08195#			if ze=='0.250':#				z_L=-250.08148#				z_R=250.08200#			if ze=='0.500':#				z_L=-250.08114#				z_R=250.08153#			if ze=='0.750':#				z_L=-250.08287#				z_R=250.08213#			if ze=='1.000':#				z_L=-250.08211#				z_R=250.08148#			if ze=='1.250':#				z_L=-250.08214#				z_R=250.08248#			if ze=='1.500':#				z_L=-250.08290#				z_R=250.08168#			if ze=='1.750':#				z_L=-250.08248#				z_R=250.08234#			if ze=='2.000':#				z_L=-250.08204#				z_R=250.08198#			if ze=='2.500':#				z_L=-250.08314#				z_R=250.08293#			if ze=='2.750':#				z_L=-250.08260#				z_R=250.08295#			if ze=='3.000':#				z_L=-250.08295#				z_R=250.08265#			if ze=='3.500':#				z_L=-250.08335#				z_R=250.08318#			if ze=='4.000':#				z_L=-250.08377#				z_R=250.08401#			if ze=='5.000':#				print '\t\tFake Values used for z_wall of ions'#				z_L=-250.08503#				z_R=250.08510#                elif Bjerrum==0.1 and sig==5.4:#			if ze=='0.000':#				z_L=-250.08319#				z_R=250.08310#			if ze=='0.250':#				z_L=-250.08285#				z_R=250.08370#			if ze=='0.500':#				z_L=-250.08413#				z_R=250.08302#			if ze=='0.750':#				z_L=-250.08336#				z_R=250.08319#			if ze=='1.000':#				z_L=-250.08324#				z_R=250.08301#			if ze=='1.250':#				z_L=-250.08381#				z_R=250.08328#			if ze=='1.500':#				z_L=-250.08391#				z_R=250.08393#                elif Bjerrum==0.1 and sig==9.6:#			if ze=='0.000':#				z_L=-250.08257#				z_R=250.08213#			if ze=='0.250':#				z_L=-250.08207#				z_R=250.08240#			if ze=='0.500':#				z_L=-250.08293#				z_R=250.08242#			if ze=='0.750':#				z_L=-250.08247#				z_R=250.08265#			if ze=='1.000':#				z_L=-250.08233#				z_R=250.08224#			if ze=='1.250':#				z_L=-250.08310#				z_R=250.08275#			if ze=='1.500':#				z_L=-250.08269#				z_R=250.08320#			if ze=='1.750':#				z_L=-250.08322#				z_R=250.08303#			if ze=='2.000':#				z_L=-250.08300#				z_R=250.08350#		z_plot[0]=(z_L+0.5*L_z)/L_z#		z_plot[-1]=(z_R+0.5*L_z)/L_z#		###Untested code directly below!!! 07/14/11 09:03:03 #		if ze=='1.500':#			colors[i]='k'#		ax1.errorbar(np.array(z_plot)*(L_z/characteristic_length),mu_ex_z-np.mean(mu_ex_z[len(mu_ex_z)/2-2:len(mu_ex_z)/2+2]),yerr=None,marker='x',ms=5.0,color=colors[i],ls='None',label=r'$\Sigma$'+' = ' + str(round(Sigma_s,3)))#		if Bikerman=='yes':#		  Bik_file='_Bik_zeta_' + ze + '.txt'#		  if i==0: #This reasonably assumes the Bikerman plots all share the same x-axis#		      x_Bik=[[float(x) for x in line.split()] for line in file('x_Bik.txt',"r").readlines()]#		      x_Bik=np.array(x_Bik)*lam_D/characteristic_length#		  c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]#		  co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]#		  ax1.plot(x_Bik[0],-0.5*np.log(np.array(co_Bik[0])*np.array(c_Bik[0])),color=colors[i],lw=1.5,ls='--') ##		  print 'Validating Bik'##		  phi_total=(np.array(co_Bik[0])+np.array(c_Bik[0]))*2*n0*sig_HS**3##		  mu_ex_Bik_verify=-np.log(1-phi_total)##		  ax1.plot(np.array(x_Bik[0]),mu_ex_Bik_verify-mu_ex_Bik_verify[len(mu_ex_Bik_verify)/2],color=colors[i],lw=1.5,ls='-') #		if CarnahanStarling=='yes':#		  CS_file='_CS_zeta_' + ze + '.txt'#		  if i==0: #This reasonably assumes the Bikerman plots all share the same x-axis#		      x_CS=[[float(x) for x in line.split()] for line in file('x_CS.txt',"r").readlines()]#      		      x_CS=np.array(x_CS)*lam_D/characteristic_length#		  c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]#		  co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]	      #		  ax1.plot(x_CS[0],-0.5*np.log(np.array(co_CS[0])*np.array(c_CS[0])),color=colors[i],lw=1.5,ls='-.') 				  ##		  print 'Validating CS'##		  phi_total=(np.array(co_CS[0])+np.array(c_CS[0]))*2*n0*(np.pi/6)*sig_HS**3##  		  mu_ex_CS_verify=phi_total*(8-9*phi_total+3*phi_total**2)*((1-phi_total)**-3)####		  ax1.plot(np.array(z_density)*(L_z/characteristic_length),mu_ex_CS_verify-np.mean(mu_ex_CS_verify[len(mu_ex_CS_verify)/2-2:len(mu_ex_CS_verify)/2+2]),color=colors[i],lw=1.5,ls='-')##		  ax1.plot(np.array(x_CS[0])*(lam_D/characteristic_length),mu_ex_CS_verify-np.mean(mu_ex_CS_verify[len(mu_ex_CS_verify)/2-2:len(mu_ex_CS_verify)/2+2]),color=colors[i],lw=1.5,ls='-')#    ax1.set_ylabel(ylabel,size='x-large') #    if characteristic_length==L_z:#      ax1.set_xlabel(r'$z/L_{box}$',size='x-large') #      plt.xlim(xmin=0.0)#      plt.xlim(xmax=0.25)#      plt.ylim(ymin=-0.75)#      plt.ylim(ymax=3.0)#    elif characteristic_length==sig:#      ax1.set_xlabel(r'$z/ \sigma_{WCA}$',size='x-large')#      plt.xlim(xmin=0.0)#      plt.xlim(xmax=25.0)#      if sig==8:#      	ax1.set_xlim(0,10)#      if np.mean(LDs)>16:#      	plt.xlim(xmax=10.0)#      plt.ylim(ymin=-0.25)#      plt.ylim(ymax=3.0)##    string = str(round(np.mean(LDs),2))+','+str(Bjerrum)+','+str(sig)+')'##    ax1.title('(lamD,lamB,sigma) = ('+ string,size='x-large')##    ax1.legend(loc=1) #    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    #plt.show()#    plt.close()      ##Finished plottting excess chemical potential = f(z)#####	WARNING: THIS FUNCTION MAY HAVE A BUG, NOT SURE WAS FOUND WHEN DOING SOMETHING PARTICULARLY SPECIAL... - 07/14/11 08:57:15     #    print 'Plotting Shell Capacitance...'      #This must be re-worked to find the slope using adjacent data points... Easy enough.#    graphname = 'DifCap_inprogress' + '.pdf'#    C_dif_Shell=[]#    ##This (reasonably) assumes that the thermal energy is equal to one.#    kBT=1.#    beta=1./kBT#    #Take the average of the magnitude of the zeta-potentials#    zeta_data=[np.mean(abs(zL),abs(zR)) for (zL,zR) in zip(zeta_dataL,zeta_dataR)]#    fig=plt.figure()#    ax1=fig.add_subplot(111)#    dip_vars=[]#    for (dp,dp_sq,Sigma_s,ze,LD) in zip(dipole_avgs,dipole_avg_sqs,SIGMAS,zeta_data,LDs):#      dp_var=beta/dielectric*(dp_sq-dp**2.)#      #dp_var=-83131.378#      #print '%1.1f\t%1.1f' % (ze,dp_var)#      C_dif=(area*dielectric/L_z)*(1-(beta/(area*L_z))*dp_var)**-1#      #dip_vars.append(dp_sq-dp**2.)#      #C_tot=(area*dielectric/L_z)*(1-dp/(Sigma_s*area*L_z))**-1 #Don't really think this tells anything#      #print C_tot,Sigma_s/ze#      C_dif_Shell.append(C_dif)#      C_theory=(dielectric*area/(2*LD))*np.cosh(ze/2)#      print ze,C_theory#      #ax1.errorbar(ze,C_dif,yerr=None,marker=markers[i],ms=5.0,color='orange',ls='None',label=r'$\Sigma$'+' = '+ str(round(Sigma_s,3)))#      ax1.errorbar(ze,C_theory,yerr=None,marker=markers[i],ls='-',color='b')#    #Assemble GC theory#    mean_LD=np.mean(LDs)#    zeta_GC=np.linspace(0,np.max(zeta_data))#    C_dif_GC=[(dielectric/mean_LD)*np.cosh(zeta/2.) for zeta in zeta_GC]#    #C_dif_GC=[(dielectric/mean_LD)*np.cosh(zeta/2.) for zeta in zeta_GC]#    #ax1.errorbar(zeta_GC,C_dif_GC,yerr=None,ls='-',color='b')#  #    ax1.set_xlabel(r'$\tilde \zeta$',size='x-large') #    ax1.set_ylabel(r'$C^{\prime}(\tilde \zeta)$',size='x-large')#    #plt.title('TITLE')#    #plt.xlim(xmin=0.0)#    #plt.xlim(xmax=1.0)#    #plt.ylim(ymin=-0.05)#    #plt.ylim(ymax=2.)  #    #ax1.legend(loc=0) #    #plt.show()#    plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    plt.close()    #    ####For Root Mean Squared deviation of theory from data:#    print 'Calculating RMS deviation for all ND data...'#    Bikerman='yes'#  #    Bikerman='no'#    if Bikerman=='yes':#	  print '\t...including Bikerman theory...'#    CarnahanStarling='yes'#  #    CarnahanStarling='no'#    if CarnahanStarling=='yes':#	  print '\t...including Carnahan-Starling theory...'    #    #    ###Obtain theory evaluated at z_positions for simulated data (simZ)#    i=-1#    PB_voltS,PB_pS,PB_mS,PB_fS=[],[],[],[]#    Bik_voltS,Bik_pS,Bik_mS,Bik_fS=[],[],[],[]#    CS_voltS,CS_pS,CS_mS,CS_fS=[],[],[],[]#    for (V,lam_D,ze,n0) in zip(Volts,LDs,zetas,n0s):#	  i+=1#	  if nonDim=='no': #Since I want non-dimmed values#	    z_positions=[z/characteristic_length for z in z_positions] #NonDim distances#	    z_density=[z/characteristic_length for z in z_density] #NonDim distances#	  #	  v_T_cat,v_T_ano=[],[]#	  zeta_measL=V[0]  #Shit on a stick, I think this is supposed to be V[0]...#	  zeta_measR=V[-1]#	  sign=1#	  for z in z_positions[:len(z_positions)/2]:#		  v_T_cat.append(-np.log(GC_density(z,lam_D/characteristic_length,zeta_measL,n0,sign)/n0))#		  v_T_ano.append(-np.log(GC_density(z,lam_D/characteristic_length,zeta_measR,n0,sign)/n0))#	  if len(z_positions) % 2: #If there are an even number of z_positions#		  v_T_cat.append(-np.log(GC_density(z_positions[len(z_positions)/2],lam_D/characteristic_length,zeta_measL,n0,sign)/n0))#		  z=z_positions[len(z_positions)/2]#	  v_T_ano.reverse()#	  volt_theory=v_T_cat+v_T_ano#	  PB_voltS.append(-np.array(volt_theory))#	  GCT_c_L,GCT_co_L=[],[]#	  GCT_c_R,GCT_co_R=[],[]#	  sign=1#	  for z in z_density:#		  if z>=0.5: #At this point, you should be using PBT from the other electrode#			  sign = -1 #, which this does.#			  z = 1 - z#			  z=z-z_wall/characteristic_length#			  GCT_co_L.append(GC_density(z,lam_D/characteristic_length,zeta_measL,n0,sign)/n0) #For Nplus#			  GCT_c_R.append(GC_density(z,lam_D/characteristic_length,zeta_measR,n0,sign)/n0) #For Nminus#		  else:#			  z=z-z_wall/characteristic_length#			  GCT_c_L.append(GC_density(z,lam_D/characteristic_length,zeta_measL,n0,sign)/n0) #For Nminus    	    		#			  GCT_co_R.append(GC_density(z,lam_D/characteristic_length,zeta_measR,n0,sign)/n0) #For Nplus#	  GCT_co_L.reverse()#	  GCT_co_R.reverse()#	  rhoP=GCT_co_L+GCT_c_R#	  rhoM=GCT_c_L+GCT_co_R#	  PB_pS.append(rhoP)#	  PB_mS.append(rhoM)#	  PB_fS.append([(-x+y) for (x,y) in zip(rhoM,rhoP)])#	  if Bikerman=='yes':#	    Bik_file='_Bik_at_simZ_zeta_' + ze + '.txt'#	    volt_Bik=[[float(x) for x in line.split()] for line in file('volt' + Bik_file,"r").readlines()]#	    Bik_voltS.append(volt_Bik[0])#	    c_Bik=[[float(x) for x in line.split()] for line in file('counter' + Bik_file,"r").readlines()]#	    Bik_mS.append(c_Bik[0])#	    co_Bik=[[float(x) for x in line.split()] for line in file('co' + Bik_file,"r").readlines()]#	    Bik_pS.append(co_Bik[0])#	    Bik_fS.append(np.array(co_Bik[0])-np.array(c_Bik[0]))#	  if CarnahanStarling=='yes':#	    CS_file='_CS_at_simZ_zeta_' + ze + '.txt'#	    volt_CS=[[float(x) for x in line.split()] for line in file('volt' + CS_file,"r").readlines()]#	    CS_voltS.append(volt_CS[0])#	    c_CS=[[float(x) for x in line.split()] for line in file('counter' + CS_file,"r").readlines()]#	    CS_mS.append(c_CS[0])#	    co_CS=[[float(x) for x in line.split()] for line in file('co' + CS_file,"r").readlines()]#	    CS_pS.append(co_CS[0])#	    CS_fS.append(np.array(co_CS[0])-np.array(c_CS[0]))#    i=-1#    for (Nm,Np,V,PB_v,PB_p,PB_m,PB_f,Bik_v,Bik_p,Bik_m,Bik_f,CS_v,CS_p,CS_m,CS_f,n0,Sig_s) in zip(N_minusS,N_plusS,Volts,PB_voltS,PB_pS,PB_mS,PB_fS,Bik_voltS,Bik_pS,Bik_mS,Bik_fS,CS_voltS,CS_pS,CS_mS,CS_fS,n0s,SIGMAS):#	  i+=1#	    ##Calculate normalized densities#	  Nm=[nm/(area*L_bin*n0) for nm in Nm]#	  Np=[np/(area*L_bin*n0) for np in Np]#	  Nf=[(npl-nm) for (npl,nm) in zip(Np,Nm)]#	  PB_volt_RMS=(sum([(data-theory)**2 for (data,theory) in zip(V,PB_v)])/len(V))**(0.5)#	  PB_p_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Np,PB_p)])/len(Np))**(0.5)#	  PB_m_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Nm,PB_m)])/len(Nm))**(0.5)#	  PB_f_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Nf,PB_f)])/len(Nf))**(0.5)#	  Bik_volt_RMS=(sum([(data-theory)**2 for (data,theory) in zip(V,Bik_v)])/len(V))**(0.5)#	  Bik_p_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Np,Bik_p)])/len(Np))**(0.5)#	  Bik_m_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Nm,Bik_m)])/len(Nm))**(0.5)#	  Bik_f_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Nf,Bik_f)])/len(Nf))**(0.5)#	  CS_volt_RMS=(sum([(data-theory)**2 for (data,theory) in zip(V,CS_v)])/len(V))**(0.5)#	  CS_p_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Np,CS_p)])/len(Np))**(0.5)#	  CS_m_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Nm,CS_m)])/len(Nm))**(0.5)#	  CS_f_RMS=(sum([(data-theory)**2 for (data,theory) in zip(Nf,CS_f)])/len(Nf))**(0.5)#	  #	  print '%1.4f\t%1.4f\t%1.4f\t%1.4f\t%1.4f' % (Sig_s,PB_volt_RMS,PB_p_RMS,PB_m_RMS,PB_f_RMS)#	  print '%1.4f\t%1.4f\t%1.4f\t%1.4f\t%1.4f' % (Sig_s,Bik_volt_RMS,Bik_p_RMS,Bik_m_RMS,Bik_f_RMS)#	  print '%1.4f\t%1.4f\t%1.4f\t%1.4f\t%1.4f' % (Sig_s,CS_volt_RMS,CS_p_RMS,CS_m_RMS,CS_f_RMS)	#if i==0:	  #print r"\begin{tabular}{|c|c|c|c|c|c|}"	#print '\hline'	#print r"$\Sigma_{s}$ & $\tilde \zeta_{cathode}$ & $\tilde \zeta_{anode}$ & $\lambda_{D}$ & $n_{bulk}$ & $N$ \\ \hline"	#for (Sig_s,zL,zR,N_p,N_m,n0,lam_D) in zip(SIGMAS,zeta_dataL,zeta_dataR,N_plusS,N_minusS,n0s,LDs):	    #print r"%1.3f & %1.2f & %1.2f & %1.2f & %1.2e & %i \\ \hline" % (Sig_s,zL,zR,lam_D,n0,int(round(np.sum(N_p)+np.sum(N_m))))    print 'the filename is ',filename    print 'Plotting CDFs...'    graphname = 'CDFs_test' + '.pdf'    fig=plt.figure()    ax1=fig.add_subplot(111)    zeta_data=[np.mean(abs(zL),abs(zR)) for (zL,zR) in zip(zeta_dataL,zeta_dataR)]#    zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500']        i=-1#    for (ze,Sigma_s,lam_D,z_D) in zip(zetas,SIGMAS,LDs,zeta_data):    for ze in zetas:    	#This all needs to be cleaned up, more or less.  - 12/14/10 10:52:33   	    	i+=1    	filename='1000_ss_zeta_' + ze + '_50_CDF_Output.txt'    	print filename    	z_50=np.array([[x for x in line.split()] for line in file(filename,"r").readlines()])    	if i==len(colors): #This resets the colors    		i=0	##Trim incoming data	if i==0: #This reasonably assumes that all CDF files have the same r bins	  r_bins=z_50[:,0]	  r_bins=[float(x) for x in r_bins[1:]]        	#g_AA=z_50[:,1]	#g_AA=[float(x) for x in g_AA[1:]]	#g_AC=z_50[:,2]	#g_AC=[float(x) for x in g_AC[1:]]	g_CC=z_50[:,3]	g_CC=[float(x) for x in g_CC[1:]]#	print g_CC	line_style='-'	markersize=0	if ze=='1.500':		colors[i]='k'	#	##Unhighlight for steric CDFs#	z_c=-np.log(sig**3/(8.*np.pi*0.65*Bjerrum_temp*lam_D**2))#	if z_D<z_c:#		line_style='--'#		markersize=0.5	###Unhighlight for electrostatic CDFs#	Xi=2.*np.pi*(Bjerrum**2)*Sigma_s#	print Xi,Sigma_s,ze#	if Xi>=1:#		line_style='--'#		markersize=0.5	  	ax1.errorbar(r_bins,g_CC,yerr=None,ls=line_style,lw=2.0,ms=markersize,color=colors[i])#,label=r'$\Sigma$'+' = ' + str(round(Sigma_s,4)))    ax1.plot(r_bins,np.ones(len(r_bins)),ls=':',color='k')    ax1.set_xlabel(r'$r$',size='x-large')     ax1.set_ylabel(r'$g_{c-c}$',size='x-large')    plt.title(r'$\lambda_B = $'+str(Bjerrum))    plt.xlim(xmin=0.0)#    plt.xlim(xmax=np.max(r_bins))    plt.ylim(ymin=-0.05)    plt.ylim(ymax=2.)  #    ax1.legend(loc=0)     plt.savefig(graphname, dpi=None, facecolor='w', edgecolor='w',orientation='portrait', papertype=None, format=None, transparent=False)   #    plt.show()    plt.close()    ##Entire print out of all relevant model parameters    #print '\nSig_s,zeta_Left,zeta_Right,<p>,<p^2>,N_tot,rho_bulk,lam_D,lam_B,sig_WCA,L_box,A_xy,eps,beta=1/(kT_setpoint)'    #for (Sig_s,zL,zR,dp,dp_sq,N_p,N_m,n0,lam_D) in zip(SIGMAS,zeta_dataL,zeta_dataR,dipole_avgs,dipole_avg_sqs,N_plusS,N_minusS,n0s,LDs):      #print '%1.5f,%1.3f,%1.3f,%1.4f,%1.3f,%i,%1.3e,%1.3f,%1.2f,%1.2f,%i,%1.3f,%1.2f,%i' % (Sig_s,zL,zR,dp,dp_sq,int(round(np.sum(N_p)+np.sum(N_m))),n0,lam_D,Bjerrum,sig,L_z,area,dielectric,1)          #print 'Sig_s\t\tzeta_Left\tzeta_Right\t<p>\t\t\t<p^2>\t\t\tN_tot\t\trho_bulk\tlam_D\t\tlam_B\t\tsig\t\tL_z\t\tA_xy\t\t\teps\t\tbeta'    #for (Sig_s,zL,zR,dp,dp_sq,N_p,N_m,n0,lam_D) in zip(SIGMAS,zeta_dataL,zeta_dataR,dipole_avgs,dipole_avg_sqs,N_plusS,N_minusS,n0s,LDs):      #print '%1.5f\t\t%1.3f\t\t%1.3f\t\t%1.4f\t\t%1.3f\t\t%i\t\t%1.3f\t\t%1.3f\t\t%1.2f\t\t%1.2f\t\t%i\t\t%1.3f\t\t%1.2f\t\t%i' % (Sig_s,zL,zR,dp,dp_sq,int(round(np.sum(N_p)+np.sum(N_m))),n0,lam_D,Bjerrum,sig,L_z,area,Bjerrum**-1,1)      #    print r"\begin{tabular}{|c|c|c|c|c|c|}"#    print '\hline'#    print r"$\Sigma_{s}$ & $\tilde \zeta_{cathode}$ & $\tilde \zeta_{anode}$ & $\lambda_{D}$ & $n_{bulk}$ & $N$ \\ \hline"    #for (Sig_s,zL,zR,N_p,N_m,n0,lam_D) in zip(SIGMAS,zeta_dataL,zeta_dataR,N_plusS,N_minusS,n0s,LDs):      #print r"%1.3f & %1.2f & %1.2f & %1.2f & %1.2e & %i \\ \hline" % (Sig_s,zL,zR,lam_D,n0,int(round(np.sum(N_p)+np.sum(N_m))))    #for (ze,z,LD) in zip(zetas,zeta_data,LDs):      #print ze,z,LD#    ##For LamD +/- value#    import numpy as np#    print sum(LDs)/len(LDs),np.max(sum(LDs)/len(LDs)-np.min(LDs),np.max(LDs)-sum(LDs)/len(LDs))#    print 2*np.mean(n0s)*(np.pi/6.)*sig_HS**3,2*np.mean(n0s)*sig_HS**3#    import numpy as np#####   Bikerman MATLAB commands.#    for (ze,zL,zR,lam_D,n0) in zip(zetas,zeta_dataL,zeta_dataR,LDs,n0s):#	  co_text='\'co_Bik_zeta_'+ze+'.txt\''#	  c_text='\'counter_Bik_zeta_'+ze+'.txt\''#	  volt_text='\'volt_Bik_zeta_'+ze+'.txt\''##	  print 'PBik_Solver_zLzR(%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,lam_D/500.,2*n0*sig_HS**3,co_text,c_text,volt_text)#  	  print 'MPB_Bik(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 2*n0*sig_HS**3,co_text,c_text,volt_text)##    ##Carnahan-Starling commands#    i=-1#    for (ze,zL,zR,lam_D,n0) in zip(zetas,zeta_dataL,zeta_dataR,LDs,n0s):#    	  i+=1#	  co_text='\'co_CS_zeta_'+ze+'.txt\''#	  c_text='\'counter_CS_zeta_'+ze+'.txt\''#  	  volt_text='\'volt_CS_zeta_'+ze+'.txt\''#  	  if i==0:#	  	  print 'MPB_CS(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 2*n0*(np.pi/6.)*sig_HS**3,co_text,c_text,volt_text)#	  else:#	  	  print 'MPB_CS(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 2*n0*(np.pi/6.)*sig_HS**3,co_text,c_text,volt_text)#    i=-1#    for (ze,zL,zR,lam_D) in zip(zetas,zeta_dataL,zeta_dataR,LDs):#    	  i+=1#  	  volt_text='\'volt_MPBoltz_zeta_'+ze+'.txt\''##  	  MP_Boltz(zetaL,zetaR,Lz,LD,corr_len,volt_text)#	  print 'MP_Boltz(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s);\n' % (zL, zR, 500.,lam_D, Bjerrum,volt_text)#    i=-1#    ##For PB solutions for r5, where DLs are overlapping#    for (ze,zL,zR,lam_D,n0) in zip(zetas,zeta_dataL,zeta_dataR,LDs,n0s):#    	  i+=1#	  co_text='\'co_PB_zeta_'+ze+'.txt\''#	  c_text='\'counter_PB_zeta_'+ze+'.txt\''#  	  volt_text='\'volt_PB_zeta_'+ze+'.txt\''#  	  if i==0:#	  	  print 'MPB_CS(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 0*2*n0*(np.pi/6.)*sig_HS**3,co_text,c_text,volt_text)#	  else:#	  	  print 'MPB_CS(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 0*2*n0*(np.pi/6.)*sig_HS**3,co_text,c_text,volt_text)##   ##Bikerman MATLAB commands.#    for (ze,zL,zR,lam_D,n0) in zip(zetas,zeta_dataL,zeta_dataR,LDs,n0s):#	  co_text='\'co_Bik_at_simZ_zeta_'+ze+'.txt\''#	  c_text='\'counter_Bik_at_simZ_zeta_'+ze+'.txt\''#	  volt_text='\'volt_Bik_at_simZ_zeta_'+ze+'.txt\''#	  print 'PBik_Solver_zLzR_RMS(%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,lam_D,2*n0*sig_HS**3,co_text,c_text,volt_text)##    #Carnahan-Starling commands##    i=-1#    for (ze,zL,zR,lam_D,n0) in zip(zetas,zeta_dataL,zeta_dataR,LDs,n0s):#          i+=1#	  co_text='\'co_CS_at_simZ_zeta_'+ze+'.txt\''#	  c_text='\'counter_CS_at_simZ_zeta_'+ze+'.txt\''#	  volt_text='\'volt_CS_at_simZ_zeta_'+ze+'.txt\''#	  if i==0:#	  	  print 'MPB_CS_RMS(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 2*n0*(np.pi/6.)*sig_HS**3,co_text,c_text,volt_text)#	  else:#	  	  print 'MPB_CS_RMS(%1.5f,%1.5f,%1.5f,%1.5f,%1.5f,%s,%s,%s);\n' % (zL,zR,500.,lam_D, 2*n0*(np.pi/6.)*sig_HS**3,co_text,c_text,volt_text)#    ##MF Carnahan-Starling commands#    phi_bulkS=[]#    for (ze,n0,LD) in zip(zetas,n0s,LDs):#        phi_bulkS.append(2*n0*(np.pi/6)*sig_HS**3)#    print 'MF_CS_Compare(%1.5f,%1.5f,%1.1f,%1.1f);\n' % (np.mean(phi_bulkS),np.mean(LDs),Bjerrum,sig)    return####################Save for later use##Qsub management below#for i in range(390,407):  #print 'qdel %i.c4hdn-la' % i#for (ze,i) in zip(zetas,range(0,20)):  ##print 'qsub %i_3_%1.2f' % (i,float(ze))  #print 'qsub %i_LB_0.1_%1.2f' % (i,float(ze))  #print 'qsub %i_LB_0.1_sig_1.0' % i  #print 'qsub %i_LB_10.pbs' % i  #count=0#n_obs=0#count2=0#for x in np.arange(2000):    #n_obs+=1    #if n_obs<=500:	#count+=1    #elif n_obs>500 and n_obs<=1500:	#count2+=1###############################r3_Phi_0.185Bjerrum=0.1r_ion=2.70M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#r4_Phi_0.185Bjerrum=0.1r_ion=4.80M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#sig=7Bjerrum=1.0r_ion=3.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.100.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.200.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.300.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.600.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.900.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#sig=1Bjerrum=1.0r_ion=0.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#Bjerrum=10.0Bjerrum=10.0r_ion=0.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#Bjerrum=7.0Bjerrum=7.0r_ion=0.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#Bjerrum=5.0Bjerrum=5.0r_ion=0.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)	###Submit new ones from here!#Bjerrum=3.0Bjerrum=3.0r_ion=0.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)Bjerrum=100.0r_ion=0.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','4.000','5.000']#for z in zetas:#	filename='1000_ss_zeta_'+z+'.gz'#	CDF(filename,r_ion)##############Bjerrum=0.5#Bjerrum=0.5#r_ion=0.5#M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#sig=5Bjerrum=1.0r_ion=2.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)###GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)###GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)##GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.311.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#sig=6Bjerrum=1.0r_ion=3.0M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.350.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.600.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.670.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.800.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#sig=8Bjerrum=1.0r_ion=4.0M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.870.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)##VALIDBjerrum=7.0r_ion=3.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#R5Bjerrum=0.1r_ion=7.5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)###ASYMMETRIC SIZE: sig = 1,2Bjerrum=1.0r_ion=[0.5,1.0]M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.776.gz',Bjerrum,502,0.12345,M)#ASYMMETRIC SIZE: sig = 1,3Bjerrum=1.0r_ion=[0.5,1.5]M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.250.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.100.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_5.000.gz',Bjerrum,502,r_ion,M)	#Set of uncharged particle debugging dataBjerrum=1.0M=10#GC_System('1000_ss_phis_0.047.gz',Bjerrum,502,4.0,M)#GC_System('1000_ss_phis_0.093.gz',Bjerrum,502,5.0,M)#GC_System('1000_ss_phis_0.203.gz',Bjerrum,502,6.5,M)#GC_System('1000_ss_phis_0.254.gz',Bjerrum,502,7.0,M)#GC_System('1000_ss_phis_0.380.gz',Bjerrum,502,8.0,M)#GC_System('1000_ss_phis_0.540.gz',Bjerrum,502,9.0,M)#GC_System('1000_ss_phis_0.740.gz',Bjerrum,502,10.0,M)total_runs=0##sig 8 --> Good to go#zetas=['0.000','0.500','1.000','1.500','1.870','2.500']#zetas=['0.000','0.500','1.500','2.500']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.870','2.000','2.250','2.500']#total_runs+=len(zetas)#Plot_Analysis(zetas)#sig 7#zetas=['0.000','0.500','1.000','2.000','2.200','3.000']#zetas=['0.000','0.500','1.000','2.200','3.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.100','2.200','2.300','2.500','2.600','2.750','2.900','3.000']#,'3.500']#total_runs+=len(zetas)#Plot_Analysis(zetas)#sig 6 #zetas=['0.000','0.500','1.000','2.000','2.670','3.000']#zetas=['0.000','0.500','1.000','2.000','3.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.250','2.350','2.500','2.600','2.670','2.750','2.800','3.000','3.500']#total_runs+=len(zetas)#Plot_Analysis(zetas)#sig 5#zetas=['0.000','0.500','1.000','2.000','3.311','4.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.311','3.500','4.000','5.000']##total_runs+=len(zetas)##zetas=['0.000','0.500','1.000','2.000','3.311','4.000','5.000'] #CDF#Plot_Analysis(zetas)#sig 2 L = 500 ***UNGENERATED RESULTS#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#sig 2 L = 100 ***UNGENERATED RESULTS#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#sig 1 - #***BE SURE TO INCLUDE 1400 LATTICE Data*#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000']#,'3.500','4.000','5.000']#zetas=['1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#########zetas=['0.000','1.000','2.000','3.000','4.000','5.000']#zetas=['2.500']#total_runs+=len(zetas)#Plot_Analysis(zetas)#VALID#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.250','2.500','2.750','3.000','3.500','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#lam_B 1000.0 ##Results to be obtained#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','4.000','5.000']#zetas=['0.000','1.000','2.000','3.000','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#lam_B 100.0 ##Results to be obtained#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','4.000','5.000']#print 'Still need to MATLAB solve for 1.5 and 2.5'#zetas=['0.000','0.500','1.000','2.000','3.000','3.500','4.000','5.000']#zetas=['0.000','1.000','2.000','3.000','4.000','5.000']#total_runs+=len(zetas)#zetas=['0.000','0.500','1.000','1.500','2.000']#Plot_Analysis(zetas)#lam_B 10.0#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.250','2.500','2.750','3.000','3.250','3.500','4.000','5.000']#zetas=['0.000','0.500','1.000','2.000','3.000','4.000','5.000']#zetas=['0.000','0.500','1.000','2.000','3.000','4.000']#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#lam_B 7.0#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.250','2.500','2.750','3.000','3.250','3.500','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#lam_B 5.0#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#lam_B 5.0, sig = 1.0#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','5.000']#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000']#total_runs+=len(zetas)##zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','5.000']#Plot_Analysis(zetas)##NEW!#lam_B 5.0, sig = 2.0zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','5.000']#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000']#total_runs+=len(zetas)zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','5.000']#Plot_Analysis(zetas)#lam_B 3.0#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.250','2.500','2.750','3.000','3.250','3.500','4.000','5.000']#total_runs+=len(zetas)#Plot_Analysis(zetas)#lam_B 0.5 #zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#total_runs+=len(zetas)#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000']#Plot_Analysis(zetas)#print total_runs#lam_B 0.1 --> ##Results not yet obtained#zetas=['0.000','0.250','0.500','1.000','1.250','2.000']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#Plot_Analysis(zetas)#sigr=2#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#zetas=['0.000','0.500','1.000','2.000','3.000','4.000','5.000']#Plot_Analysis(zetas)#sigr=3#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000','3.500','4.000','5.000']#zetas=['0.000','0.500','1.000','2.000','3.000','4.000']#Plot_Analysis(zetas)###Phi_bulk = sig_HS^3/(24lam_B**lam_D^2)#Phi_bulk_0.185, (LD,LB,sig) = (3sig,0.1,5.4)		LAMMPS_GC_inputfile_implicit(Bjerrum=0.1,lam_D_spec=16.2,sig_WCA=5.4,L_z=502,N_tot=800,zetas=[z],opt_cut=20)zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500']#zetas=['0.000','0.500','1.000','1.500']#zetas=['0.250']#,'0.750','1.250']#Plot_Analysis(zetas)#Phi_bulk_0.185, (LD,LB,sig) = (4sig,0.1,9.6)		LAMMPS_GC_inputfile_implicit(Bjerrum=0.1,lam_D_spec=38.4,sig_WCA=9.6,L_z=502,N_tot=800,zetas=[z],opt_cut=20)	#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000']##zetas=['0.000','0.500','1.000','2.000']#Plot_Analysis(zetas)##Phi_bulk_0.289, (LD,LB,sig) = (5sig,0.1,15.)		LAMMPS_GC_inputfile_implicit(Bjerrum=0.1,lam_D_spec=60.,sig_WCA=15.,L_z=502,N_tot=800,zetas=[z],opt_cut=20)	#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000']#zetas=['0.000','0.500','1.000','2.000']#zetas=['2.000','2.500','2.750','3.000','4.000']#Plot_Analysis(zetas)#Explicit solvent#LAMMPS_GC_inputfile_explicit(Bjerrum=1.0,lam_D_spec=10,sig_WCA=2.0,L_z=102,N_tot=200,N_sol=93000,zetas=[z],opt_cut=60)  #This gives rho*=~0.8Bjerrum=0.1Numbins=502r_ion=2.7#zetas=['0.000','0.250','0.500','0.750']#zetas=['1.000','1.250','1.500']#zetas=['1.750','2.000']#zetas=['0.250','0.500','0.750']#zetas=['1.250','1.500']#zetas=['1.750','2.000']#zetas=['2.750','3.000','2.500']#zetas=['3.500','3.776','4.000','5.000']#zetas=['4.000']#zetas=['5.000']#zetas=['0.000','0.250','0.500','0.750']#zetas=['1.000','1.250','1.500']#zetas1=['0.000']#LAMMPS_GC_inputfile_implicit(Bjerrum=1000.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=800,zetas=zetas1,opt_cut=150)#zetas1=['0.000','1.000','5.000','1.500']#LAMMPS_GC_inputfile_implicit(Bjerrum=1000.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=800,zetas=zetas1,opt_cut=375)#zetas1=['4.000','2.000','2.500']#LAMMPS_GC_inputfile_implicit(Bjerrum=1000.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=800,zetas=zetas1,opt_cut=375)#zetas1=['3.000','3.500','0.500']#LAMMPS_GC_inputfile_implicit(Bjerrum=1000.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=800,zetas=zetas1,opt_cut=375)Bjerrum=1.0r_ion = 0.5#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.250','2.500','2.750','3.000','3.250','3.500','4.000','5.000']#zetas=['0.000','0.500']#zetas=['1.000','1.500']#zetas=['2.000']#zetas=['2.500']#zetas=['0.000','0.500','1.000']#zetas=['2.500','4.000']#zetas=['3.500','2.000','3.000']#zetas=['5.000','1.500']#zetas=['3.776']#zetas=['0.000','0.250','0.500','0.750','1.000','1.250','1.500','1.750','2.000','2.500','2.750','3.000']#,'3.500','4.000','5.000']Bjerrum=100.0r_ion = 0.5##zetas=['0.000','0.250','0.500']##zetas=['0.750','1.000','1.250']##zetas=['1.500','1.750','2.000','2.250']##zetas=['2.500','2.750','3.000']##zetas=['3.500','4.000','5.000','3.250']#zetas=['0.000','0.500']##zetas=['1.000','1.500']##zetas=['2.000','2.500']##zetas=['3.000','3.500']#zetas=['4.000','5.000']]#zetas=['0.500']#zetas=['2.000']#zetas=['0.250']#zetas=['3.000']#zetas=['4.000']#zetas=['5.000']#zetas=['2.500','3.000','3.500','5.000']#zetas=['0.050']Bjerrum=3.0r_ion = 0.5#zetas=['0.000','0.050']+['0.125']#zetas=['0.250']+['0.500']#zetas=['0.000','0.500','1.000','1.500','2.000','2.500','3.000','3.500','5.000']#zetas=['1.000','1.500']zetas=['0.500']zetas=['1.500']zetas=['2.500']zetas=['0.000','0.050','0.125','0.250','0.500']#,'1.000','1.500','2.000','2.500']#Plot_Analysis(zetas)#Bjerrum=20.0#r_ion = 0.5#zetas=['3.000']#zetas=['3.500']#zetas=['6.000']Bjerrum=0.025r_ion = 1.5#zetas=['2.000']#zetas=['2.500']#zetas=['2.750']#zetas=['3.000']#zetas=['0.000','4.000']zetas=['5.000']#,'6.000']#zetas=['1.000']#zetas=['2.500']#zetas=['3.000']#zetas=['3.500']#zetas=['4.500']#zetas=['2.000','2.500']zetas=['S.110']#zetas=['S.107']#zetas=['S.105']#zetas=['S.104']#zetas=['S.103']#zetas=['S.102']#zetas=['S.101']#zetas=['S.100']#LAMMPS_GC_inputfile_implicit(Bjerrum=20.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=1000,zetas=zW,opt_cut=85)#LAMMPS_GC_inputfile_implicit(Bjerrum=40.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=1000,zetas=zW,opt_cut=100)#LAMMPS_GC_inputfile_implicit(Bjerrum=60.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=1000,zetas=zW,opt_cut=120)#LAMMPS_GC_inputfile_implicit(Bjerrum=80.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=1000,zetas=zW,opt_cut=130)#for z in zetas:###	###filename='1000_ss_zeta_'+z+'.txt'#	filename='1000_ss_zeta_'+z+'.gz'#	GC_System(filename,Bjerrum,Numbins,r_ion,10)#	CDF(filename,r_ion)#	GC_System_noerror_restore(filename,Bjerrum,Numbins,r_ion)#	LAMMPS_GC_inputfile_implicit(Bjerrum=0.1,lam_D_spec=15.0,sig_WCA=3.0,L_z=502,N_tot=1000,zetas=[z],opt_cut=15)#	LAMMPS_GC_inputfile_implicit(Bjerrum=0.025,lam_D_spec=30.0,sig_WCA=3.0,L_z=502,N_tot=1000,zetas=[z],opt_cut=15)#	LAMMPS_GC_inputfile_implicit(Bjerrum=100.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=800,zetas=[z],opt_cut=150)#	LAMMPS_GC_inputfile_implicit(Bjerrum=1.0,lam_D_spec=10.0,sig_WCA=2.0,L_z=102,N_tot=800,zetas=[z],opt_cut=15)#	LAMMPS_GC_inputfile_implicit(Bjerrum=1.0,lam_D_spec=10.0,sig_WCA=2.0,L_z=502,N_tot=800,zetas=[z],opt_cut=15)#	LAMMPS_GC_inputfile_implicit(Bjerrum=0.1,lam_D_spec=60.,sig_WCA=15.,L_z=502,N_tot=800,zetas=[z],opt_cut=20)#	LAMMPS_GC_inputfile_explicit(Bjerrum=1.0,lam_D_spec=10,sig_WCA=2.0,L_z=102,N_tot=400,N_sol=93000,zetas=[z],opt_cut=20)#	LAMMPS_GC_inputfile_explicit(Bjerrum=1.0,lam_D_spec=10,sig_WCA=2.0,L_z=102,N_tot=200,N_sol=93000,zetas=[z],opt_cut=60)  #This gives rho*=~0.8#	LAMMPS_GC_inputfile_explicit(Bjerrum=1.0,lam_D_spec=10,sig_WCA=2.0,L_z=102,N_tot=200,N_sol=93000,zetas=[z],opt_cut=60)  #This gives rho*=~0.8#	LAMMPS_GC_inputfile_implicit(Bjerrum=5.0,lam_D_spec=20.0,sig_WCA=1.0,L_z=502,N_tot=800,zetas=[z],opt_cut=15)#	LAMMPS_GC_inputfile_implicit(Bjerrum=20.0,lam_D_spec=10.0,sig_WCA=1.0,L_z=502,N_tot=1000,zetas=[z],opt_cut=15)#import random#N_type_needed = 18#Lx = 11.8663*2#Ly=Lx#zlo = -20#zhi = 20#for i in range(N_type_needed): #Create positions for i particles#		x=random.uniform(-0.5*Lx,0.5*Lx)#		y=random.uniform(-0.5*Ly,0.5*Ly)#		z=random.uniform(zlo,zhi)#		print "create_atoms	%i single %1.2f %1.2f %1.2f units box" % (2,x,y,z)#		print "create_atoms	%i single %1.2f %1.2f %1.2f units box" % (1,x,y,-z)#ASYMMETRIC SIZE: sig = 1,2Bjerrum=0.1r_ion=[0.5*2.311031,0.5*3.4665469857] #1.5r_ion=[0.5*1.81712,0.5*3.634246] #2r_ion=[0.5*1.244741513,0.5*3.734224540] #3r_ion=[0.5*0.94007,0.5*3.760284664] #4r_ion=[0.5*0.7539484789,0.5*3.7697423947] #5M=10#GC_System('1000_ss_zeta_0.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_0.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_1.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_2.750.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.000.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_3.500.gz',Bjerrum,502,r_ion,M)#GC_System('1000_ss_zeta_4.000.gz',Bjerrum,502,r_ion,M)#filenameS = ['in.LB_0.1_sigr_1.5_zeta_4.00','in.LB_0.1_sigr_1.5_zeta_3.50','in.LB_0.1_sigr_1.5_zeta_3.00','in.LB_0.1_sigr_1.5_zeta_2.75','in.LB_0.1_sigr_1.5_zeta_2.50','in.LB_0.1_sigr_1.5_zeta_2.00','in.LB_0.1_sigr_1.5_zeta_1.75','in.LB_0.1_sigr_1.5_zeta_1.50','in.LB_0.1_sigr_1.5_zeta_1.00','in.LB_0.1_sigr_1.5_zeta_0.50','in.LB_0.1_sigr_1.5_zeta_0.00']#filenameS = ['in.LB_0.1_sigr_2.0_zeta_4.00','in.LB_0.1_sigr_2.0_zeta_3.50','in.LB_0.1_sigr_2.0_zeta_3.00','in.LB_0.1_sigr_2.0_zeta_2.75','in.LB_0.1_sigr_2.0_zeta_2.50','in.LB_0.1_sigr_2.0_zeta_2.00','in.LB_0.1_sigr_2.0_zeta_1.75','in.LB_0.1_sigr_2.0_zeta_1.50','in.LB_0.1_sigr_2.0_zeta_1.00','in.LB_0.1_sigr_2.0_zeta_0.50','in.LB_0.1_sigr_2.0_zeta_0.00']#filenameS = ['in.LB_0.1_sigr_3.0_zeta_4.00','in.LB_0.1_sigr_3.0_zeta_3.50','in.LB_0.1_sigr_3.0_zeta_3.00','in.LB_0.1_sigr_3.0_zeta_2.75','in.LB_0.1_sigr_3.0_zeta_2.50','in.LB_0.1_sigr_3.0_zeta_2.00','in.LB_0.1_sigr_3.0_zeta_1.75','in.LB_0.1_sigr_3.0_zeta_1.50','in.LB_0.1_sigr_3.0_zeta_1.00','in.LB_0.1_sigr_3.0_zeta_0.50','in.LB_0.1_sigr_3.0_zeta_0.00']#filenameS = ['in.LB_0.1_sigr_4.0_zeta_4.00','in.LB_0.1_sigr_4.0_zeta_3.50','in.LB_0.1_sigr_4.0_zeta_3.00','in.LB_0.1_sigr_4.0_zeta_2.75','in.LB_0.1_sigr_4.0_zeta_2.50','in.LB_0.1_sigr_4.0_zeta_2.00','in.LB_0.1_sigr_4.0_zeta_1.75','in.LB_0.1_sigr_4.0_zeta_1.50','in.LB_0.1_sigr_4.0_zeta_1.00','in.LB_0.1_sigr_4.0_zeta_0.50','in.LB_0.1_sigr_4.0_zeta_0.00']#filenameS = ['in.LB_0.1_sigr_5.0_zeta_4.00','in.LB_0.1_sigr_5.0_zeta_3.50','in.LB_0.1_sigr_5.0_zeta_3.00','in.LB_0.1_sigr_5.0_zeta_2.75','in.LB_0.1_sigr_5.0_zeta_2.50','in.LB_0.1_sigr_5.0_zeta_2.00','in.LB_0.1_sigr_5.0_zeta_1.75','in.LB_0.1_sigr_5.0_zeta_1.50','in.LB_0.1_sigr_5.0_zeta_1.00','in.LB_0.1_sigr_5.0_zeta_0.50','in.LB_0.1_sigr_5.0_zeta_0.00']#for name in filenameS:#	qsubname=name[10:]#	qsub_file=file(qsubname+'.sh',"w")#	qsub_file.write("""##!/bin/bash####$ -V##$ -cwd##$ -j y##$ -S /bin/bash#""")  #	numProc = 2#	qsub_file.write('#$ -N %s\n#$ -pe ompi %s\n\ndate' % (qsubname,str(numProc)))#   	qsub_file.write('\nhostname\nCURDIR=$(pwd)\n')	#	qsub_file.write('TMPDIR=/state/partition1/$JOB_NAME\nmkdir $TMPDIR')#	qsub_file.write('\ncp -rf $CURDIR/*%s* $TMPDIR/.\ncp EDLC* $TMPDIR/.\ncd $TMPDIR\n\n' % qsubname)##	#Uncomment below for initial optimization - multiple processor	 5#	qsub_file.write('\nmpiexec -np %s /share/apps/scripts/lmp_carmichael_mpi -in %s >> THERMO_%s.txt\n' % (str(numProc),name,qsubname))#	qsub_file.write('\nwait\npython data_%s.py\nwait\n' % (qsubname))#	qsub_file.write('\nmv $TMPDIR/* $CURDIR/.\nwait\nrm -rf $TMPDIR')#    	qsub_file.close()#    	print 'smartsubmit -p %s %s.sh\nsleep 3' % (str(numProc),str(qsubname))